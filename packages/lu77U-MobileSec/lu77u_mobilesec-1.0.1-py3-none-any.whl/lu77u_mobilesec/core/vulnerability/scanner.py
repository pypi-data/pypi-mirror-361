#!/usr/bin/env python3
"""
Vulnerability Scanner Module

This module provides comprehensive vulnerability scanning functionality
for Android applications across different frameworks.
"""

import re
from typing import Dict, List
from ...constants.vulnerabilities import VULNERABILITY_KEYWORDS


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for Android applications"""
    
    def __init__(self, debug: bool = False):
        """Initialize vulnerability scanner"""
        self.debug = debug
    
    def pattern_based_vulnerability_scan(self, files_content: Dict[str, str]) -> List[Dict]:
        """üîç MAIN SCANNER: Comprehensive pattern-based vulnerability scanner for all security issues"""
        
        if self.debug:
            print("üîç DEBUG: Starting comprehensive pattern-based vulnerability scan")
        
        # Check what files we have
        java_files_count = len(files_content["java_files"])
        layout_files_count = len(files_content["layout_files"])
        
        if self.debug:
            print(f"üîç DEBUG: Scanning {java_files_count} Java files and {layout_files_count} layout files")
        
        if java_files_count == 0:
            print("‚ö†Ô∏è  No Java files found for pattern scanning")
        
        vulnerabilities = []
        
        # 1. XSS patterns in WebView usage
        xss_patterns = [
            (r'\.loadUrl\s*\(\s*[^"\']*\+', 'loadUrl with concatenated user input'),
            (r'\.loadData\s*\(\s*[^"\']*\+', 'loadData with concatenated user input'),
            (r'\.evaluateJavascript\s*\(\s*[^"\']*\+', 'evaluateJavascript with concatenated user input'),
            (r'webView\.loadUrl\s*\(\s*getIntent\(\)', 'WebView loading URL from Intent'),
            (r'webView\.loadData\s*\(\s*.*getString', 'WebView loading data from user input'),
            (r'webView\.loadData\s*\(\s*userInput', 'WebView loading user input directly'),
            (r'\.loadData\s*\(\s*userInput', 'loadData with direct user input'),
            (r'addJavascriptInterface\s*\(', 'JavaScript interface enabled'),
        ]
        
        # 2. SQL Injection patterns
        sql_patterns = [
            (r'SELECT.*\+.*WHERE', 'SQL query with string concatenation'),
            (r'INSERT.*\+.*VALUES', 'INSERT query with string concatenation'),
            (r'UPDATE.*\+.*SET', 'UPDATE query with string concatenation'),
            (r'DELETE.*\+.*WHERE', 'DELETE query with string concatenation'),
            (r'rawQuery\s*\(\s*[^"\']*\+', 'rawQuery with concatenated input'),
            (r'execSQL\s*\(\s*[^"\']*\+', 'execSQL with concatenated input'),
        ]
        
        # 3. Hardcoded secrets patterns
        secret_patterns = [
            (r'(?i)(api[_-]?key|apikey)\s*[=:]\s*["\'][^"\']{8,}["\']', 'Hardcoded API key'),
            (r'(?i)(password|pwd)\s*[=:]\s*["\'][^"\']{4,}["\']', 'Hardcoded password'),
            (r'(?i)(secret|token)\s*[=:]\s*["\'][^"\']{8,}["\']', 'Hardcoded secret/token'),
            (r'(?i)(aws_access_key|aws_secret)', 'AWS credentials'),
            (r'(?i)(private_key|privatekey)\s*[=:]\s*["\'][^"\']{20,}["\']', 'Hardcoded private key'),
            (r'["\'][A-Za-z0-9]{32,}["\'](?![^@]*@Metadata)', 'Potential hardcoded secret (long string)'),
        ]
        
        # 4. Insecure network communication
        network_patterns = [
            (r'http://[^"\']*["\']', 'HTTP URL (insecure communication)'),
            (r'setHostnameVerifier\s*\(\s*new\s+HostnameVerifier', 'Custom hostname verifier'),
            (r'trustAllCerts|TrustAllCerts', 'Trust all certificates'),
            (r'ALLOW_ALL_HOSTNAME_VERIFIER', 'Allow all hostname verifier'),
            (r'\.setSSLSocketFactory\s*\(', 'Custom SSL socket factory'),
        ]
        
        # 5. Weak cryptography patterns
        crypto_patterns = [
            (r'MessageDigest\.getInstance\s*\(\s*["\']MD5["\']', 'MD5 hash algorithm (weak)'),
            (r'MessageDigest\.getInstance\s*\(\s*["\']SHA1["\']', 'SHA1 hash algorithm (weak)'),
            (r'Cipher\.getInstance\s*\(\s*["\']DES["\']', 'DES encryption (weak)'),
            (r'Cipher\.getInstance\s*\(\s*["\']RC4["\']', 'RC4 encryption (weak)'),
            (r'new\s+Random\s*\(', 'Insecure random number generator'),
        ]
        
        # 6. Code injection patterns
        injection_patterns = [
            (r'Runtime\.getRuntime\(\)\.exec\s*\([^)]*\+', 'Runtime.exec with user input'),
            (r'ProcessBuilder\s*\([^)]*\+', 'ProcessBuilder with user input'),
            (r'Class\.forName\s*\([^)]*\+', 'Dynamic class loading with user input'),
        ]
        
        # 7. Path traversal patterns
        path_patterns = [
            (r'new\s+File\s*\([^)]*\+', 'File creation with user input'),
            (r'FileInputStream\s*\([^)]*\+', 'FileInputStream with user input'),
            (r'FileOutputStream\s*\([^)]*\+', 'FileOutputStream with user input'),
        ]
        
        # 8. WebView security issues
        webview_patterns = [
            (r'setJavaScriptEnabled\s*\(\s*true\s*\)', 'JavaScript enabled in WebView'),
            (r'setAllowFileAccess\s*\(\s*true\s*\)', 'File access enabled in WebView'),
            (r'setAllowContentAccess\s*\(\s*true\s*\)', 'Content access enabled in WebView'),
            (r'setMixedContentMode\s*\(\s*MIXED_CONTENT_ALWAYS_ALLOW', 'Mixed content allowed'),
        ]
        
        # 9. Insecure data storage patterns
        storage_patterns = [
            (r'MODE_WORLD_READABLE', 'World readable file mode'),
            (r'MODE_WORLD_WRITEABLE', 'World writeable file mode'),
            (r'getExternalStorageDirectory', 'External storage usage'),
            (r'openFileOutput\s*\([^,]*,\s*MODE_WORLD', 'World accessible file'),
        ]
        
        # Combine all patterns
        all_patterns = [
            ('XSS', xss_patterns),
            ('SQL Injection', sql_patterns),
            ('Hardcoded Secrets', secret_patterns),
            ('Insecure Network', network_patterns),
            ('Weak Cryptography', crypto_patterns),
            ('Code Injection', injection_patterns),
            ('Path Traversal', path_patterns),
            ('WebView Security', webview_patterns),
            ('Insecure Storage', storage_patterns),
        ]
        
        if self.debug:
            print(f"üîç DEBUG: Defined {len(all_patterns)} vulnerability pattern categories")
        
        # Scan Java files for all vulnerability patterns
        for file_name, content in files_content["java_files"].items():
            for category, patterns in all_patterns:
                for pattern, description in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                    for match in matches:
                        # Find line number
                        line_number = content[:match.start()].count('\n') + 1
                        
                        vulnerabilities.append({
                            'vulnerability_type': category,
                            'file': file_name,
                            'line_number': line_number,
                            'code_snippet': match.group(0),
                            'description': description,
                            'severity': self._determine_severity(category),
                            'pattern_matched': pattern
                        })
        
        # Scan layout files for hardcoded secrets and insecure configurations
        for file_name, content in files_content["layout_files"].items():
            # Only scan for hardcoded secrets in layout files
            for pattern, description in secret_patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1
                    
                    vulnerabilities.append({
                        'vulnerability_type': 'Hardcoded Secrets',
                        'file': file_name,
                        'line_number': line_number,
                        'code_snippet': match.group(0),
                        'description': f"Layout file contains {description.lower()}",
                        'severity': 'High',
                        'pattern_matched': pattern
                    })
        
        # Scan AndroidManifest.xml for various security issues
        manifest_content = files_content["android_manifest"]
        if manifest_content:
            manifest_patterns = [
                (r'android:exported="true"', 'Exported component without protection'),
                (r'android:allowBackup="true"', 'Application backup allowed'),
                (r'android:debuggable="true"', 'Debug mode enabled'),
                (r'uses-permission.*WRITE_EXTERNAL_STORAGE', 'External storage write permission'),
                (r'uses-permission.*INTERNET', 'Internet permission (review usage)'),
                (r'android:usesCleartextTraffic="true"', 'Cleartext traffic allowed'),
            ]
            
            for pattern, description in manifest_patterns:
                matches = re.finditer(pattern, manifest_content, re.IGNORECASE)
                for match in matches:
                    line_number = manifest_content[:match.start()].count('\n') + 1
                    
                    vulnerabilities.append({
                        'vulnerability_type': 'Manifest Security',
                        'file': 'AndroidManifest.xml',
                        'line_number': line_number,
                        'code_snippet': match.group(0),
                        'description': description,
                        'severity': self._determine_severity('Manifest Security'),
                        'pattern_matched': pattern
                    })
        
        # Deduplicate vulnerabilities
        seen_vulns = set()
        unique_vulnerabilities = []
        for vuln in vulnerabilities:
            vuln_key = (vuln['vulnerability_type'], vuln['file'], vuln['line_number'], vuln['code_snippet'])
            if vuln_key not in seen_vulns:
                seen_vulns.add(vuln_key)
                unique_vulnerabilities.append(vuln)
        
        if self.debug:
            print(f"üîç DEBUG: Found {len(unique_vulnerabilities)} unique vulnerabilities after deduplication")
        
        return unique_vulnerabilities

    def simple_vulnerability_scan(self, files_content: Dict[str, str]) -> List[Dict]:
        """Simple pattern-based vulnerability detection as backup when AI fails"""
        if self.debug:
            print("üîç DEBUG: Running simple vulnerability scan (backup method)")
        
        vulnerabilities = []
        
        # XSS patterns in WebView
        xss_patterns = [
            r'webView\.loadUrl\s*\(',
            r'webView\.loadData\s*\(',
            r'webView\.loadDataWithBaseURL\s*\(',
            r'webView\.evaluateJavascript\s*\(',
            r'addJavascriptInterface\s*\(',
        ]
        
        # SQL Injection patterns
        sql_patterns = [
            r'rawQuery\s*\([^)]*\+',
            r'execSQL\s*\([^)]*\+',
            r'"SELECT.*"\s*\+',
            r'"INSERT.*"\s*\+',
            r'"UPDATE.*"\s*\+',
            r'"DELETE.*"\s*\+',
        ]
        
        # Hardcoded secrets patterns
        secret_patterns = [
            r'password\s*=\s*"[^"]+',
            r'api_key\s*=\s*"[^"]+',
            r'secret\s*=\s*"[^"]+',
            r'token\s*=\s*"[^"]+',
        ]
        
        # Check Java files
        for file_path, content in files_content["java_files"].items():
            # Check for XSS
            for pattern in xss_patterns:
                if re.search(pattern, content):
                    vulnerabilities.append({
                        'vulnerability_type': 'XSS',
                        'file': file_path,
                        'description': 'Potential XSS vulnerability in WebView',
                        'severity': 'High'
                    })
            
            # Check for SQL Injection
            for pattern in sql_patterns:
                if re.search(pattern, content):
                    vulnerabilities.append({
                        'vulnerability_type': 'SQL Injection',
                        'file': file_path,
                        'description': 'Potential SQL injection vulnerability',
                        'severity': 'High'
                    })
            
            # Check for hardcoded secrets
            for pattern in secret_patterns:
                if re.search(pattern, content):
                    vulnerabilities.append({
                        'vulnerability_type': 'Hardcoded Secrets',
                        'file': file_path,
                        'description': 'Hardcoded credential found',
                        'severity': 'Medium'
                    })
        
        # Check AndroidManifest for dangerous permissions
        manifest_content = files_content.get("android_manifest", "")
        if manifest_content:
            dangerous_permissions = [
                'WRITE_EXTERNAL_STORAGE',
                'READ_EXTERNAL_STORAGE',
                'CAMERA',
                'RECORD_AUDIO',
                'ACCESS_FINE_LOCATION'
            ]
            
            for permission in dangerous_permissions:
                if permission in manifest_content:
                    vulnerabilities.append({
                        'vulnerability_type': 'Dangerous Permission',
                        'file': 'AndroidManifest.xml',
                        'description': f'Dangerous permission: {permission}',
                        'severity': 'Medium'
                    })
        
        return vulnerabilities
    
    def _determine_severity(self, vulnerability_type: str) -> str:
        """Determine severity based on vulnerability type"""
        high_severity = ['XSS', 'SQL Injection', 'Code Injection', 'Hardcoded Secrets']
        medium_severity = ['Insecure Network', 'Weak Cryptography', 'Path Traversal', 'WebView Security']
        
        if vulnerability_type in high_severity:
            return 'High'
        elif vulnerability_type in medium_severity:
            return 'Medium'
        else:
            return 'Low'
