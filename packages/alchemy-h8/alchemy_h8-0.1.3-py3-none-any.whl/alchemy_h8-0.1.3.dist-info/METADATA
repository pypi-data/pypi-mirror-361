Metadata-Version: 2.4
Name: alchemy-h8
Version: 0.1.3
Summary: Advanced SQLAlchemy extension with connection pooling, rate limiting, and security features
Project-URL: Documentation, https://github.com/Harut8/alchemy_h8#readme
Project-URL: Issues, https://github.com/Harut8/alchemy_h8/issues
Project-URL: Source, https://github.com/Harut8/alchemy_h8
Author-email: Harut <har.avetisyan2002@gmail.com>
License: MIT
Keywords: async,connection-pooling,database,postgresql,rate-limiting,sqlalchemy
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Database
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Typing :: Typed
Requires-Python: >=3.11
Requires-Dist: asyncpg>=0.30.0
Requires-Dist: greenlet>=3.2.3
Requires-Dist: pydantic>=2.11.7
Requires-Dist: sqlalchemy>=2.0.41
Requires-Dist: structlog>=25.4.0
Requires-Dist: tenacity>=9.1.2
Provides-Extra: dev
Requires-Dist: black>=24.4.0; extra == 'dev'
Requires-Dist: flake8>=7.0.0; extra == 'dev'
Requires-Dist: isort>=5.13.2; extra == 'dev'
Requires-Dist: mypy>=1.8.0; extra == 'dev'
Requires-Dist: pytest-asyncio>=0.23.5; extra == 'dev'
Requires-Dist: pytest-cov>=5.0.0; extra == 'dev'
Requires-Dist: pytest>=8.4.1; extra == 'dev'
Requires-Dist: sphinx-rtd-theme>=2.0.0; extra == 'dev'
Requires-Dist: sphinx>=7.3.7; extra == 'dev'
Requires-Dist: sqlalchemy-stubs>=0.4; extra == 'dev'
Provides-Extra: test
Requires-Dist: pytest-asyncio>=0.23.5; extra == 'test'
Requires-Dist: pytest-cov>=5.0.0; extra == 'test'
Requires-Dist: pytest>=8.4.1; extra == 'test'
Description-Content-Type: text/markdown

# Advanced SQLAlchemy Connection Architecture

## Overview

This document explains the architectural decisions behind the robust async SQLAlchemy connection management system implemented in `alchemy_h8/connection.py`. It details why our comprehensive solution significantly outperforms simple connection handling approaches in production environments.

## Why Simple Connection Handling Is Insufficient

A simple connection approach typically looks like this:

```python
async def get_db_session():
    async_session = sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False)
    try:
        async with async_session() as session:
            yield session
    except Exception as e:
        logger.error(f"Database error: {str(e)}")
        raise
```

While this works for basic applications, it falls short in critical production environments for numerous reasons detailed below.

## Architectural Edge Cases & Advanced Features

### 1. Connection Lifecycle Management

**Simple Approach Limitation:**
- Connections are created and destroyed without tracking
- No visibility into connection states or lifetimes
- Connection leaks go undetected until pool exhaustion

**Our Solution:**
- Comprehensive connection tracking via weakrefs
- Full connection lifecycle observability with timestamps
- Automatic detection and cleanup of long-lived connections
- Proactive connection health checking

```python
# From our implementation
async def _register_connection(self, conn: AsyncConnection) -> None:
    async with self._connection_track_lock:
        conn_id = id(conn)
        self._active_connections[conn_id] = conn
        self._connection_creation_times[conn_id] = time.time()
```

### 2. Resilience & Fault Tolerance

**Simple Approach Limitation:**
- Single point of failure with no retry mechanisms
- Database blips cause cascading application failures
- No protection against connection overload

**Our Solution:**
- Circuit breaker pattern prevents cascading failures
- Exponential backoff retry logic with configurable parameters
- Connection timeouts prevent indefinite hanging
- Statement timeouts at driver level prevent query hanging

```python
# Circuit breaker implementation
def _setup_circuit_breaker(self) -> None:
    self._circuit_breaker = CircuitBreaker(
        failure_threshold=self.config.circuit_breaker_threshold,
        recovery_timeout=self.config.circuit_breaker_timeout,
        name="db_circuit",
        logger=self.logger,
    )
```

### 3. Advanced Connection Pooling

**Simple Approach Limitation:**
- Relies solely on SQLAlchemy's default pool behavior
- No proactive pool management or optimization
- Unable to detect pool exhaustion before failures

**Our Solution:**
- Optimized pool configuration based on workload
- Idle connection management to prevent resource waste
- Periodic pool statistics reporting for diagnostics
- Automatic pool reconfiguration on demand

```python
# Connection pool monitoring
async def _check_stale_connections(self) -> None:
    # Regular diagnostics about connection pool state
    self.logger.info(f"Stale connection check: {len(connection_ids)} tracked connections")
    
    # Pool statistics logging
    if self._async_engine:
        try:
            pool = self._async_engine.pool
            self.logger.info(f"Pool stats - Size: {pool.size()}, Overflow: {pool.overflow()}")
        except Exception as e:
            self.logger.error(f"Error getting pool stats: {str(e)}")
```

### 4. Graceful Shutdown Management

**Simple Approach Limitation:**
- No handling of application shutdown scenarios
- In-flight connections are abruptly terminated
- Potential for data loss during shutdowns

**Our Solution:**
- Signal handlers for graceful shutdown
- Managed connection disposal process
- In-flight transaction completion before shutdown
- Comprehensive shutdown logging

```python
def setup_signal_handlers(self) -> None:
    """Set up signal handlers for graceful shutdown."""
    self.logger.info(f"Setting up signal handlers for platform {sys.platform}")
    
    def handle_shutdown_signal(sig, frame):
        """Handle shutdown signals by scheduling DB cleanup."""
        self.logger.info(f"Received shutdown signal {sig}, scheduling database cleanup")
        asyncio.create_task(self.dispose())
```

### 5. Concurrent Connection Management

**Simple Approach Limitation:**
- No control over concurrent database access
- Database can be overwhelmed during traffic spikes
- No backpressure mechanisms to prevent overload

**Our Solution:**
- Semaphore-based connection limiting
- Dynamic backpressure based on database health
- Fair queuing of connection requests
- Prioritization capabilities for critical operations

```python
# Connection limiting with semaphores
async def get_async_connection(self, read_only: bool = False) -> AsyncGenerator[AsyncConnection, None]:
    # Limit concurrent connections
    if self._connection_semaphore:
        self.logger.debug("Acquiring connection semaphore")
        try:
            await asyncio.wait_for(
                self._connection_semaphore.acquire(),
                timeout=self.config.connection_acquire_timeout
            )
        except asyncio.TimeoutError:
            self.logger.error(f"Timed out waiting for connection semaphore after {self.config.connection_acquire_timeout}s")
            raise ConnectionPoolError("Connection pool exhausted, timed out waiting for connection")
```

### 6. Rate Limiting & Throttling

**Simple Approach Limitation:**
- No protection against excessive database access
- Vulnerable to query storms that can overload database
- No differentiation between query priorities

**Our Solution:**
- Token bucket rate limiting algorithm
- Configurable rate limits per time window
- Automatic cleanup of rate tracking data
- Query priority support for critical operations

```python
# Rate limiting implementation
@retry(retry=retry_if_exception_type(RateLimitExceededError),
       stop=stop_after_attempt(3),
       wait=wait_exponential(multiplier=1, min=1, max=10),
       reraise=True)
async def _check_rate_limit(self) -> None:
    """Check if rate limit is exceeded."""
    if not self.config.use_rate_limiter:
        return

    if self._rate_limiter.exceeded():
        self.logger.warning("Database rate limit exceeded")
        raise RateLimitExceededError("Database rate limit exceeded")
```

### 7. Read/Write Splitting

**Simple Approach Limitation:**
- All queries use same connection regardless of read/write nature
- No optimization for read-heavy workloads
- Inefficient use of database resources

**Our Solution:**
- Automatic read/write operation splitting
- Read replica support with load balancing
- Configurable read replica selection strategies
- Fallback to writer if read replicas unavailable

```python
async def get_engine(self, read_only: bool = False) -> AsyncEngine:
    """Get the appropriate engine based on read/write need."""
    if read_only and self._async_read_replicas:
        # Select read replica using round-robin or another strategy
        replica_index = random.randint(0, len(self._async_read_replicas) - 1)
        return self._async_read_replicas[replica_index]
    
    # Use primary for writes or if no read replicas available
    return self._async_engine
```

### 8. Enhanced Error Handling & Diagnostics

**Simple Approach Limitation:**
- Limited error information for debugging
- No categorization of database errors
- No correlation between related errors

**Our Solution:**
- Comprehensive structured logging of all operations
- Detailed error categorization and handling
- Connection state tracking for debugging
- Correlation IDs for tracking related operations

```python
# Advanced error handling
async def _return_connection_to_pool(self, conn: AsyncConnection) -> None:
    """Attempt to safely return a connection to the pool."""
    try:
        # Protect connection closing from cancellation with shield
        async with async_timeout.timeout(3):  # 3 second timeout for closing
            await asyncio.shield(conn.close())
        self.logger.debug("Connection closed explicitly")
    except Exception as e:
        self.logger.warning(f"Error closing connection: {str(e)}. "
                     f"Connection will be garbage collected by SQLAlchemy.")
```

### 9. Connection Leak Prevention

**Simple Approach Limitation:**
- No protection against connection leaks
- Leaks only detected when pool exhausted
- Resource exhaustion can occur silently

**Our Solution:**
- Active connection tracking with weakrefs
- Timeout-protected connection cleanup
- Periodic stale connection detection
- Forced cleanup of very old connections

```python
# Long-lived connection detection
current_time = time.time()
for conn_id in connection_ids:
    creation_time = self._connection_creation_times.get(conn_id)
    if creation_time:
        lifetime = current_time - creation_time
        if lifetime > self._max_safe_connection_lifetime:
            # Force cleanup of extremely long-lived connections
            self.logger.error(f"Connection alive for {lifetime:.2f}s, exceeding safe lifetime")
            conn = self._active_connections.get(conn_id)
            if conn:
                task = asyncio.create_task(self._return_connection_to_pool(conn))
```

### 10. Cross-Event Loop Safety

**Simple Approach Limitation:**
- Vulnerable to event loop misuse
- No protection against connection sharing across loops
- No handling of event loop shutdown scenarios

**Our Solution:**
- Safe engine handling across event loops
- Protection against misuse of connections in multiple loops
- Proper engine disposal during event loop shutdown

```python
# Connection isolation between event loops
async def initialize(self) -> None:
    """Initialize database engines and connections."""
    self.logger.debug("Initializing database connection handler")
    
    # Engine initialization for current event loop
    await self._initialize_engines()
    
    # Setup background tasks in current loop
    await self._setup_background_tasks()
```

## Common SQLAlchemy, asyncpg, and asyncio Issues

Through extensive research and practical experience, we've identified several critical issues that can affect the reliability, performance, and resource utilization of async database connections. Our architecture is specifically designed to address these issues:

### 1. Connection Leaks During Task Cancellation

**Issue:** When an asyncio task is cancelled while holding a database connection, the connection often isn't properly returned to the pool.

**Evidence:** 
- [SQLAlchemy Issue #8145](https://github.com/sqlalchemy/sqlalchemy/issues/8145) - Async connections not returned to pool if task is cancelled
- [SQLAlchemy Issue #6652](https://github.com/sqlalchemy/sqlalchemy/issues/6652) - asyncpg connections not returned to pool if task is cancelled
- [SQLAlchemy Issue #12077](https://github.com/sqlalchemy/sqlalchemy/issues/12077) - anyio taskgroup cancellation leading to asyncpg connection leak

**Our Solution:**
```python
async def _return_connection_to_pool(self, conn: AsyncConnection) -> None:
    """Safely return connection to pool even during cancellation."""
    try:
        # Shield connection closing from cancellation
        async with async_timeout.timeout(3):  # Timeout for safety
            await asyncio.shield(conn.close())
        self.logger.debug("Connection closed explicitly")
    except Exception as e:
        self.logger.warning(f"Error closing connection: {str(e)}")
```

### 2. Memory Leaks with Connection Pool Overflow

**Issue:** Under high load, when connection pools are constantly overflowing, memory usage can grow uncontrollably, leading to OOM crashes.

**Evidence:**
- [SQLAlchemy Discussion #7058](https://github.com/sqlalchemy/sqlalchemy/discussions/7058) - Memory leak when connection pool is constantly overflown with asyncpg
- [SQLAlchemy Issue #8763](https://github.com/sqlalchemy/sqlalchemy/issues/8763) - Memory leak with asyncpg and Python 3.11

**Our Solution:**
```python
# Limit connection acquisition with semaphores to prevent overflow
self._connection_semaphore = asyncio.Semaphore(self.config.max_connections)

# Track all connections and periodically check for stale ones
async def _check_stale_connections(self) -> None:
    # Regular connection pool monitoring and cleanup
```

### 3. Session and Engine Lifecycle Management

**Issue:** Improper session and engine lifecycle management across event loops can cause resource leaks and unexpected behaviors.

**Evidence:**
- [SQLAlchemy Asyncio Documentation](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html) - Warnings about not sharing AsyncEngine across multiple event loops

**Our Solution:**
```python
# Proper engine disposal on shutdown
async def dispose(self) -> None:
    """Dispose the engine and release all resources."""
    self._dispose_requested.set()
    
    # Cancel any background tasks
    self._cancel_background_tasks()
    
    # Clear connection tracking
    await self._clear_connection_tracking()
    
    # Dispose engines
    if self._async_engine:
        await self._async_engine.dispose()
```

### 4. Inadequate Error Handling

**Issue:** Database operations can fail for many reasons, and without proper error handling, these failures can cascade throughout an application.

**Evidence:**
- [SQLAlchemy Documentation on Error Handling](https://docs.sqlalchemy.org/en/20/core/connections.html#handling-disconnects)

**Our Solution:**
```python
# Comprehensive retry logic with circuit breaker
@retry(
    retry=retry_if_exception_type(exception_types),
    stop=stop_after_attempt(max_attempts),
    wait=wait_exponential(multiplier=backoff, min=min_wait, max=max_wait),
    before=before_retry_log(logger),
    after=after_retry_log(logger),
    reraise=True
)
async def _execute_with_retry(self, func, *args, **kwargs):
    try:
        if self._circuit_breaker and not self._circuit_breaker.is_closed():
            raise CircuitBreakerOpenError("Database circuit breaker is open")
        
        return await func(*args, **kwargs)
    except Exception as e:
        # Handle different error types appropriately
```

### 5. Thread and Event Loop Misuse

**Issue:** Mixing ThreadPoolExecutor with asyncio can lead to deadlocks and nested event loop problems.

**Evidence:**
- Common issue in async applications, evidenced by crashes when mixing thread pools and async code
- Various discussions in SQLAlchemy issue tracker about thread safety

**Our Solution:**
```python
# Proper async design without relying on thread pools for database operations
async def async_session_scope(self, **session_kwargs) -> AsyncGenerator[AsyncSession, None]:
    """Get a scoped session using pure async patterns, avoiding thread pool issues."""
    engine = await self.get_engine()
    connection = None
    
    try:
        # Acquire connection with timeout
        async with async_timeout.timeout(self.config.connection_acquire_timeout):
            connection = await engine.connect()
        
        # Register connection for tracking
        await self._register_connection(connection)
        
        yield connection
    finally:
        # Ensure connection is returned to pool
        if connection:
            try:
                # Shield from cancellation
                await asyncio.shield(self._return_connection_to_pool(connection))
            except Exception as e:
                self.logger.error(f"Failed to properly close connection: {e}")
```

### 6. Connection Timeouts and Hanging Queries

**Issue:** Without proper timeouts, connections and queries can hang indefinitely, tying up resources.

**Evidence:**
- Common issue in production systems, especially under heavy load
- Database driver timeout settings are often overlooked

**Our Solution:**
```python
# Configure statement timeouts at connection level
@event.listens_for(engine, "connect")
def set_connection_defaults(dbapi_connection, connection_record):
    cursor = dbapi_connection.cursor()
    cursor.execute(f"SET statement_timeout = {statement_timeout_ms}")
    cursor.close()
```

### 7. Poor Visibility into Connection State

**Issue:** Without proper tracking and metrics, it's difficult to diagnose connection issues in production.

**Evidence:**
- Common operational challenge in managing database connections at scale

**Our Solution:**
```python
# Comprehensive logging and metrics
async def _check_stale_connections(self) -> None:
    """Periodic check for stale connections with metrics."""
    async with self._connection_track_lock:
        connection_ids = list(self._active_connections.keys())
    
    self.logger.info(
        "Connection pool stats",
        tracked_connections=len(connection_ids),
        total_created=self._total_connections_created,
        total_released=self._total_connections_released,
        max_tracked=self._max_tracked_connections
    )
```

### 8. Cross-Coroutine State Handling

**Issue:** Sharing state across coroutines without proper synchronization can lead to race conditions.

**Evidence:**
- Common pitfall in async programming, particularly with shared resources like connection pools

**Our Solution:**
```python
# Proper locks for shared state
self._connection_track_lock = asyncio.Lock()

# Safe shared state modifications
async with self._connection_track_lock:
    # Modify shared state safely
    self._active_connections[conn_id] = conn
```

### 9. Background Task Management

**Issue:** Background tasks for monitoring and maintenance can become orphaned or interfere with application shutdown.

**Evidence:**
- Common operational challenge in long-running async applications

**Our Solution:**
```python
# Proper background task lifecycle management
async def _setup_background_tasks(self) -> None:
    """Setup background tasks with proper cancellation handling."""
    self._background_tasks = []
    
    # Create background task for connection checking
    stale_check_task = asyncio.create_task(
        self._periodic_task(
            self._check_stale_connections, 
            self.config.stale_connection_check_interval
        )
    )
    self._background_tasks.append(stale_check_task)

# Proper task cancellation
def _cancel_background_tasks(self) -> None:
    """Cancel all background tasks."""
    for task in self._background_tasks:
        if not task.done():
            task.cancel()
```

### 10. Async Context Manager Edge Cases

**Issue:** Async context managers can behave unpredictably during exceptions or cancellations.

**Evidence:**
- [SQLAlchemy Issue #8145](https://github.com/sqlalchemy/sqlalchemy/issues/8145) demonstrates issues with async context managers during cancellation

**Our Solution:**
```python
# Robust context manager implementation
@asynccontextmanager
async def get_async_connection(self, read_only: bool = False) -> AsyncGenerator[AsyncConnection, None]:
    """Get a connection with robust exception handling."""
    engine = await self.get_engine(read_only)
    connection = None
    
    try:
        # Acquire connection with timeout
        async with async_timeout.timeout(self.config.connection_acquire_timeout):
            connection = await engine.connect()
        
        # Register connection for tracking
        await self._register_connection(connection)
        
        yield connection
    finally:
        # Ensure connection is returned to pool
        if connection:
            try:
                # Shield from cancellation
                await asyncio.shield(self._return_connection_to_pool(connection))
            except Exception as e:
                self.logger.error(f"Failed to properly close connection: {e}")
```

These solutions collectively address the most significant issues encountered when working with async database connections in Python, ensuring robust, leak-free operation even under challenging conditions.

## References

For more information on these issues and their solutions, refer to the following resources:

- [SQLAlchemy Asyncio Documentation](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [SQLAlchemy Connection Pooling](https://docs.sqlalchemy.org/en/20/core/pooling.html)
- [Asyncpg Documentation](https://magicstack.github.io/asyncpg/current/)
- [Asyncio Documentation](https://docs.python.org/3/library/asyncio.html)
- [SQLAlchemy Issue #8145: Connection leaks during cancellation](https://github.com/sqlalchemy/sqlalchemy/issues/8145)
- [SQLAlchemy Issue #6652: asyncpg connections not returned to pool during cancellation](https://github.com/sqlalchemy/sqlalchemy/issues/6652)
- [SQLAlchemy Issue #12077: anyio taskgroup cancellation leaking connections](https://github.com/sqlalchemy/sqlalchemy/issues/12077)
- [SQLAlchemy Issue #8763: Memory leak with asyncpg and Python 3.11](https://github.com/sqlalchemy/sqlalchemy/issues/8763)
- [SQLAlchemy Discussion #7058: Memory leak with connection pool overflow](https://github.com/sqlalchemy/sqlalchemy/discussions/7058)

## Conclusion

Building robust database connectivity is far more complex than simply wrapping SQLAlchemy sessions in try/except blocks. Our architecture addresses dozens of edge cases and failure modes that are commonly encountered in production environments with high reliability requirements.

While simpler approaches may work for basic applications, any system with substantial scale, reliability requirements, or complex database interaction patterns will benefit significantly from the comprehensive approach implemented in our solution.

The true value becomes apparent during system stress, partial failures, and edge cases - precisely when you need your database layer to be most reliable.
