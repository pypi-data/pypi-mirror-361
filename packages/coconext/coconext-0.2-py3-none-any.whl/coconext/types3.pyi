from __future__ import annotations

from collections.abc import Iterable, Sequence, Sized
from typing import Literal, Protocol, Self, TypeVar, overload, reveal_type

class Range(Sequence[int]):
    @overload
    def __init__(self, start: int, stop: int) -> None: ...
    @overload
    def __init__(self, start: int, direction: Literal["to", "downto"], stop: int): ...
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, idx: int, /) -> int: ...
    @overload
    def __getitem__(self, idx: slice, /) -> Range: ...
    def __len__(self) -> int: ...

T_co = TypeVar("T_co", covariant=True)
T = TypeVar("T")

class SizedIterable(Sized, Iterable[T_co], Protocol[T_co]): ...

class ArrayLike(Protocol[T_co]):
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, value: object, /) -> bool: ...
    def __iter__(self) -> Iterable[T_co]: ...
    def __reversed__(self) -> Iterable[T_co]: ...
    @overload
    def __getitem__(self, idx: int, /) -> T_co: ...
    @overload
    def __getitem__(self, idx: slice, /) -> Self: ...
    def index(self, value: object, start: int = ..., stop: int = ..., /) -> int: ...
    def count(self, value: object, /) -> int: ...

class MutableArrayLike(ArrayLike[T]):
    @overload
    def __setitem__(self, idx: int, value: T, /) -> None: ...
    @overload
    def __setitem__(self, idx: slice, value: SizedIterable[T], /) -> None: ...

class Array(MutableArrayLike[T]):
    def __init__(self, value: SizedIterable[T_co], /) -> None: ...

class Logic:
    def __init__(self, literal: int | str | bool | Logic, /) -> None: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __and__(self, other: Self, /) -> Self: ...
    def __rand__(self, other: Self, /) -> Self: ...
    def __or__(self, other: Self, /) -> Self: ...
    def __ror__(self, other: Self, /) -> Self: ...
    def __xor__(self, other: Self, /) -> Self: ...
    def __rxor__(self, other: Self, /) -> Self: ...
    def __not__(self) -> Self: ...

class Bit(Logic): ...

LogicT_co = TypeVar("LogicT_co", covariant=True, bound=Logic)
LogicT = TypeVar("LogicT", bound=Logic)

class LogicArrayLike(ArrayLike[LogicT_co]):
    def __and__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __rand__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __or__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __ror__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __xor__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __rxor__(
        self, other: LogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __inv__(self) -> LogicArrayLike[LogicT_co]: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...

class MutableLogicArrayLike(LogicArrayLike[LogicT], MutableArrayLike[LogicT]): ...

class LogicArray(MutableLogicArrayLike[Logic]):
    def __init__(self, value: SizedIterable[int | str | bool | Logic], /) -> None: ...
    def __and__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __rand__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __or__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __ror__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __xor__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __rxor__(self, other: LogicArrayLike[Logic], /) -> LogicArray: ...
    def __inv__(self) -> LogicArray: ...

@LogicArray.register
class BitArray(MutableLogicArrayLike[Bit]):
    def __init__(self, value: SizedIterable[int | str | bool | Logic], /) -> None: ...
    def __and__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __rand__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __or__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __ror__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __xor__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __rxor__(self, other: LogicArrayLike[Bit], /) -> BitArray: ...
    def __inv__(self) -> BitArray: ...

class Unsigned(BitArray): ...
class Signed(BitArray): ...
class Ufixed(BitArray): ...
class Sfixed(BitArray): ...
class Float(BitArray): ...

a: Unsigned
b: Signed
c: LogicArray
d: BitArray
reveal_type(a & d)
reveal_type(d & a)
reveal_type(c & d)
reveal_type(d & c)
reveal_type(a & b)
reveal_type(a & c)
reveal_type(c & a)
