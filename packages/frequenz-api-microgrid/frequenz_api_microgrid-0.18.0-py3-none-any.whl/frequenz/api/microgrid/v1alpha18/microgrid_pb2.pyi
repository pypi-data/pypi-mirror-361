"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Microgrid API

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1alpha8.metrics.bounds_pb2
import frequenz.api.common.v1alpha8.metrics.metrics_pb2
import frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2
import frequenz.api.common.v1alpha8.microgrid.microgrid_pb2
import frequenz.api.common.v1alpha8.microgrid.sensors.sensors_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _PowerType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _PowerTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PowerType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    POWER_TYPE_UNSPECIFIED: _PowerType.ValueType  # 0
    """Default value. Users are discouraged from using this value. Using this will
    result in an error.
    """
    POWER_TYPE_ACTIVE: _PowerType.ValueType  # 1
    """The requested power is active power."""
    POWER_TYPE_REACTIVE: _PowerType.ValueType  # 2
    """The requested power is reactive power."""

class PowerType(_PowerType, metaclass=_PowerTypeEnumTypeWrapper):
    """The type of power requested for an electrical component."""

POWER_TYPE_UNSPECIFIED: PowerType.ValueType  # 0
"""Default value. Users are discouraged from using this value. Using this will
result in an error.
"""
POWER_TYPE_ACTIVE: PowerType.ValueType  # 1
"""The requested power is active power."""
POWER_TYPE_REACTIVE: PowerType.ValueType  # 2
"""The requested power is reactive power."""
global___PowerType = PowerType

class _SetElectricalComponentPowerRequestStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SetElectricalComponentPowerRequestStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SetElectricalComponentPowerRequestStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_UNSPECIFIED: _SetElectricalComponentPowerRequestStatus.ValueType  # 0
    """Default value. Users are discouraged from using this value."""
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_ACCEPTED: _SetElectricalComponentPowerRequestStatus.ValueType  # 1
    """The request has been accepted, and the target power set-point will be
    applied to the electrical component.

    Once the API service has received a request to set the power of an
    electrical component, it will validate the input parameters immediately.
    If the parameters are valid, the service will return this code
    immediately, and then proceed to apply the power set-point to the
    electrical component.
    """
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_REJECTED: _SetElectricalComponentPowerRequestStatus.ValueType  # 2
    """The request has been rejected because of invalid input parameters.

    Once the API service has received a request to set the power of an
    electrical component, it will validate the input parameters immediately.
    If the parameters are invalid, the service will return this code
    immediately, and will not apply the power set-point to the
    electrical component.
    """
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_FAILED: _SetElectricalComponentPowerRequestStatus.ValueType  # 3
    """The request has failed midway, and the electrical component is not
    at the desired power level.

    This code indicates that the request to set the power of an electrical
    component has been accepted, but the service encountered an error while
    applying the power set-point to the electrical component.
    """
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_SUCCESS: _SetElectricalComponentPowerRequestStatus.ValueType  # 4
    """The request has been successfully processed."""
    SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_OVERRIDDEN: _SetElectricalComponentPowerRequestStatus.ValueType  # 5
    """The request has been overridden by another request.

    This could happen if a new request to set the power of an electrical
    component arrives while the previous request is still being processed.
    """

class SetElectricalComponentPowerRequestStatus(_SetElectricalComponentPowerRequestStatus, metaclass=_SetElectricalComponentPowerRequestStatusEnumTypeWrapper):
    """Response codes for the `SetElectricalComponentPowerActive` and
    `SetElectricalComponentPowerReactive` RPCs. These codes indicate the ongoing
    status of the request to set the power of an electrical component.

    Often, electrical components are not able to immediately set their output
    power to the requested value. This can happen due to several reasons,
    including, but not limited to:
    - having to ramp up or down the power output from the current output.
    - having to wait for the electrical component to reach a stable state before
      applying the new power set-point.
    - communication latency between the API service and the electrical
      component.

    In such cases, an initial response is sent to the client, indicating that the
    request has been accepted, and it is followed by a stream of responses
    indicating the ongoing status of the request.
    """

SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_UNSPECIFIED: SetElectricalComponentPowerRequestStatus.ValueType  # 0
"""Default value. Users are discouraged from using this value."""
SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_ACCEPTED: SetElectricalComponentPowerRequestStatus.ValueType  # 1
"""The request has been accepted, and the target power set-point will be
applied to the electrical component.

Once the API service has received a request to set the power of an
electrical component, it will validate the input parameters immediately.
If the parameters are valid, the service will return this code
immediately, and then proceed to apply the power set-point to the
electrical component.
"""
SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_REJECTED: SetElectricalComponentPowerRequestStatus.ValueType  # 2
"""The request has been rejected because of invalid input parameters.

Once the API service has received a request to set the power of an
electrical component, it will validate the input parameters immediately.
If the parameters are invalid, the service will return this code
immediately, and will not apply the power set-point to the
electrical component.
"""
SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_FAILED: SetElectricalComponentPowerRequestStatus.ValueType  # 3
"""The request has failed midway, and the electrical component is not
at the desired power level.

This code indicates that the request to set the power of an electrical
component has been accepted, but the service encountered an error while
applying the power set-point to the electrical component.
"""
SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_SUCCESS: SetElectricalComponentPowerRequestStatus.ValueType  # 4
"""The request has been successfully processed."""
SET_ELECTRICAL_COMPONENT_POWER_REQUEST_STATUS_OVERRIDDEN: SetElectricalComponentPowerRequestStatus.ValueType  # 5
"""The request has been overridden by another request.

This could happen if a new request to set the power of an electrical
component arrives while the previous request is still being processed.
"""
global___SetElectricalComponentPowerRequestStatus = SetElectricalComponentPowerRequestStatus

@typing.final
class GetMicrogridResponse(google.protobuf.message.Message):
    """Information describing a microgrid."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_FIELD_NUMBER: builtins.int
    @property
    def microgrid(self) -> frequenz.api.common.v1alpha8.microgrid.microgrid_pb2.Microgrid:
        """The information about the local microgrid."""

    def __init__(
        self,
        *,
        microgrid: frequenz.api.common.v1alpha8.microgrid.microgrid_pb2.Microgrid | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["microgrid", b"microgrid"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["microgrid", b"microgrid"]) -> None: ...

global___GetMicrogridResponse = GetMicrogridResponse

@typing.final
class ListElectricalComponentsRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `ListElectricalComponents`.
    Contains filtering parameters for listing electrical components.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_IDS_FIELD_NUMBER: builtins.int
    ELECTRICAL_COMPONENT_CATEGORIES_FIELD_NUMBER: builtins.int
    @property
    def electrical_component_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Return electrical components that have the specified IDs only."""

    @property
    def electrical_component_categories(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType]:
        """Return electrical components that have the specified categories only."""

    def __init__(
        self,
        *,
        electrical_component_ids: collections.abc.Iterable[builtins.int] | None = ...,
        electrical_component_categories: collections.abc.Iterable[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentCategory.ValueType] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_categories", b"electrical_component_categories", "electrical_component_ids", b"electrical_component_ids"]) -> None: ...

global___ListElectricalComponentsRequest = ListElectricalComponentsRequest

@typing.final
class ListElectricalComponentsResponse(google.protobuf.message.Message):
    """A message containing a list of electrical components.
    Used as the return type in the RPC `ListElectricalComponents`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENTS_FIELD_NUMBER: builtins.int
    @property
    def electrical_components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponent]: ...
    def __init__(
        self,
        *,
        electrical_components: collections.abc.Iterable[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponent] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_components", b"electrical_components"]) -> None: ...

global___ListElectricalComponentsResponse = ListElectricalComponentsResponse

@typing.final
class ListSensorRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `ListSensors`.
    Contains filtering parameters for listing sensors.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SENSOR_IDS_FIELD_NUMBER: builtins.int
    @property
    def sensor_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Return sensors that have the specified IDs only."""

    def __init__(
        self,
        *,
        sensor_ids: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sensor_ids", b"sensor_ids"]) -> None: ...

global___ListSensorRequest = ListSensorRequest

@typing.final
class ListSensorsResponse(google.protobuf.message.Message):
    """Response message for the RPC `ListSensors`.
    A message containing a list of sensors.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SENSORS_FIELD_NUMBER: builtins.int
    @property
    def sensors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1alpha8.microgrid.sensors.sensors_pb2.Sensor]: ...
    def __init__(
        self,
        *,
        sensors: collections.abc.Iterable[frequenz.api.common.v1alpha8.microgrid.sensors.sensors_pb2.Sensor] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sensors", b"sensors"]) -> None: ...

global___ListSensorsResponse = ListSensorsResponse

@typing.final
class ListElectricalComponentConnectionsRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `ListElectricalComponentConnections`.
    Contains filtering parameters for listing connections.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_ELECTRICAL_COMPONENT_IDS_FIELD_NUMBER: builtins.int
    DESTINATION_ELECTRICAL_COMPONENT_IDS_FIELD_NUMBER: builtins.int
    @property
    def source_electrical_component_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Only return connections that start from the specified electrical
        component ID(s).
        If this list is empty, connections with any `source_component_id` will be
        returned.
        """

    @property
    def destination_electrical_component_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Only return connections that end at the specified electrical component
        ID(s).
        If this list is empty, connections with any `destination_component_id`
        will be returned.
        """

    def __init__(
        self,
        *,
        source_electrical_component_ids: collections.abc.Iterable[builtins.int] | None = ...,
        destination_electrical_component_ids: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["destination_electrical_component_ids", b"destination_electrical_component_ids", "source_electrical_component_ids", b"source_electrical_component_ids"]) -> None: ...

global___ListElectricalComponentConnectionsRequest = ListElectricalComponentConnectionsRequest

@typing.final
class ListElectricalComponentConnectionsResponse(google.protobuf.message.Message):
    """Response message for the RPC `ListElectricalComponentConnections`.
    Contains a list of connections.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_CONNECTIONS_FIELD_NUMBER: builtins.int
    @property
    def electrical_component_connections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentConnection]:
        """The list of connections."""

    def __init__(
        self,
        *,
        electrical_component_connections: collections.abc.Iterable[frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentConnection] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_connections", b"electrical_component_connections"]) -> None: ...

global___ListElectricalComponentConnectionsResponse = ListElectricalComponentConnectionsResponse

@typing.final
class ReceiveElectricalComponentTelemetryStreamRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `ReceiveElectricalComponentTelemetryStream`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ComponentTelemetryStreamFilter(google.protobuf.message.Message):
        """A message for specifying a filter to apply to the stream."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        METRICS_FIELD_NUMBER: builtins.int
        @property
        def metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType]:
            """List of metrics to return. Only the specified metrics will be returned.

            !!! note
                At least one metric must be specified. If no metric is specified,
                then the stream will return an error.

            !!! note
                Components may not support all metrics. If a electrical component
                does not support a given metric, then the returned data stream will
                not contain that metric.
            """

        def __init__(
            self,
            *,
            metrics: collections.abc.Iterable[frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["metrics", b"metrics"]) -> None: ...

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The electrical component ID to subscribe to."""
    @property
    def filter(self) -> global___ReceiveElectricalComponentTelemetryStreamRequest.ComponentTelemetryStreamFilter:
        """The filter to apply to the stream.

        This field is optional. If this is not provided, then the stream will
        return all metrics for the given electrical component. If this is provided,
        then the stream will return only the metrics specified in the filter.
        """

    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
        filter: global___ReceiveElectricalComponentTelemetryStreamRequest.ComponentTelemetryStreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_id", b"electrical_component_id", "filter", b"filter"]) -> None: ...

global___ReceiveElectricalComponentTelemetryStreamRequest = ReceiveElectricalComponentTelemetryStreamRequest

@typing.final
class ReceiveElectricalComponentTelemetryStreamResponse(google.protobuf.message.Message):
    """A data sample from a electrical component in the microgrid.
    Electrical Components belonging to all categories and types can be
    represented using this message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TELEMETRY_FIELD_NUMBER: builtins.int
    @property
    def telemetry(self) -> frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentTelemetry: ...
    def __init__(
        self,
        *,
        telemetry: frequenz.api.common.v1alpha8.microgrid.electrical_components.electrical_components_pb2.ElectricalComponentTelemetry | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["telemetry", b"telemetry"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["telemetry", b"telemetry"]) -> None: ...

global___ReceiveElectricalComponentTelemetryStreamResponse = ReceiveElectricalComponentTelemetryStreamResponse

@typing.final
class ReceiveSensorTelemetryStreamRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `ReceiveSensorTelemetryStream`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class SensorTelemetryStreamFilter(google.protobuf.message.Message):
        """A message for specifying a filter to apply to the stream."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        METRICS_FIELD_NUMBER: builtins.int
        @property
        def metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType]:
            """List of metrics to return. Only the specified metrics will be returned.

            !!! note
                At least one metric must be specified. If no metric is specified,
                then the stream will return an error.

            !!! note
                Sensors may not support all metrics. If a sensor does not support a
                given metric, then the returned data stream will not contain that
                metric.
            """

        def __init__(
            self,
            *,
            metrics: collections.abc.Iterable[frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["metrics", b"metrics"]) -> None: ...

    SENSOR_ID_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    sensor_id: builtins.int
    """The sensor ID to subscribe to."""
    @property
    def filter(self) -> global___ReceiveSensorTelemetryStreamRequest.SensorTelemetryStreamFilter:
        """The filter to apply to the stream.

        This field is optional. If this is not provided, then the stream will
        return all metrics for the given sensor. If this is provided, then the
        stream will return only the metrics specified in the filter.
        """

    def __init__(
        self,
        *,
        sensor_id: builtins.int = ...,
        filter: global___ReceiveSensorTelemetryStreamRequest.SensorTelemetryStreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "sensor_id", b"sensor_id"]) -> None: ...

global___ReceiveSensorTelemetryStreamRequest = ReceiveSensorTelemetryStreamRequest

@typing.final
class ReceiveSensorTelemetryStreamResponse(google.protobuf.message.Message):
    """A data sample from a sensor in the microgrid."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TELEMETRY_FIELD_NUMBER: builtins.int
    @property
    def telemetry(self) -> frequenz.api.common.v1alpha8.microgrid.sensors.sensors_pb2.SensorTelemetry:
        """The sensor data."""

    def __init__(
        self,
        *,
        telemetry: frequenz.api.common.v1alpha8.microgrid.sensors.sensors_pb2.SensorTelemetry | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["telemetry", b"telemetry"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["telemetry", b"telemetry"]) -> None: ...

global___ReceiveSensorTelemetryStreamResponse = ReceiveSensorTelemetryStreamResponse

@typing.final
class AugmentElectricalComponentBoundsRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `AugmentElectricalComponentBounds`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    TARGET_METRIC_FIELD_NUMBER: builtins.int
    BOUNDS_FIELD_NUMBER: builtins.int
    REQUEST_LIFETIME_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The ID of the target electrical component."""
    target_metric: frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType
    """The target metric whose bounds have to be set."""
    request_lifetime: builtins.int
    """The duration, in seconds, until which the request will stay in effect.
    This duration has to be between 5 seconds and 15 minutes (including both
    limits), otherwise the request will be rejected.
    If not provided, it defaults to 5s.
    """
    @property
    def bounds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1alpha8.metrics.bounds_pb2.Bounds]:
        """A list of bounds for the target metric.
        While incorporating these bounds, the API will ensure that overlapping
        pairs of bounds are merged into a single pair of bounds, and
        non-overlapping ones are kept separated.
        """

    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
        target_metric: frequenz.api.common.v1alpha8.metrics.metrics_pb2.Metric.ValueType = ...,
        bounds: collections.abc.Iterable[frequenz.api.common.v1alpha8.metrics.bounds_pb2.Bounds] | None = ...,
        request_lifetime: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_request_lifetime", b"_request_lifetime", "request_lifetime", b"request_lifetime"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_request_lifetime", b"_request_lifetime", "bounds", b"bounds", "electrical_component_id", b"electrical_component_id", "request_lifetime", b"request_lifetime", "target_metric", b"target_metric"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_request_lifetime", b"_request_lifetime"]) -> typing.Literal["request_lifetime"] | None: ...

global___AugmentElectricalComponentBoundsRequest = AugmentElectricalComponentBoundsRequest

@typing.final
class AugmentElectricalComponentBoundsResponse(google.protobuf.message.Message):
    """Response message for the RPC `AugmentElectricalComponentBounds`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALID_UNTIL_TIME_FIELD_NUMBER: builtins.int
    @property
    def valid_until_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp until which the added bounds will stay in effect.
        After this timestamp, the electrical component bounds added by this request
        will be removed. By default, this timestamp will be set to the current
        time plus 60 seconds.
        """

    def __init__(
        self,
        *,
        valid_until_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["valid_until_time", b"valid_until_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["valid_until_time", b"valid_until_time"]) -> None: ...

global___AugmentElectricalComponentBoundsResponse = AugmentElectricalComponentBoundsResponse

@typing.final
class SetElectricalComponentPowerRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `SetElectricalComponentPower`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    POWER_TYPE_FIELD_NUMBER: builtins.int
    POWER_FIELD_NUMBER: builtins.int
    REQUEST_LIFETIME_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The ID of the electrical component to set the output power of."""
    power_type: global___PowerType.ValueType
    """The requested power type."""
    power: builtins.float
    """The requested power output.

    For Active power:
    - This value is in watts (W).
    - Negative values indicate discharge, i.e., supplying power towards the
      direction of the root node of the component graph.
    - Positive values indicate charge, i.e., consuming power from the
      direction of the root node of the component graph.

    For Reactive power:
    - This value is in volt-amperes reactive (VAR).
    - Negative values indicate capacitive reactive power, i.e., the current
      is leading the voltage when viewed from the perspective of the
      electrical component.
    - Positive values indicate inductive reactive power, i.e., the current
      is lagging the voltage when viewed from the perspective of the
      electrical component.
    """
    request_lifetime: builtins.int
    """The duration, in seconds, until which the request will stay in effect.
    This duration has to be between 10 seconds and 15 minutes (including both
    limits), otherwise the request will be rejected.
    If not provided, it defaults to 60s.
    """
    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
        power_type: global___PowerType.ValueType = ...,
        power: builtins.float = ...,
        request_lifetime: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_request_lifetime", b"_request_lifetime", "request_lifetime", b"request_lifetime"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_request_lifetime", b"_request_lifetime", "electrical_component_id", b"electrical_component_id", "power", b"power", "power_type", b"power_type", "request_lifetime", b"request_lifetime"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_request_lifetime", b"_request_lifetime"]) -> typing.Literal["request_lifetime"] | None: ...

global___SetElectricalComponentPowerRequest = SetElectricalComponentPowerRequest

@typing.final
class SetElectricalComponentPowerResponse(google.protobuf.message.Message):
    """Response message for the RPC `SetElectricalComponentPower`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALID_UNTIL_TIME_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    status: global___SetElectricalComponentPowerRequestStatus.ValueType
    """The current status of the request to set the power of the electrical
    component.
    """
    @property
    def valid_until_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp until which the given power command will stay in effect.
        After this timestamp, the electrical component will be set to its standby
        state, if the API receives no further power commands.
        By default, this timestamp will be set to the current time plus 60 seconds.

        When the request status is `REJECTED`, `FAILED`, or `OVERRIDDEN`, the
        `valid_until_time` timestamp will not be set, and the request will no
        longer remain in effect.
        """

    def __init__(
        self,
        *,
        valid_until_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        status: global___SetElectricalComponentPowerRequestStatus.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["valid_until_time", b"valid_until_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["status", b"status", "valid_until_time", b"valid_until_time"]) -> None: ...

global___SetElectricalComponentPowerResponse = SetElectricalComponentPowerResponse

@typing.final
class StartElectricalComponentRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `StartElectricalComponent`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The electrical component ID to start."""
    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_id", b"electrical_component_id"]) -> None: ...

global___StartElectricalComponentRequest = StartElectricalComponentRequest

@typing.final
class PutElectricalComponentInStandbyRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `PutElectricalComponentInStandby`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The electrical component ID to set to standby."""
    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_id", b"electrical_component_id"]) -> None: ...

global___PutElectricalComponentInStandbyRequest = PutElectricalComponentInStandbyRequest

@typing.final
class StopElectricalComponentRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `StopElectricalComponent`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The electrical component ID to stop."""
    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_id", b"electrical_component_id"]) -> None: ...

global___StopElectricalComponentRequest = StopElectricalComponentRequest

@typing.final
class AckElectricalComponentErrorRequest(google.protobuf.message.Message):
    """Request parameters for the RPC `AckElectricalComponentError`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELECTRICAL_COMPONENT_ID_FIELD_NUMBER: builtins.int
    electrical_component_id: builtins.int
    """The electrical component ID to acknowledge the error for."""
    def __init__(
        self,
        *,
        electrical_component_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["electrical_component_id", b"electrical_component_id"]) -> None: ...

global___AckElectricalComponentErrorRequest = AckElectricalComponentErrorRequest
