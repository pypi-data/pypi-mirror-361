#!/bin/bash

# 设置错误时退出
set -e

# 定义颜色输出
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# 定义语言选择
LANG_ZH=1
LANG_EN=2
current_lang=$LANG_ZH

# 中文语言包
ZH_INFO="[信息]"
ZH_ERROR="[错误]"
ZH_PERMISSION_CHECK="检查脚本权限..."
ZH_PERMISSION_DENIED="脚本没有执行权限!"
ZH_PERMISSION_FIX="请运行以下命令赋予权限:"
ZH_CMD_NOT_FOUND="未安装，请先安装"
ZH_STARTING_BACKEND="正在启动后端服务..."
ZH_INSTALL_PYTHON_DEPS="安装 Python 依赖"
ZH_BACKEND_STARTED="后端服务已启动 (PID:"
ZH_STARTING_FRONTEND="正在启动前端服务..."
ZH_INSTALL_FRONTEND_DEPS="安装前端依赖..."
ZH_FRONTEND_STARTED="前端服务已启动 (PID:"
ZH_SHUTTING_DOWN="正在关闭服务..."
ZH_SERVICES_SHUTDOWN="服务已关闭"
ZH_ALL_SERVICES_STARTED="所有服务已启动！"
ZH_BACKEND_RUNNING="后端服务运行在"
ZH_FRONTEND_RUNNING="前端服务运行在"
ZH_PRESS_CTRL_C="按 Ctrl+C 停止所有服务"
ZH_SELECT_LANGUAGE="请选择语言 / Please select language:"
ZH_KILL_PORTS_PROMPT="检测到以下端口被占用，是否释放这些端口？"
ZH_PORT_DESC_3000="前端服务 (Vite)"
ZH_PORT_DESC_5001="WebSSH 服务"
ZH_PORT_DESC_5002="后端 API 服务"
ZH_PORT_DESC_7681="ttyd 终端服务"
ZH_CONFIRM_KILL="确认释放？(y/n): "
ZH_PORT_RELEASED="释放了端口"
ZH_PORT_SKIPPED="跳过端口释放"
ZH_DOCKER_MODE="Docker 运行模式"
ZH_LOCAL_MODE="本地运行模式"
ZH_SELECT_RUN_MODE="请选择运行模式:"
ZH_DOCKER_NOT_RUNNING="Docker 服务未运行，将使用本地模式"
ZH_STARTING_DOCKER="使用 Docker 模式启动服务..."
ZH_DOCKER_FRONTEND_EXISTS="检测到已运行的前端容器"
ZH_DOCKER_FRONTEND_RESTART="是否重启前端容器? (Y/n):"
ZH_DOCKER_FRONTEND_STARTING="启动前端容器..."
ZH_DOCKER_FRONTEND_SUCCESS="前端容器启动成功"
ZH_DOCKER_FRONTEND_FAIL="前端容器启动失败"

# 英文语言包
EN_INFO="[INFO]"
EN_ERROR="[ERROR]"
EN_PERMISSION_CHECK="Checking script permissions..."
EN_PERMISSION_DENIED="Script does not have execute permission!"
EN_PERMISSION_FIX="Please run the following command to grant permissions:"
EN_CMD_NOT_FOUND="is not installed, please install"
EN_STARTING_BACKEND="Starting backend service..."
EN_INSTALL_PYTHON_DEPS="Installing Python dependencies"
EN_BACKEND_STARTED="Backend service started (PID:"
EN_STARTING_FRONTEND="Starting frontend service..."
EN_INSTALL_FRONTEND_DEPS="Installing frontend dependencies..."
EN_FRONTEND_STARTED="Frontend service started (PID:"
EN_SHUTTING_DOWN="Shutting down services..."
EN_SERVICES_SHUTDOWN="Services shut down"
EN_ALL_SERVICES_STARTED="All services started!"
EN_BACKEND_RUNNING="Backend service running at"
EN_FRONTEND_RUNNING="Frontend service running at"
EN_PRESS_CTRL_C="Press Ctrl+C to stop all services"
EN_SELECT_LANGUAGE="Please select language:"
EN_KILL_PORTS_PROMPT="The following ports are in use. Do you want to release them?"
EN_PORT_DESC_3000="Frontend service (Vite)"
EN_PORT_DESC_5001="WebSSH service"
EN_PORT_DESC_5002="Backend API service"
EN_PORT_DESC_7681="ttyd terminal service"
EN_CONFIRM_KILL="Confirm release? (y/n): "
EN_PORT_RELEASED="Released port"
EN_PORT_SKIPPED="Skipped port release"
EN_DOCKER_MODE="Docker run mode"
EN_LOCAL_MODE="Local run mode"
EN_SELECT_RUN_MODE="Please select run mode:"
EN_DOCKER_NOT_RUNNING="Docker service not running, will use local mode"
EN_STARTING_DOCKER="Starting services with Docker mode..."
EN_DOCKER_FRONTEND_EXISTS="Frontend container already running"
EN_DOCKER_FRONTEND_RESTART="Restart frontend container? (Y/n):"
EN_DOCKER_FRONTEND_STARTING="Starting frontend container..."
EN_DOCKER_FRONTEND_SUCCESS="Frontend container started successfully"
EN_DOCKER_FRONTEND_FAIL="Frontend container failed to start"

# 显示语言选择函数
select_language() {
    echo -e "${YELLOW}$ZH_SELECT_LANGUAGE${NC}"
    echo "1. 中文"
    echo "2. English"
    read -p "选择/Select (1/2, default: 1): " lang_choice
    
    if [ "$lang_choice" = "2" ]; then
        current_lang=$LANG_EN
    else
        current_lang=$LANG_ZH
    fi
}

# 打印带颜色的信息
print_info() {
    if [ $current_lang -eq $LANG_ZH ]; then
        echo -e "${GREEN}$ZH_INFO${NC} $1"
    else
        echo -e "${GREEN}$EN_INFO${NC} $1"
    fi
}

print_error() {
    if [ $current_lang -eq $LANG_ZH ]; then
        echo -e "${RED}$ZH_ERROR${NC} $1"
    else
        echo -e "${RED}$EN_ERROR${NC} $1"
    fi
}

# 带颜色输出函数
print_color_msg() {
    local color="$1"
    local zh_msg="$2"
    local en_msg="$3"
    
    if [ $current_lang -eq $LANG_ZH ]; then
        echo -e "${color}${zh_msg}${NC}"
    else
        echo -e "${color}${en_msg}${NC}"
    fi
}

# 权限检查函数
check_permissions() {
    print_color_msg "$YELLOW" "$ZH_PERMISSION_CHECK" "$EN_PERMISSION_CHECK"
    
    if [ ! -x "$0" ]; then
        print_color_msg "$RED" "$ZH_PERMISSION_DENIED" "$EN_PERMISSION_DENIED"
        print_color_msg "$YELLOW" "$ZH_PERMISSION_FIX" "$EN_PERMISSION_FIX"
        echo "chmod +x $(basename "$0")"
        exit 1
    fi
}

# 检查必要的命令是否存在
check_command() {
    if ! command -v $1 &> /dev/null; then
        if [ $current_lang -eq $LANG_ZH ]; then
            print_error "$1 $ZH_CMD_NOT_FOUND $1"
        else
            print_error "$1 $EN_CMD_NOT_FOUND $1"
        fi
        exit 1
    fi
}

# 检查端口占用并询问用户
check_and_kill_ports() {
    local ports=(3000 5001 5002)
    local port_descs=()
    local occupied_ports=()
    
    # 端口描述
    if [ $current_lang -eq $LANG_ZH ]; then
        port_descs[3000]="$ZH_PORT_DESC_3000"
        port_descs[5001]="$ZH_PORT_DESC_5001"
        port_descs[5002]="$ZH_PORT_DESC_5002"
        port_descs[7681]="$ZH_PORT_DESC_7681"
    else
        port_descs[3000]="$EN_PORT_DESC_3000"
        port_descs[5001]="$EN_PORT_DESC_5001"
        port_descs[5002]="$EN_PORT_DESC_5002"
        port_descs[7681]="$EN_PORT_DESC_7681"
    fi
    
    # 检查哪些端口被占用
    for port in ${ports[@]}; do
        pid=$(lsof -t -i:$port 2>/dev/null || true)
        if [ -n "$pid" ]; then
            occupied_ports+=($port)
        fi
    done
    
    # 如果有端口被占用，询问用户
    if [ ${#occupied_ports[@]} -gt 0 ]; then
        if [ $current_lang -eq $LANG_ZH ]; then
            echo -e "${YELLOW}$ZH_KILL_PORTS_PROMPT${NC}"
        else
            echo -e "${YELLOW}$EN_KILL_PORTS_PROMPT${NC}"
        fi
        
        # 显示占用的端口信息
        for port in ${occupied_ports[@]}; do
            echo "  - $port: ${port_descs[$port]}"
        done
        
        # 询问用户
        if [ $current_lang -eq $LANG_ZH ]; then
            read -p "$ZH_CONFIRM_KILL" confirm
        else
            read -p "$EN_CONFIRM_KILL" confirm
        fi
        
        if [[ -z "$confirm" || $confirm == "y" || $confirm == "Y" ]]; then
            # 释放端口
            for port in ${occupied_ports[@]}; do
                pid=$(lsof -t -i:$port 2>/dev/null || true)
                if [ -n "$pid" ]; then
                    kill -9 $pid 2>/dev/null || true
                    if [ $current_lang -eq $LANG_ZH ]; then
                        print_info "$ZH_PORT_RELEASED $port"
                    else
                        print_info "$EN_PORT_RELEASED $port"
                    fi
                fi
            done
        else
            if [ $current_lang -eq $LANG_ZH ]; then
                print_info "$ZH_PORT_SKIPPED"
            else
                print_info "$EN_PORT_SKIPPED"
            fi
        fi
    fi
}

# 检查 Docker 是否可用
check_docker() {
    if command -v docker &> /dev/null; then
        # 尝试运行docker ps，如果失败可能是权限问题或服务未启动
        if docker ps &> /dev/null; then
            return 0
        else
            # Docker已安装但服务未启动
            if [ "$(uname)" = "Darwin" ]; then
                # macOS - 尝试启动Docker Desktop
                if [ $current_lang -eq $LANG_ZH ]; then
                    print_info "检测到Docker未运行，正在启动Docker Desktop..."
                else
                    print_info "Docker not running, starting Docker Desktop..."
                fi
                
                # 启动Docker Desktop
                open -a Docker
                
                # 等待Docker启动
                local count=0
                while ! docker ps &> /dev/null && [ $count -lt 30 ]; do
                    if [ $count -eq 0 ]; then
                        if [ $current_lang -eq $LANG_ZH ]; then
                            echo -n "等待Docker启动"
                        else
                            echo -n "Waiting for Docker to start"
                        fi
                    fi
                    echo -n "."
                    sleep 2
                    count=$((count + 1))
                done
                echo
                
                if docker ps &> /dev/null; then
                    if [ $current_lang -eq $LANG_ZH ]; then
                        print_info "Docker Desktop已启动"
                    else
                        print_info "Docker Desktop started"
                    fi
                    return 0
                else
                    if [ $current_lang -eq $LANG_ZH ]; then
                        print_error "Docker Desktop启动失败，请手动启动"
                    else
                        print_error "Failed to start Docker Desktop, please start manually"
                    fi
                    return 1
                fi
            else
                # Linux系统
                if [ $current_lang -eq $LANG_ZH ]; then
                    print_info "Docker已安装但服务未启动，请运行: sudo systemctl start docker"
                else
                    print_info "Docker installed but service not started, run: sudo systemctl start docker"
                fi
                return 1
            fi
        fi
    else
        return 1
    fi
}

# 选择运行模式
select_run_mode() {
    # 如果有环境变量，直接使用
    if [ ! -z "$MOFA_RUN_MODE" ]; then
        if [ "$MOFA_RUN_MODE" = "docker" ]; then
            return 0  # Docker 模式
        else
            return 1  # 本地模式
        fi
    fi
    
    # 检查Docker是否可用
    if check_docker; then
        if [ $current_lang -eq $LANG_ZH ]; then
            echo -e "${YELLOW}$ZH_SELECT_RUN_MODE${NC}"
            echo "1. $ZH_LOCAL_MODE"
            echo "2. $ZH_DOCKER_MODE (推荐)"
            read -p "选择 (1/2, 默认: 2): " mode_choice
        else
            echo -e "${YELLOW}$EN_SELECT_RUN_MODE${NC}"
            echo "1. $EN_LOCAL_MODE"
            echo "2. $EN_DOCKER_MODE (Recommended)"
            read -p "Select (1/2, default: 2): " mode_choice
        fi
        
        # 默认选择Docker模式
        if [ -z "$mode_choice" ] || [ "$mode_choice" = "2" ]; then
            return 0  # Docker 模式
        else
            return 1  # 本地模式
        fi
    else
        if [ $current_lang -eq $LANG_ZH ]; then
            print_info "$ZH_DOCKER_NOT_RUNNING"
        else
            print_info "$EN_DOCKER_NOT_RUNNING"
        fi
        sleep 2
        return 1  # 本地模式
    fi
}

# Docker 模式运行前端
run_frontend_with_docker() {
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_STARTING_DOCKER"
    else
        print_info "$EN_STARTING_DOCKER"
    fi
    
    # 检查是否已有运行的容器
    if docker ps -a | grep -q mofa-frontend; then
        if [ $current_lang -eq $LANG_ZH ]; then
            print_info "$ZH_DOCKER_FRONTEND_EXISTS"
            read -p "$ZH_DOCKER_FRONTEND_RESTART" restart_choice
        else
            print_info "$EN_DOCKER_FRONTEND_EXISTS"
            read -p "$EN_DOCKER_FRONTEND_RESTART" restart_choice
        fi
        
        if [ "$restart_choice" != "n" ] && [ "$restart_choice" != "N" ]; then
            docker stop mofa-frontend 2>/dev/null
            docker rm mofa-frontend 2>/dev/null
        else
            return 0
        fi
    fi
    
    # 启动前端容器
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_DOCKER_FRONTEND_STARTING"
    else
        print_info "$EN_DOCKER_FRONTEND_STARTING"
    fi
    
    docker run -d -p 3000:80 --name mofa-frontend \
        --add-host=host.docker.internal:host-gateway \
        liyao1119/mofa-stage-frontend:latest
    
    if [ $? -eq 0 ]; then
        if [ $current_lang -eq $LANG_ZH ]; then
            print_info "$ZH_DOCKER_FRONTEND_SUCCESS"
        else
            print_info "$EN_DOCKER_FRONTEND_SUCCESS"
        fi
        return 0
    else
        if [ $current_lang -eq $LANG_ZH ]; then
            print_error "$ZH_DOCKER_FRONTEND_FAIL"
        else
            print_error "$EN_DOCKER_FRONTEND_FAIL"
        fi
        return 1
    fi
}

# 初始化语言选择 - 优先使用环境变量，否则询问用户
if [ ! -z "$MOFA_LANG" ]; then
    current_lang=$MOFA_LANG
else
    select_language
fi

# 权限检查
check_permissions

# 获取脚本所在目录的绝对路径
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# 启动后端服务
start_backend() {
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_STARTING_BACKEND"
    else
        print_info "$EN_STARTING_BACKEND"
    fi
    cd "$SCRIPT_DIR/backend"
    
    # 在后台启动 Flask 服务
    python app.py &
    BACKEND_PID=$!
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_BACKEND_STARTED $BACKEND_PID)"
    else
        print_info "$EN_BACKEND_STARTED $BACKEND_PID)"
    fi
}

# 启动前端服务
start_frontend() {
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_STARTING_FRONTEND"
    else
        print_info "$EN_STARTING_FRONTEND"
    fi
    cd "$SCRIPT_DIR/frontend"
    
    # 在后台启动 Vite 开发服务器
    npm run dev &
    FRONTEND_PID=$!
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_FRONTEND_STARTED $FRONTEND_PID)"
    else
        print_info "$EN_FRONTEND_STARTED $FRONTEND_PID)"
    fi
}

# 清理函数
cleanup() {
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_SHUTTING_DOWN"
    else
        print_info "$EN_SHUTTING_DOWN"
    fi
    if [ ! -z "$BACKEND_PID" ]; then
        kill $BACKEND_PID 2>/dev/null || true
    fi
    if [ ! -z "$FRONTEND_PID" ]; then
        kill $FRONTEND_PID 2>/dev/null || true
    fi
    if [ $current_lang -eq $LANG_ZH ]; then
        print_info "$ZH_SERVICES_SHUTDOWN"
    else
        print_info "$EN_SERVICES_SHUTDOWN"
    fi
    exit 0
}

# 注册清理函数
trap cleanup SIGINT SIGTERM

# 检查并释放端口
check_and_kill_ports

# 选择运行模式
if select_run_mode; then
    # Docker 模式
    # 后端仍需本地运行
    check_command python3
    
    # Docker运行前端
    run_frontend_with_docker
    
    # 启动后端
    start_backend
else
    # 本地模式
    # 检查 Python 和 Node.js
    check_command python3
    check_command node
    check_command npm
    
    # 启动服务
    start_backend
    start_frontend
fi

# 打开浏览器的函数
open_browser() {
    local url="$1"
    
    # 等待一下确保服务已经启动
    sleep 2
    
    # 根据操作系统选择打开方式
    if [ "$(uname)" = "Darwin" ]; then
        # macOS
        open "$url"
    elif [ "$(uname)" = "Linux" ]; then
        # Linux
        if command -v xdg-open &> /dev/null; then
            xdg-open "$url"
        elif command -v gnome-open &> /dev/null; then
            gnome-open "$url"
        elif command -v kde-open &> /dev/null; then
            kde-open "$url"
        fi
    fi
}

# 服务已在前面根据模式启动

if [ $current_lang -eq $LANG_ZH ]; then
    print_info "$ZH_ALL_SERVICES_STARTED"
    print_info "$ZH_BACKEND_RUNNING http://localhost:5002"
    print_info "$ZH_FRONTEND_RUNNING http://localhost:3000"
    print_info "$ZH_PRESS_CTRL_C"
else
    print_info "$EN_ALL_SERVICES_STARTED"
    print_info "$EN_BACKEND_RUNNING http://localhost:5002"
    print_info "$EN_FRONTEND_RUNNING http://localhost:3000"
    print_info "$EN_PRESS_CTRL_C"
fi

# 自动打开浏览器
open_browser "http://localhost:3000" &

# 保持脚本运行
wait 