#!/usr/bin/env python3
"""
Vulnerability Reporting Module

This module handles the display and reporting of vulnerability findings
across different frameworks in a unified manner.
"""

from typing import List, Dict


class VulnerabilityReporter:
    """Unified vulnerability reporting and display functionality"""
    
    def __init__(self, debug: bool = False):
        """Initialize vulnerability reporter"""
        self.debug = debug
    
    def display_vulnerabilities(self, vulnerabilities: List[Dict]) -> bool:
        """Display found vulnerabilities to user in formatted output"""
        if not vulnerabilities:
            print("✅ No vulnerabilities found!")
            return False
        
        print(f"\n🚨 Found {len(vulnerabilities)} potential vulnerabilities:")
        print("=" * 80)
        
        for i, vuln in enumerate(vulnerabilities, 1):
            severity_emoji = self._get_severity_emoji(vuln.get('severity', 'Unknown'))
            
            print(f"\n{i}. {severity_emoji} {vuln.get('vulnerability_type', 'Unknown')} "
                  f"({vuln.get('severity', 'Unknown')} Severity)")
            print(f"   📄 File: {vuln.get('file', 'Unknown')}")
            
            if vuln.get('line_number'):
                print(f"   📍 Line: {vuln.get('line_number')}")
            
            # Clean description before displaying
            description = self._clean_description(vuln.get('description', 'No description'))
            print(f"   📝 Description: {description}")
            
            if vuln.get('code_snippet'):
                code_snippet = vuln.get('code_snippet', '')
                if len(code_snippet) > 100:
                    code_snippet = code_snippet[:100] + "..."
                print(f"   💻 Code: {code_snippet}")
        
        print("=" * 80)
        return True
    
    def display_enhanced_vulnerabilities(self, vulnerabilities: List[Dict]) -> bool:
        """Display enhanced vulnerability findings with additional context"""
        if not vulnerabilities:
            print("✅ No vulnerabilities found!")
            return False
        
        print(f"\n🚨 Enhanced Analysis: Found {len(vulnerabilities)} potential vulnerabilities:")
        print("=" * 90)
        
        # Group vulnerabilities by severity
        high_vulns = [v for v in vulnerabilities if v.get('severity') == 'High']
        medium_vulns = [v for v in vulnerabilities if v.get('severity') == 'Medium']
        low_vulns = [v for v in vulnerabilities if v.get('severity') == 'Low']
        
        if high_vulns:
            print(f"\n🔴 HIGH SEVERITY ({len(high_vulns)} issues)")
            self._display_vulnerability_group(high_vulns)
        
        if medium_vulns:
            print(f"\n🟡 MEDIUM SEVERITY ({len(medium_vulns)} issues)")
            self._display_vulnerability_group(medium_vulns)
        
        if low_vulns:
            print(f"\n🟢 LOW SEVERITY ({len(low_vulns)} issues)")
            self._display_vulnerability_group(low_vulns)
        
        print("=" * 90)
        return True
    
    def save_enhanced_vulnerability_report(self, vulnerabilities: List[Dict], 
                                         output_path: str) -> bool:
        """Save enhanced vulnerability report to file"""
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write("# Enhanced Vulnerability Analysis Report\n\n")
                f.write(f"Total vulnerabilities found: {len(vulnerabilities)}\n\n")
                
                # Group by severity
                high_vulns = [v for v in vulnerabilities if v.get('severity') == 'High']
                medium_vulns = [v for v in vulnerabilities if v.get('severity') == 'Medium']
                low_vulns = [v for v in vulnerabilities if v.get('severity') == 'Low']
                
                if high_vulns:
                    f.write(f"## High Severity Issues ({len(high_vulns)})\n\n")
                    self._write_vulnerability_group(f, high_vulns)
                
                if medium_vulns:
                    f.write(f"## Medium Severity Issues ({len(medium_vulns)})\n\n")
                    self._write_vulnerability_group(f, medium_vulns)
                
                if low_vulns:
                    f.write(f"## Low Severity Issues ({len(low_vulns)})\n\n")
                    self._write_vulnerability_group(f, low_vulns)
            
            print(f"📄 Enhanced vulnerability report saved to: {output_path}")
            return True
            
        except Exception as e:
            print(f"❌ Failed to save vulnerability report: {e}")
            return False
    
    def show_analysis_summary(self, total_vulnerabilities: int, 
                            analysis_time: float, framework: str = ""):
        """Show analysis summary with statistics"""
        print(f"\n📊 Analysis Summary:")
        print(f"   🔍 Framework: {framework}")
        print(f"   🚨 Total vulnerabilities: {total_vulnerabilities}")
        print(f"   ⏱️  Analysis time: {analysis_time:.2f} seconds")
        
        if total_vulnerabilities > 0:
            print(f"   📋 Review the findings above and consider applying fixes")
        else:
            print(f"   ✅ No security issues detected")
    
    def deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities based on key characteristics"""
        seen_vulns = set()
        unique_vulnerabilities = []
        
        for vuln in vulnerabilities:
            # Create a unique key for deduplication
            vuln_key = (
                vuln.get('vulnerability_type', ''),
                vuln.get('file', ''),
                vuln.get('line_number', 0),
                vuln.get('code_snippet', '')[:50]  # First 50 chars of code snippet
            )
            
            if vuln_key not in seen_vulns:
                seen_vulns.add(vuln_key)
                unique_vulnerabilities.append(vuln)
        
        if self.debug and len(vulnerabilities) != len(unique_vulnerabilities):
            removed_count = len(vulnerabilities) - len(unique_vulnerabilities)
            print(f"🔍 DEBUG: Removed {removed_count} duplicate vulnerabilities")
        
        return unique_vulnerabilities
    
    def _display_vulnerability_group(self, vulnerabilities: List[Dict]):
        """Display a group of vulnerabilities"""
        for i, vuln in enumerate(vulnerabilities, 1):
            print(f"   {i}. {vuln.get('vulnerability_type', 'Unknown')}")
            print(f"      📄 File: {vuln.get('file', 'Unknown')}")
            if vuln.get('line_number'):
                print(f"      📍 Line: {vuln.get('line_number')}")
            print(f"      📝 {self._clean_description(vuln.get('description', 'No description'))}")
            if vuln.get('code_snippet'):
                code_snippet = vuln.get('code_snippet', '')
                if len(code_snippet) > 80:
                    code_snippet = code_snippet[:80] + "..."
                print(f"      💻 Code: {code_snippet}")
            print()
    
    def _write_vulnerability_group(self, file, vulnerabilities: List[Dict]):
        """Write vulnerability group to file"""
        for i, vuln in enumerate(vulnerabilities, 1):
            file.write(f"### {i}. {vuln.get('vulnerability_type', 'Unknown')}\n\n")
            file.write(f"**File:** {vuln.get('file', 'Unknown')}\n")
            if vuln.get('line_number'):
                file.write(f"**Line:** {vuln.get('line_number')}\n")
            file.write(f"**Description:** {self._clean_description(vuln.get('description', 'No description'))}\n")
            if vuln.get('code_snippet'):
                file.write(f"**Code:**\n```\n{vuln.get('code_snippet', '')}\n```\n")
            file.write("\n---\n\n")
    
    def _get_severity_emoji(self, severity: str) -> str:
        """Get emoji for severity level"""
        severity_emojis = {
            'High': '🔴',
            'Medium': '🟡',
            'Low': '🟢'
        }
        return severity_emojis.get(severity, '⚪')
    
    def _clean_description(self, description: str) -> str:
        """Clean description field from JSON artifacts and formatting issues"""
        if not description or not isinstance(description, str):
            return 'No description'
        
        import re
        
        # Remove JSON-like patterns from description
        cleaned = re.sub(r'\{[^}]*\}', '', description)  # Remove JSON objects
        cleaned = re.sub(r'\[[^\]]*\]', '', cleaned)     # Remove JSON arrays
        cleaned = re.sub(r'"[^"]*"\s*:', '', cleaned)    # Remove JSON key-value pairs
        cleaned = re.sub(r'\s+', ' ', cleaned)           # Normalize whitespace
        cleaned = cleaned.strip()
        
        # If description is empty after cleaning, provide default
        if not cleaned:
            return 'No description available'
        
        # Limit description length for display
        if len(cleaned) > 200:
            cleaned = cleaned[:200] + "..."
        
        return cleaned
