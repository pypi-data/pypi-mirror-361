from __future__ import annotations

from collections.abc import Iterable, Sequence, Sized
from typing import Generic, Literal, Protocol, Self, TypeVar, overload

class Range(Sequence[int]):
    @overload
    def __init__(self, start: int, stop: int) -> None: ...
    @overload
    def __init__(self, start: int, direction: Literal["to", "downto"], stop: int): ...
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, idx: int, /) -> int: ...
    @overload
    def __getitem__(self, idx: slice, /) -> Range: ...
    def __len__(self) -> int: ...

T_co = TypeVar("T_co", covariant=True)
T = TypeVar("T")

class SizedIterable(Sized, Iterable[T_co], Protocol[T_co]): ...

class Array(Generic[T]):
    def __init__(self, value: SizedIterable[T_co], /) -> None: ...
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, value: object, /) -> bool: ...
    def __iter__(self) -> Iterable[T]: ...
    def __reversed__(self) -> Iterable[T]: ...
    @overload
    def __getitem__(self, idx: int, /) -> T: ...
    @overload
    def __getitem__(self, idx: slice, /) -> Self: ...
    @overload
    def __setitem__(self, idx: int, value: T, /) -> None: ...
    @overload
    def __setitem__(self, idx: slice, value: SizedIterable[T], /) -> None: ...
    def index(self, value: object, start: int = ..., stop: int = ..., /) -> int: ...
    def count(self, value: object, /) -> int: ...

class Logic:
    def __init__(self, literal: int | str | bool | Logic, /) -> None: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __and__(self, other: Logic, /) -> Logic: ...
    def __rand__(self, other: Logic, /) -> Logic: ...
    def __or__(self, other: Logic, /) -> Logic: ...
    def __ror__(self, other: Logic, /) -> Logic: ...
    def __xor__(self, other: Logic, /) -> Logic: ...
    def __rxor__(self, other: Logic, /) -> Logic: ...
    def __not__(self) -> Logic: ...

class LogicArray(Array[Logic]):
    @overload
    def __setitem__(self, idx: int, value: Logic, /) -> None: ...
    @overload
    def __setitem__(
        self, idx: slice, value: SizedIterable[int | str | bool | Logic], /
    ) -> None: ...
    def index(self, value: object, start: int = ..., stop: int = ..., /) -> int: ...
    def count(self, value: object, /) -> int: ...
    def __and__(self, other: LogicArray, /) -> LogicArray: ...
    def __or__(self, other: LogicArray, /) -> LogicArray: ...
    def __xor__(self, other: LogicArray, /) -> LogicArray: ...
    def __inv__(self) -> LogicArray: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...

class BitArray(LogicArray):
    @overload
    def __and__(self, other: BitArray, /) -> BitArray: ...
    @overload
    def __and__(self, other: LogicArray, /) -> LogicArray: ...
    @overload
    def __or__(self, other: BitArray, /) -> BitArray: ...
    @overload
    def __or__(self, other: LogicArray, /) -> LogicArray: ...
    @overload
    def __xor__(self, other: BitArray, /) -> BitArray: ...
    @overload
    def __xor__(self, other: LogicArray, /) -> LogicArray: ...
    def __inv__(self) -> BitArray: ...

class Unsigned(BitArray): ...
class Signed(BitArray): ...  # implements LogicArray[Bit], Arithmetic
class Ufixed(BitArray): ...  # implements LogicArray[Bit], Arithmetic
class Sfixed(BitArray): ...  # implements LogicArray[Bit], Arithmetic
class Float(BitArray): ...  # implements LogicArray[Bit], Arithmetic

a: Unsigned
b: Signed
c: LogicArray
reveal_type(a & b)
reveal_type(a & c)
reveal_type(c & a)
