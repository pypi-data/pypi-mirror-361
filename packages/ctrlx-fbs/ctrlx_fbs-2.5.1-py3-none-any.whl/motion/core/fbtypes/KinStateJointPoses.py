# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbtypes

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# all joint poses of a kinematic
class KinStateJointPoses(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KinStateJointPoses()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsKinStateJointPoses(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # KinStateJointPoses
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # array of 16 input axis positions and units, this input is optional and must only be written if the inputType==GIVEN_AXIS_POS 
    # KinStateJointPoses
    def InPosAcs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.KinPosValues import KinPosValues
            obj = KinPosValues()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Use of the axis positions input. Possible types: "INTERPOLATED_AXIS_POS", "ACTUAL_AXIS_POS", "GIVEN_AXIS_POS".
    # KinStateJointPoses
    def InputType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # output joint positions, should be left out in the request
    # KinStateJointPoses
    def OutJointPoses(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from motion.core.fbtypes.PoseParallelChains import PoseParallelChains
            obj = PoseParallelChains()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KinStateJointPoses
    def OutJointPosesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KinStateJointPoses
    def OutJointPosesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # units of all joint poses (6 units)
    # KinStateJointPoses
    def UnitsJointsPoses(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # KinStateJointPoses
    def UnitsJointsPosesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KinStateJointPoses
    def UnitsJointsPosesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def KinStateJointPosesStart(builder): builder.StartObject(4)
def Start(builder):
    return KinStateJointPosesStart(builder)
def KinStateJointPosesAddInPosAcs(builder, inPosAcs): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(inPosAcs), 0)
def AddInPosAcs(builder, inPosAcs):
    return KinStateJointPosesAddInPosAcs(builder, inPosAcs)
def KinStateJointPosesAddInputType(builder, inputType): builder.PrependInt8Slot(1, inputType, 0)
def AddInputType(builder, inputType):
    return KinStateJointPosesAddInputType(builder, inputType)
def KinStateJointPosesAddOutJointPoses(builder, outJointPoses): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(outJointPoses), 0)
def AddOutJointPoses(builder, outJointPoses):
    return KinStateJointPosesAddOutJointPoses(builder, outJointPoses)
def KinStateJointPosesStartOutJointPosesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartOutJointPosesVector(builder, numElems):
    return KinStateJointPosesStartOutJointPosesVector(builder, numElems)
def KinStateJointPosesAddUnitsJointsPoses(builder, unitsJointsPoses): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(unitsJointsPoses), 0)
def AddUnitsJointsPoses(builder, unitsJointsPoses):
    return KinStateJointPosesAddUnitsJointsPoses(builder, unitsJointsPoses)
def KinStateJointPosesStartUnitsJointsPosesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartUnitsJointsPosesVector(builder, numElems):
    return KinStateJointPosesStartUnitsJointsPosesVector(builder, numElems)
def KinStateJointPosesEnd(builder): return builder.EndObject()
def End(builder):
    return KinStateJointPosesEnd(builder)
import motion.core.fbtypes.KinPosValues
import motion.core.fbtypes.PoseParallelChains
try:
    from typing import List, Optional
except:
    pass

class KinStateJointPosesT(object):

    # KinStateJointPosesT
    def __init__(self):
        self.inPosAcs = None  # type: Optional[motion.core.fbtypes.KinPosValues.KinPosValuesT]
        self.inputType = 0  # type: int
        self.outJointPoses = None  # type: List[motion.core.fbtypes.PoseParallelChains.PoseParallelChainsT]
        self.unitsJointsPoses = None  # type: List[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        kinStateJointPoses = KinStateJointPoses()
        kinStateJointPoses.Init(buf, pos)
        return cls.InitFromObj(kinStateJointPoses)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, kinStateJointPoses):
        x = KinStateJointPosesT()
        x._UnPack(kinStateJointPoses)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.inPosAcs == other.inPosAcs and \
            self.inputType == other.inputType and \
            self.outJointPoses == other.outJointPoses and \
            self.unitsJointsPoses == other.unitsJointsPoses

    # KinStateJointPosesT
    def _UnPack(self, kinStateJointPoses):
        if kinStateJointPoses is None:
            return
        if kinStateJointPoses.InPosAcs() is not None:
            self.inPosAcs = motion.core.fbtypes.KinPosValues.KinPosValuesT.InitFromObj(kinStateJointPoses.InPosAcs())
        self.inputType = kinStateJointPoses.InputType()
        if not kinStateJointPoses.OutJointPosesIsNone():
            self.outJointPoses = []
            for i in range(kinStateJointPoses.OutJointPosesLength()):
                if kinStateJointPoses.OutJointPoses(i) is None:
                    self.outJointPoses.append(None)
                else:
                    poseParallelChains_ = motion.core.fbtypes.PoseParallelChains.PoseParallelChainsT.InitFromObj(kinStateJointPoses.OutJointPoses(i))
                    self.outJointPoses.append(poseParallelChains_)
        if not kinStateJointPoses.UnitsJointsPosesIsNone():
            self.unitsJointsPoses = []
            for i in range(kinStateJointPoses.UnitsJointsPosesLength()):
                self.unitsJointsPoses.append(kinStateJointPoses.UnitsJointsPoses(i))

    # KinStateJointPosesT
    def Pack(self, builder):
        if self.inPosAcs is not None:
            inPosAcs = self.inPosAcs.Pack(builder)
        if self.outJointPoses is not None:
            outJointPoseslist = []
            for i in range(len(self.outJointPoses)):
                outJointPoseslist.append(self.outJointPoses[i].Pack(builder))
            KinStateJointPosesStartOutJointPosesVector(builder, len(self.outJointPoses))
            for i in reversed(range(len(self.outJointPoses))):
                builder.PrependUOffsetTRelative(outJointPoseslist[i])
            outJointPoses = builder.EndVector()
        if self.unitsJointsPoses is not None:
            unitsJointsPoseslist = []
            for i in range(len(self.unitsJointsPoses)):
                unitsJointsPoseslist.append(builder.CreateString(self.unitsJointsPoses[i]))
            KinStateJointPosesStartUnitsJointsPosesVector(builder, len(self.unitsJointsPoses))
            for i in reversed(range(len(self.unitsJointsPoses))):
                builder.PrependUOffsetTRelative(unitsJointsPoseslist[i])
            unitsJointsPoses = builder.EndVector()
        KinStateJointPosesStart(builder)
        if self.inPosAcs is not None:
            KinStateJointPosesAddInPosAcs(builder, inPosAcs)
        KinStateJointPosesAddInputType(builder, self.inputType)
        if self.outJointPoses is not None:
            KinStateJointPosesAddOutJointPoses(builder, outJointPoses)
        if self.unitsJointsPoses is not None:
            KinStateJointPosesAddUnitsJointsPoses(builder, unitsJointsPoses)
        kinStateJointPoses = KinStateJointPosesEnd(builder)
        return kinStateJointPoses
