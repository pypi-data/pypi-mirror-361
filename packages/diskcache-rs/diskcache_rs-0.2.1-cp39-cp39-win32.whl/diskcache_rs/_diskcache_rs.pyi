# Type stubs for _diskcache_rs module (Rust extension)
# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from typing import Any, Optional, List, Dict

# Rust Cache Classes
class PyCache:
    """Python wrapper for the Cache"""
    def __init__(self, directory: str, max_size: Optional[int] = None, max_entries: Optional[int] = None) -> None: ...
    def get(self, key: str) -> Optional[bytes]: ...
    def set(self, key: str, value: Any, expire_time: Optional[int] = None, tags: Optional[List[str]] = None) -> None: ...
    def delete(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def size(self) -> int: ...
    def hit_rate(self) -> float: ...

class Cache:
    """Drop-in replacement for diskcache.Cache"""
    def __init__(self, directory: str, **kwargs: Any) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def get(self, key: str, default: Any = None, retry: bool = False) -> Any: ...
    def set(self, key: str, value: Any, expire: Optional[int] = None, read: Optional[bool] = None, tag: Optional[str] = None, retry: Optional[bool] = None) -> bool: ...
    def add(self, key: str, value: Any, expire: Optional[int] = None, retry: bool = False) -> bool: ...
    def delete(self, key: str, retry: bool = False) -> bool: ...
    def pop(self, key: str, default: Any = None, expire: Optional[int] = None, retry: bool = False) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def values(self) -> List[Any]: ...
    def items(self) -> List[tuple[str, Any]]: ...
    def iterkeys(self) -> typing.Iterator[str]: ...
    def itervalues(self) -> typing.Iterator[Any]: ...
    def iteritems(self) -> typing.Iterator[tuple[str, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(self, key: str, expire: Optional[int] = None, retry: bool = False) -> bool: ...
    def incr(self, key: str, delta: typing.Union[int, float] = 1, default: typing.Union[int, float] = 0, retry: bool = False) -> typing.Union[int, float]: ...
    def decr(self, key: str, delta: typing.Union[int, float] = 1, default: typing.Union[int, float] = 0, retry: bool = False) -> typing.Union[int, float]: ...

class FanoutCache:
    """Drop-in replacement for diskcache.FanoutCache"""
    def __init__(self, directory: str, shards: Optional[int] = None, **kwargs: Any) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def get(self, key: str, default: Any = None, retry: bool = False) -> Any: ...
    def set(self, key: str, value: Any, expire: Optional[int] = None, read: Optional[bool] = None, tag: Optional[str] = None, retry: Optional[bool] = None) -> bool: ...
    def delete(self, key: str) -> bool: ...
    def iterkeys(self) -> List[str]: ...

class PickleCache:
    """High-performance pickle cache with expiration support"""
    def __init__(self, directory: str, max_size: Optional[int] = None, default_ttl_seconds: Optional[int] = None) -> None: ...
    def set_pickle(self, key: str, pickled_data: Any, ttl_seconds: Optional[int] = None) -> None: ...
    def get_pickle(self, key: str) -> Optional[bytes]: ...
    def delete(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def exists(self, key: str) -> bool: ...
    def keys(self) -> List[str]: ...
    def is_expired(self, key: str) -> bool: ...
    def cleanup_expired(self) -> int: ...
    def get_stats(self) -> Dict[str, Any]: ...

# Utility Functions
def detect_diskcache_format_py(path: str) -> bool:
    """Python wrapper for detect_diskcache_format"""
    ...

def rust_pickle_dumps(obj: Any) -> Any:
    """High-performance pickle serialization using Rust"""
    ...

def rust_pickle_loads(data: Any) -> Any:
    """High-performance pickle deserialization using Rust"""
    ...

