# pyziggy - Run automation scripts that interact with zigbee2mqtt.
# Copyright (C) 2025 Attila Szarvas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from .device_bases import LightWithColor, LightWithColorTemp
from .devices_client import DevicesClient
from .parameters import EnumParameter
from .parser import NumericParameterDefinition


# ==============================================================================
# These functions will adjust the generated AvailableDevices object before
# connecting to the MQTT service.
#
# They are necessary for my use cases, but I'm not confident enough about their
# general applicability, hence the name, workarounds.
#
# One of them changes the minimum and maximum values for hue and saturation
# sub-parameters in LightWithColor devices. These minimum and maximum values
# should ideally be reported by zigbee2mqtt, but for some reason they seem to be
# missing for all sub-parameters of composite parameters. After some
# experimentation, one can discover that the effective limits are [0, 360] for
# hue, and [0, 100] for saturation. I wouldn't be surprised if zigbee2mqtt
# eventually started reporting these limits, at which point they would
# automatically show up in the autogenerated LightWithColor devices.
#
# You can disable these workarounds by accessing the pyziggy.workarounds
# singleton object in your automation script.
#
# For example:
#
#     import pyziggy.workarounds
#     pyziggy.workarounds.fix_light_with_color_min_max_values.set_enabled(False)
#
# ==============================================================================


class Workaround:
    def __init__(self, callable, description: str):
        self._enabled = True
        self._callable = callable
        self._description = description

    def set_enabled(self, enabled: bool):
        self._enabled = enabled


def fix_light_with_color_min_max_values(dc: DevicesClient):
    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            if (
                device.color_hs.hue._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.hue._min_value = 0
            if (
                device.color_hs.hue._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.hue._max_value = 360
            if (
                device.color_hs.saturation._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.saturation._min_value = 0
            if (
                device.color_hs.saturation._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.saturation._max_value = 100


def make_action_enum_parameters_use_sync_callbacks(dc: DevicesClient):
    for device in dc.get_devices():
        for parameter in device.get_parameters():
            if (
                isinstance(parameter, EnumParameter)
                and parameter.get_property_name() == "action"
            ):
                parameter.set_use_synchronous_broadcast(True)


def make_setting_color_invalidate_color(dc: DevicesClient):
    def hs_was_set(device: LightWithColor):
        device.color_temp.mark_as_stale()
        device.color_xy.mark_as_stale()

    def xy_was_set(device: LightWithColor):
        device.color_hs.mark_as_stale()
        device.color_temp.mark_as_stale()

    def color_temp_was_set(device: LightWithColor):
        device.color_hs.mark_as_stale()
        device.color_xy.mark_as_stale()

    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            device.color_hs.hue.add_listener(lambda d=device: hs_was_set(d), -1)  # type: ignore
            device.color_hs.saturation.add_listener(lambda d=device: hs_was_set(d), -1)  # type: ignore
            device.color_xy.x.add_listener(lambda d=device: xy_was_set(d), -1)  # type: ignore
            device.color_xy.y.add_listener(lambda d=device: xy_was_set(d), -1)  # type: ignore
            device.color_temp.add_listener(lambda d=device: color_temp_was_set(d), -1)  # type: ignore


def make_setting_state_invalidate_color_temp(dc: DevicesClient):
    """
    If we send color parameter changes to a device that is turned off, it will
    be likely to ignore it. Z2M however will send the info to the device, and
    even in its internal state, Z2M will believe that the light has this new
    color value.

    So it can happen that the device is turned on, has the wrong color, but both
    Z2M and pyziggy thinks it has the right color, hence it won't even send a
    new parameter change with the same value.

    Marking the parameters stale ensures, that whatever color we set after the
    device turns on, will be sent to it.
    """
    for device in dc.get_devices():
        if isinstance(device, LightWithColorTemp):
            device.state.add_listener(lambda d=device: d.color_temp.mark_as_stale(), -1)  # type: ignore


class Workarounds:
    def __init__(self):
        self.fix_light_with_color_min_max_values = Workaround(
            fix_light_with_color_min_max_values,
            "Modifying LightWithColor devices. Changing hue limits to [0, 360] and saturation limits to [0, 100].",
        )
        self.make_setting_color_invalidate_color = Workaround(
            make_setting_color_invalidate_color,
            "Modifying LightWithColor devices. Setting hs, xy or color_temp will invalidate the other two.",
        )
        self.make_setting_state_invalidate_color_temp = Workaround(
            make_setting_state_invalidate_color_temp,
            "Modifying LightWithColorTemp devices. Marking all color related params stale when the device is turned on.",
        )
        self.make_action_enum_parameters_use_sync_callbacks = Workaround(
            make_action_enum_parameters_use_sync_callbacks,
            'Modifying EnumParameters with the "action" property to use synchronous callbacks.',
        )

    def _get_workarounds(self) -> list[Workaround]:
        workarounds: list[Workaround] = []

        for k, v in vars(self).items():
            if isinstance(v, Workaround):
                workarounds.append(v)

        return workarounds

    def _apply(self, dc: DevicesClient):
        if not any([wa._enabled for wa in self._get_workarounds()]):
            return

        print(
            "Applying workarounds. See the documentation in the pyziggy.workarounds module if you want to disable them."
        )

        for wa in self._get_workarounds():
            if not wa._enabled:
                continue

            print(f"* {wa._description}")
            wa._callable(dc)


workarounds = Workarounds()
