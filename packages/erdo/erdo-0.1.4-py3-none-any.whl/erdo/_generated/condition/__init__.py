# DO NOT EDIT THIS FILE MANUALLY - it will be overwritten.
# Generated by: erdo gen-client
"""
Condition classes auto-generated from Go condition types.

These classes provide type-safe condition definitions that match
the backend condition system exactly.
"""

from typing import TYPE_CHECKING, Any, Dict, List, Union

if TYPE_CHECKING:
    # Forward reference for condition types
    Condition = Union[
        "_BaseCondition", "_AndCondition", "_OrCondition", "_NotCondition"
    ]


# Composite condition functions (matching Go pattern)
class _AndCondition:
    def __init__(self, *conditions: Any) -> None:
        self.conditions = list(conditions)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {
            "type": "And",
            "conditions": [
                c.to_dict() if hasattr(c, "to_dict") else c for c in self.conditions
            ],
        }

    def __and__(self, other: Any) -> "_AndCondition":
        """Support & operator for chaining AND conditions."""
        if isinstance(other, _AndCondition):
            return _AndCondition(*(self.conditions + other.conditions))
        return _AndCondition(*(self.conditions + [other]))

    def __or__(self, other: Any) -> "_OrCondition":
        """Support | operator for OR conditions."""
        return _OrCondition(self, other)

    def __invert__(self) -> "_NotCondition":
        """Support ~ operator for NOT conditions."""
        return _NotCondition(self)


class _OrCondition:
    def __init__(self, *conditions: Any) -> None:
        self.conditions = list(conditions)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {
            "type": "Or",
            "conditions": [
                c.to_dict() if hasattr(c, "to_dict") else c for c in self.conditions
            ],
        }

    def __and__(self, other: Any) -> "_AndCondition":
        """Support & operator for AND conditions."""
        return _AndCondition(self, other)

    def __or__(self, other: Any) -> "_OrCondition":
        """Support | operator for chaining OR conditions."""
        if isinstance(other, _OrCondition):
            return _OrCondition(*(self.conditions + other.conditions))
        return _OrCondition(*(self.conditions + [other]))

    def __invert__(self) -> "_NotCondition":
        """Support ~ operator for NOT conditions."""
        return _NotCondition(self)


class _NotCondition:
    def __init__(self, condition: Any) -> None:
        self.condition = condition

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {
            "type": "Not",
            "conditions": (
                self.condition.to_dict()
                if hasattr(self.condition, "to_dict")
                else self.condition
            ),
        }

    def __and__(self, other: Any) -> "_AndCondition":
        """Support & operator for AND conditions."""
        return _AndCondition(self, other)

    def __or__(self, other: Any) -> "_OrCondition":
        """Support | operator for OR conditions."""
        return _OrCondition(self, other)

    def __invert__(self) -> Any:
        """Support ~ operator for double negation (returns original condition)."""
        return self.condition


def And(*conditions: "Condition") -> _AndCondition:
    """Create an AND condition from multiple conditions"""
    return _AndCondition(*conditions)


def Or(*conditions: "Condition") -> _OrCondition:
    """Create an OR condition from multiple conditions"""
    return _OrCondition(*conditions)


def Not(condition: "Condition") -> _NotCondition:
    """Create a NOT condition from a single condition"""
    return _NotCondition(condition)


# Base class for leaf conditions to support operators
class _BaseCondition:
    """Base class for all leaf conditions to support operator overloading."""

    def __and__(self, other: Any) -> "_AndCondition":
        """Support & operator for AND conditions."""
        return _AndCondition(self, other)

    def __or__(self, other: Any) -> "_OrCondition":
        """Support | operator for OR conditions."""
        return _OrCondition(self, other)

    def __invert__(self) -> "_NotCondition":
        """Support ~ operator for NOT conditions."""
        return _NotCondition(self)


class IsNull(_BaseCondition):
    def __init__(self, key: Any = None) -> None:
        self.key = key

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "IsNull"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.key is not None:
            leaf["key"] = self.key

        if leaf:
            result["leaf"] = leaf

        return result


class IsSuccess(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsSuccess", "leaf": {}}


class AndCondition(_BaseCondition):
    def __init__(self, conditions: Any = None) -> None:
        self.conditions = conditions

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "AndCondition"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.conditions is not None:
            leaf["conditions"] = self.conditions

        if leaf:
            result["leaf"] = leaf

        return result


class EarlierThan(_BaseCondition):
    def __init__(self, time: Any = None, value: Any = None) -> None:
        self.time = time
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "EarlierThan"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.time is not None:
            leaf["time"] = self.time
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class FalseCondition(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "FalseCondition", "leaf": {}}


class IsError(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsError", "leaf": {}}


class LessThan(_BaseCondition):
    def __init__(self, number: Any = None, value: Any = None) -> None:
        self.number = number
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "LessThan"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.number is not None:
            leaf["number"] = self.number
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class TextEquals(_BaseCondition):
    def __init__(self, text: Any = None, value: Any = None) -> None:
        self.text = text
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "TextEquals"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.text is not None:
            leaf["text"] = self.text
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class TextStartsWith(_BaseCondition):
    def __init__(self, text: Any = None, value: Any = None) -> None:
        self.text = text
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "TextStartsWith"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.text is not None:
            leaf["text"] = self.text
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class TrueCondition(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "TrueCondition", "leaf": {}}


class NotCondition(_BaseCondition):
    def __init__(self, condition: Any = None) -> None:
        self.condition = condition

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "NotCondition"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.condition is not None:
            leaf["condition"] = self.condition

        if leaf:
            result["leaf"] = leaf

        return result


class IsErrorActionNotFound(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsErrorActionNotFound", "leaf": {}}


class IsErrorTerminated(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsErrorTerminated", "leaf": {}}


class TextContains(_BaseCondition):
    def __init__(self, text: Any = None, value: Any = None) -> None:
        self.text = text
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "TextContains"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.text is not None:
            leaf["text"] = self.text
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class OrCondition(_BaseCondition):
    def __init__(self, conditions: Any = None) -> None:
        self.conditions = conditions

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "OrCondition"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.conditions is not None:
            leaf["conditions"] = self.conditions

        if leaf:
            result["leaf"] = leaf

        return result


class GreaterThan(_BaseCondition):
    def __init__(self, number: Any = None, value: Any = None) -> None:
        self.number = number
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "GreaterThan"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.number is not None:
            leaf["number"] = self.number
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class IsAny(_BaseCondition):
    def __init__(self, key: Any = None, value: Any = None) -> None:
        self.key = key
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "IsAny"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.key is not None:
            leaf["key"] = self.key
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


class IsErrorInfoNeeded(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsErrorInfoNeeded", "leaf": {}}


class IsErrorInternalError(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsErrorInternalError", "leaf": {}}


class IsFormattedError(_BaseCondition):
    def __init__(self) -> None:
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        return {"type": "IsFormattedError", "leaf": {}}


class TextEndsWith(_BaseCondition):
    def __init__(self, text: Any = None, value: Any = None) -> None:
        self.text = text
        self.value = value

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result: Dict[str, Any] = {}
        result["type"] = "TextEndsWith"

        # Add field values to leaf object (backend expects leaf format)
        leaf: Dict[str, Any] = {}
        if self.text is not None:
            leaf["text"] = self.text
        if self.value is not None:
            leaf["value"] = self.value

        if leaf:
            result["leaf"] = leaf

        return result


# Auto-generated __all__ list for import *
__all__ = [
    "And",
    "Or",
    "Not",
    "LessThan",
    "TextEquals",
    "TextStartsWith",
    "TrueCondition",
    "IsErrorActionNotFound",
    "IsErrorTerminated",
    "TextContains",
    "GreaterThan",
    "IsAny",
    "IsErrorInfoNeeded",
    "IsErrorInternalError",
    "IsFormattedError",
    "TextEndsWith",
    "IsNull",
    "IsSuccess",
    "EarlierThan",
    "FalseCondition",
    "IsError",
]
