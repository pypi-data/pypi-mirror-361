# base class for all entity detectors

from dataclasses import dataclass
import time
import logging
import json
import asyncio
from typing import List
from azure.core.credentials import AzureKeyCredential
from azure.ai.textanalytics.aio import TextAnalyticsClient

from ..configs.ta_config import TAConfig

# entity class for hallucination detection
@dataclass
class HdEntity:
    hypothesis: str # E2E hypothesis generated by entity detector feeding to HD
    span_text : str # the text of the entity in the original text
    entity_type : str
    entity_name : str # the name of the entity in standard format
    span_start : int = -1 # [spanStart, spanEnd) character index of the entity in the original text
    span_end : int = -1
    detection_type: str = 'NA'

    def __hash__(self) -> int:
        return hash(self.hypothesis)

class EntityDetectorBase:
    def __init__(self) -> None:
        pass

    # detect entities in a given text, return a list of entities
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [[] for _ in range(len(text_content))] # return empty list by default

class PassThroughEntityDetector(EntityDetectorBase):
    def __init__(self) -> None:
        super().__init__()

    # detect entities in a given text, return a list of entities
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        # simply treat the whole sentennce as a giant "entity",
        # so that hallucination detection can be applied to the whole sentence

        # TODO: change the entity type "whole_sentence" to a constant and defined in a central place
        return [[HdEntity(s, s, "whole_sentence", s, 0, len(s), 'PASS_THROUGH')] for s in text_content]

class EnsembledEntityDetector(EntityDetectorBase) :
    def __init__(self, detectors : List[EntityDetectorBase]) -> None:
        super().__init__()
        self.detectors = detectors
        assert self._check_detectors(), "PassThroughEntityDetector is not the last detector"

    def _detect_entities(self, text_content : str) -> List[HdEntity]:
        results = []

        for detector in self.detectors:
            if type(detector) is PassThroughEntityDetector and len(results) != 0:
                continue
            cur_result = detector.detect_entities(text_content)
            results.extend(cur_result)
        return results
    
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [self._detect_entities(text) for text in text_content]

    def _detect_bkg_entities(self, text_content : str) -> List[HdEntity]:
        for detector in self.detectors:
            if type(detector) is BkgEntityDetector:
                return detector.detect_entities(text_content)
        return []
    
    def detect_bkg_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [self._detect_bkg_entities(text) for text in text_content]

    def _check_detectors(self) -> bool:
        if len(self.detectors) == 1:
            return True

        for detector in self.detectors[:-1]:
            if type(detector) is PassThroughEntityDetector:
                return False
        return True

class GenTAEntityDetector(EntityDetectorBase):
    def __init__(self, ta_config: TAConfig) -> None:
        super().__init__()
        self.ta_config = ta_config
        api_key = ta_config.api_key
        if not api_key:
            raise ValueError("API_KEY is not defined in the config file and LANGUAGE_KEY is not set in environment")

        self.credential = AzureKeyCredential(api_key)
        self.endpoint = ta_config.endpoint

        self.default_allowed_entity_types = [
            "Quantity_Number",
            "Event",
            "Location",
            "DateTime_DateRange",
            "Person",
            "PersonType",
            "Skill",
            "Quantity_Currency",
            "DateTime_Duration"
        ]

    @staticmethod
    def get_general_entity_category(entity):
        return f"{entity.category}_{entity.subcategory}" if entity.subcategory else f"{entity.category}"

    async def _detect_entities(self, text_contents: List[str]) -> List[List[HdEntity]]:
        ta_client = TextAnalyticsClient(endpoint=self.endpoint, credential=self.credential)
        
        async with ta_client:
            while True:
                try:
                    result = ta_client.recognize_entities(documents=text_contents)
                    ta_results = [r for r in result if not r.is_error]
                    break
                except Exception as e:
                    error_str = str(e).lower()
                    if "invalid subscription key or wrong api endpoint" in error_str:
                        raise Exception(f'[TA] Unexpected, unrecoverable error: {error_str}')
                    else:
                        logging.info(f"[TA] Unexpected error, retryable error: {error_str}")
                        await asyncio.sleep(5)
                        continue

        entity_types_allow_list = self.get_entity_types_allow_list()
        return_list = []

        for result, text_content_str in zip(ta_results, text_contents):
            def to_hd_entity(text, entity):
                eType = self.get_general_entity_category(entity)
                start_pos = entity.offset
                end_pos = start_pos + len(entity.text)
                hypothesis = f'{text[:start_pos]}[ {entity.text} ]{text[end_pos:]}'
                return HdEntity(hypothesis, entity.text, eType, None, start_pos, end_pos, f'TA-{eType}')

            entities = [to_hd_entity(text_content_str, r) for r in result.entities 
                        if not entity_types_allow_list or self.get_general_entity_category(r) in entity_types_allow_list]
            return_list.append(entities)

        return return_list

    def detect_entities(self, text_content: List[str]) -> List[List[HdEntity]]:
        return asyncio.run(self._detect_entities(text_content))

    def get_entity_types_allow_list(self) -> List[str]:
        return self.ta_config.entities or self.default_allowed_entity_types


class EntityDetectorFactory:
    @staticmethod
    def create_entity_detector(entity_detector_type : str, **kwargs) -> EntityDetectorBase:
        type_with_info = entity_detector_type.split(':')
        entity_detector_type_real = type_with_info[0]
        if entity_detector_type_real == "ensemble":
            # ensembled, arguments provided as: ensemble:detector1,detector2,detector3
            detect_type_list = type_with_info[1].split(',')
            return EntityDetectorFactory.create_ensembled_entity_detector(detect_type_list, **kwargs)
        else:
            return EntityDetectorFactory.create_single_entity_detector(entity_detector_type_real, **kwargs)

    @staticmethod
    def create_single_entity_detector(entity_detector_type : str, **kwargs) -> EntityDetectorBase:
        if entity_detector_type == "pass_through":
            return PassThroughEntityDetector()
        elif entity_detector_type == "ta-general":
            ta_config = kwargs['ta_config']
            return GenTAEntityDetector(ta_config)
        elif entity_detector_type == "base":
            return EntityDetectorBase() # only used for testing ensembled entity detector
        else:
            raise ValueError(f"Unknown entity detector type: {entity_detector_type}")

    @staticmethod
    def create_ensembled_entity_detector(detectors_to_ensemble : List[str], **kwargs) -> EntityDetectorBase:
        if detectors_to_ensemble is None or len(detectors_to_ensemble) == 0:
            raise ValueError("Ensembled entity detector must have at least one detector")

        detectors = []
        for detector_type in detectors_to_ensemble:
            detectors.append(EntityDetectorFactory.create_single_entity_detector(detector_type, **kwargs))

        return EnsembledEntityDetector(detectors)
