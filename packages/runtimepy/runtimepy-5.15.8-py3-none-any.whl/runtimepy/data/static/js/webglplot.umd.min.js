/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /gh/danchitnis/webgl-plot@master/dist/webglplot.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 *
  * removed sourcemappingurl manually
 */
!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports):"function"==typeof define&&define.amd?define(["exports"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).WebglPlotBundle={})}(this,(function(t){"use strict";class s{r;g;b;a;constructor(t,s,i,e){this.r=t,this.g=s,this.b=i,this.a=e}}class i{intensity;visible;numPoints;xy;color;scaleX;scaleY;offsetX;offsetY;loop;webglNumPoints;_vbuffer;_coord;constructor(){this.scaleX=1,this.scaleY=1,this.offsetX=0,this.offsetY=0,this.loop=!1,this._vbuffer=0,this._coord=0,this.visible=!0,this.intensity=1,this.xy=new Float32Array([]),this.numPoints=0,this.color=new s(0,0,0,1),this.webglNumPoints=0}}const e=(t,s,i)=>{const e={x:0,y:0};return e.x=t.x+s.x*i,e.y=t.y+s.y*i,e},o=t=>h(-t.y,t.x),n=(t,s)=>{let i=a(t,s);return i=r(i),i},r=t=>{const s={x:0,y:0};let i=t.x*t.x+t.y*t.y;return i>0&&(i=1/Math.sqrt(i),s.x=t.x*i,s.y=t.y*i),s},h=(t,s)=>{const i={x:0,y:0};return i.x=t,i.y=s,i},a=(t,s)=>{const i={x:0,y:0};return i.x=t.x-s.x,i.y=t.y-s.y,i},l=(t,s)=>{let i=((t,s)=>{const i={x:0,y:0};return i.x=t.x+s.x,i.y=t.y+s.y,i})(t,s);i=r(i);return h(-i.y,i.x)},g=(t,s,i)=>{const e=h(-t.y,t.x);return i/(n=e,(o=s).x*n.x+o.y*n.y);var o,n};t.ColorRGBA=s,t.WebglLine=class extends i{currentIndex=0;constructor(t,s){super(),this.webglNumPoints=s,this.numPoints=s,this.color=t,this.xy=new Float32Array(2*this.webglNumPoints)}setX(t,s){this.xy[2*t]=s}setY(t,s){this.xy[2*t+1]=s}getX(t){return this.xy[2*t]}getY(t){return this.xy[2*t+1]}lineSpaceX(t,s){for(let i=0;i<this.numPoints;i++)this.setX(i,t+s*i)}arrangeX(){this.lineSpaceX(-1,2/this.numPoints)}constY(t){for(let s=0;s<this.numPoints;s++)this.setY(s,t)}shiftAdd(t){const s=t.length;for(let t=0;t<this.numPoints-s;t++)this.setY(t,this.getY(t+s));for(let i=0;i<s;i++)this.setY(i+this.numPoints-s,t[i])}addArrayY(t){if(this.currentIndex+t.length<=this.numPoints)for(let s=0;s<t.length;s++)this.setY(this.currentIndex,t[s]),this.currentIndex++}replaceArrayY(t){if(t.length==this.numPoints)for(let s=0;s<this.numPoints;s++)this.setY(s,t[s])}},t.WebglPlot=class{webgl;gScaleX;gScaleY;gXYratio;gOffsetX;gOffsetY;gLog10X;gLog10Y;_linesData;_linesAux;_thickLines;_surfaces;get linesData(){return this._linesData}get linesAux(){return this._linesAux}get thickLines(){return this._thickLines}get surfaces(){return this._surfaces}_progLine;debug=!1;constructor(t,s){null==s?this.webgl=t.getContext("webgl",{antialias:!0,transparent:!1}):(this.webgl=t.getContext("webgl",{antialias:s.antialias,transparent:s.transparent,desynchronized:s.deSync,powerPerformance:s.powerPerformance,preserveDrawing:s.preserveDrawing}),this.debug=null!=s.debug&&s.debug),this.log("canvas type is: "+t.constructor.name),this.log(`[webgl-plot]:width=${t.width}, height=${t.height}`),this._linesData=[],this._linesAux=[],this._thickLines=[],this._surfaces=[],this.gScaleX=1,this.gScaleY=1,this.gXYratio=1,this.gOffsetX=0,this.gOffsetY=0,this.gLog10X=!1,this.gLog10Y=!1,this.webgl.clear(this.webgl.COLOR_BUFFER_BIT),this.webgl.viewport(0,0,t.width,t.height),this._progLine=this.webgl.createProgram(),this.initThinLineProgram(),this.webgl.enable(this.webgl.BLEND),this.webgl.blendFunc(this.webgl.SRC_ALPHA,this.webgl.ONE_MINUS_SRC_ALPHA)}_drawLines(t){const s=this.webgl;t.forEach((t=>{if(t.visible){s.useProgram(this._progLine);const i=s.getUniformLocation(this._progLine,"uscale");s.uniformMatrix2fv(i,!1,new Float32Array([t.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,t.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const e=s.getUniformLocation(this._progLine,"uoffset");s.uniform2fv(e,new Float32Array([t.offsetX+this.gOffsetX,t.offsetY+this.gOffsetY]));const o=s.getUniformLocation(this._progLine,"is_log");s.uniform2iv(o,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));const n=s.getUniformLocation(this._progLine,"uColor");s.uniform4fv(n,[t.color.r,t.color.g,t.color.b,t.color.a]),s.bufferData(s.ARRAY_BUFFER,t.xy,s.STREAM_DRAW),s.drawArrays(t.loop?s.LINE_LOOP:s.LINE_STRIP,0,t.webglNumPoints)}}))}_drawSurfaces(t){const s=this.webgl;t.forEach((t=>{if(t.visible){s.useProgram(this._progLine);const i=s.getUniformLocation(this._progLine,"uscale");s.uniformMatrix2fv(i,!1,new Float32Array([t.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,t.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const e=s.getUniformLocation(this._progLine,"uoffset");s.uniform2fv(e,new Float32Array([t.offsetX+this.gOffsetX,t.offsetY+this.gOffsetY]));const o=s.getUniformLocation(this._progLine,"is_log");s.uniform2iv(o,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));const n=s.getUniformLocation(this._progLine,"uColor");s.uniform4fv(n,[t.color.r,t.color.g,t.color.b,t.color.a]),s.bufferData(s.ARRAY_BUFFER,t.xy,s.STREAM_DRAW),s.drawArrays(s.TRIANGLE_STRIP,0,t.webglNumPoints)}}))}_drawTriangles(t){const s=this.webgl;s.bufferData(s.ARRAY_BUFFER,t.xy,s.STREAM_DRAW),s.useProgram(this._progLine);const i=s.getUniformLocation(this._progLine,"uscale");s.uniformMatrix2fv(i,!1,new Float32Array([t.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,t.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const e=s.getUniformLocation(this._progLine,"uoffset");s.uniform2fv(e,new Float32Array([t.offsetX+this.gOffsetX,t.offsetY+this.gOffsetY]));const o=s.getUniformLocation(this._progLine,"is_log");s.uniform2iv(o,new Int32Array([0,0]));const n=s.getUniformLocation(this._progLine,"uColor");s.uniform4fv(n,[t.color.r,t.color.g,t.color.b,t.color.a]),s.drawArrays(s.TRIANGLE_STRIP,0,t.xy.length/2)}_drawThickLines(){this._thickLines.forEach((t=>{if(t.visible){const s=Math.min(this.gScaleX,this.gScaleY);t.setActualThickness(t.getThickness()/s),t.convertToTriPoints(),this._drawTriangles(t)}}))}update(){this.clear(),this.draw()}draw(){this._drawLines(this.linesData),this._drawLines(this.linesAux),this._drawThickLines(),this._drawSurfaces(this.surfaces)}clear(){this.webgl.clear(this.webgl.COLOR_BUFFER_BIT)}_addLine(t){t._vbuffer=this.webgl.createBuffer(),this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER,t._vbuffer),this.webgl.bufferData(this.webgl.ARRAY_BUFFER,t.xy,this.webgl.STREAM_DRAW),t._coord=this.webgl.getAttribLocation(this._progLine,"coordinates"),this.webgl.vertexAttribPointer(t._coord,2,this.webgl.FLOAT,!1,0,0),this.webgl.enableVertexAttribArray(t._coord)}addDataLine(t){this._addLine(t),this.linesData.push(t)}addLine=this.addDataLine;addAuxLine(t){this._addLine(t),this.linesAux.push(t)}addThickLine(t){this._addLine(t),this._thickLines.push(t)}addSurface(t){this._addLine(t),this.surfaces.push(t)}initThinLineProgram(){const t=this.webgl.createShader(this.webgl.VERTEX_SHADER);this.webgl.shaderSource(t,"\n      attribute vec2 coordinates;\n      uniform mat2 uscale;\n      uniform vec2 uoffset;\n      uniform ivec2 is_log;\n\n      void main(void) {\n         float x = (is_log[0]==1) ? log(coordinates.x) : coordinates.x;\n         float y = (is_log[1]==1) ? log(coordinates.y) : coordinates.y;\n         vec2 line = vec2(x, y);\n         gl_Position = vec4(uscale*line + uoffset, 0.0, 1.0);\n      }"),this.webgl.compileShader(t);const s=this.webgl.createShader(this.webgl.FRAGMENT_SHADER);this.webgl.shaderSource(s,"\n         precision mediump float;\n         uniform highp vec4 uColor;\n         void main(void) {\n            gl_FragColor =  uColor;\n         }"),this.webgl.compileShader(s),this._progLine=this.webgl.createProgram(),this.webgl.attachShader(this._progLine,t),this.webgl.attachShader(this._progLine,s),this.webgl.linkProgram(this._progLine)}popDataLine(){this.linesData.pop()}removeAllLines(){this._linesData=[],this._linesAux=[],this._thickLines=[],this._surfaces=[]}removeDataLines(){this._linesData=[]}removeAuxLines(){this._linesAux=[]}viewport(t,s,i,e){this.webgl.viewport(t,s,i,e)}log(t){this.debug&&console.log("[webgl-plot]:"+t)}},t.WebglPolar=class extends i{numPoints;xy;color;intenisty;visible;offsetTheta;constructor(t,s){super(),this.webglNumPoints=s,this.numPoints=s,this.color=t,this.intenisty=1,this.xy=new Float32Array(2*this.webglNumPoints),this._vbuffer=0,this._coord=0,this.visible=!0,this.offsetTheta=0}setRtheta(t,s,i){const e=i*Math.cos(2*Math.PI*(s+this.offsetTheta)/360),o=i*Math.sin(2*Math.PI*(s+this.offsetTheta)/360);this.setX(t,e),this.setY(t,o)}getTheta(t){return 0}getR(t){return Math.sqrt(Math.pow(this.getX(t),2)+Math.pow(this.getY(t),2))}setX(t,s){this.xy[2*t]=s}setY(t,s){this.xy[2*t+1]=s}getX(t){return this.xy[2*t]}getY(t){return this.xy[2*t+1]}},t.WebglSquare=class extends i{constructor(t){super(),this.webglNumPoints=4,this.numPoints=4,this.color=t,this.xy=new Float32Array(2*this.webglNumPoints)}setSquare(t,s,i,e){this.xy=new Float32Array([t,s,t,e,i,s,i,e])}},t.WebglStep=class extends i{constructor(t,s){super(),this.webglNumPoints=2*s,this.numPoints=s,this.color=t,this.xy=new Float32Array(2*this.webglNumPoints)}setY(t,s){this.xy[4*t+1]=s,this.xy[4*t+3]=s}getX(t){return this.xy[4*t]}getY(t){return this.xy[4*t+1]}lineSpaceX(t,s){for(let i=0;i<this.numPoints;i++)this.xy[4*i]=t+i*s,this.xy[4*i+2]=t+(i*s+s)}constY(t){for(let s=0;s<this.numPoints;s++)this.setY(s,t)}shiftAdd(t){const s=t.length;for(let t=0;t<this.numPoints-s;t++)this.setY(t,this.getY(t+s));for(let i=0;i<s;i++)this.setY(i+this.numPoints-s,t[i])}},t.WebglThickLine=class extends i{currentIndex=0;_linePoints;_thicknessRequested=0;_actualThickness=0;constructor(t,s,i){super(),this.webglNumPoints=2*s,this.numPoints=s,this.color=t,this._thicknessRequested=i,this._linePoints=new Float32Array(2*s),this.xy=new Float32Array(2*this.webglNumPoints)}convertToTriPoints(){const t=this._actualThickness/2,s=(t=>{let s,i={x:0,y:0},e={x:0,y:0};const r=[],h=(t,s)=>{r.push({vec2:t,miterLength:s})},a=s=>({x:t[2*s],y:t[2*s+1]});i=n(a(1),a(0)),s=o(i),h(s,1);const c=t.length/2;for(let t=1;t<c-1;t++){const r=a(t-1),c=a(t),u=a(t+1);i=n(c,r),s=o(i),e=n(u,c);const f=l(i,e);h(f,g(i,f,1))}return i=n(a(c-1),a(c-2)),s=o(i),h(s,1),r})(this._linePoints);for(let i=0;i<this.numPoints;i++){const o={x:this._linePoints[2*i],y:this._linePoints[2*i+1]},n=e(o,s[i].vec2,s[i].miterLength*t),r=e(o,s[i].vec2,-s[i].miterLength*t);this.xy[4*i]=n.x,this.xy[4*i+1]=n.y,this.xy[4*i+2]=r.x,this.xy[4*i+3]=r.y}}setX(t,s){this._linePoints[2*t]=s}setY(t,s){this._linePoints[2*t+1]=s}lineSpaceX(t,s){for(let i=0;i<this.numPoints;i++)this.setX(i,t+s*i)}setThickness(t){this._thicknessRequested=t}getThickness(){return this._thicknessRequested}setActualThickness(t){this._actualThickness=t}}}));
