"""
Type stubs for diskcache_rs package

This package provides a high-performance disk cache implementation in Rust
with Python bindings, compatible with python-diskcache API.
"""

from typing import Any, Dict, Iterator, List, Optional, Union, Callable, ContextManager
from pathlib import Path
import os

# Version
__version__: str

# Main Cache Classes
class Cache:
    """High-performance disk cache compatible with python-diskcache API"""
    
    def __init__(
        self,
        directory: Optional[Union[str, Path]] = None,
        timeout: float = 60.0,
        disk_min_file_size: int = 32768,
        **kwargs: Any
    ) -> None: ...
    
    def __contains__(self, key: Any) -> bool: ...
    def __enter__(self) -> "Cache": ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    
    def get(self, key: Any, default: Any = None, retry: bool = False) -> Any: ...
    def set(self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def add(self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def delete(self, key: Any, retry: bool = False) -> bool: ...
    def pop(self, key: Any, default: Any = None, expire: Optional[float] = None, retry: bool = False) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: Any) -> bool: ...
    def keys(self) -> Iterator[Any]: ...
    def values(self) -> Iterator[Any]: ...
    def items(self) -> Iterator[tuple[Any, Any]]: ...
    def iterkeys(self) -> Iterator[Any]: ...
    def itervalues(self) -> Iterator[Any]: ...
    def iteritems(self) -> Iterator[tuple[Any, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(self, key: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def incr(self, key: Any, delta: Union[int, float] = 1, default: Union[int, float] = 0, retry: bool = False) -> Union[int, float]: ...
    def decr(self, key: Any, delta: Union[int, float] = 1, default: Union[int, float] = 0, retry: bool = False) -> Union[int, float]: ...
    
    # Properties
    @property
    def directory(self) -> Path: ...

class FanoutCache:
    """Fanout cache implementation for better concurrency"""
    
    def __init__(
        self,
        directory: Optional[Union[str, Path]] = None,
        shards: int = 8,
        timeout: float = 60.0,
        **kwargs: Any
    ) -> None: ...
    
    def __contains__(self, key: Any) -> bool: ...
    def __enter__(self) -> "FanoutCache": ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    
    def get(self, key: Any, default: Any = None, retry: bool = False) -> Any: ...
    def set(self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def add(self, key: Any, value: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def delete(self, key: Any, retry: bool = False) -> bool: ...
    def pop(self, key: Any, default: Any = None, expire: Optional[float] = None, retry: bool = False) -> Any: ...
    def clear(self, retry: bool = False) -> int: ...
    def close(self) -> None: ...
    def exists(self, key: Any) -> bool: ...
    def keys(self) -> Iterator[Any]: ...
    def values(self) -> Iterator[Any]: ...
    def items(self) -> Iterator[tuple[Any, Any]]: ...
    def expire(self, now: Optional[float] = None) -> int: ...
    def evict(self, tag: Optional[str] = None) -> int: ...
    def stats(self, enable: bool = True, reset: bool = False) -> tuple[int, int]: ...
    def volume(self) -> int: ...
    def reset(self, key: str, value: Any = None) -> None: ...
    def touch(self, key: Any, expire: Optional[float] = None, retry: bool = False) -> bool: ...
    def incr(self, key: Any, delta: Union[int, float] = 1, default: Union[int, float] = 0, retry: bool = False) -> Union[int, float]: ...
    def decr(self, key: Any, delta: Union[int, float] = 1, default: Union[int, float] = 0, retry: bool = False) -> Union[int, float]: ...

# Fast Cache Classes
class FastCache(Cache):
    """Ultra-fast cache implementation with optimized storage backends"""
    pass

class FastFanoutCache(FanoutCache):
    """Ultra-fast fanout cache implementation"""
    pass

# Pickle Cache
class PickleCache:
    """High-performance pickle cache with expiration support"""
    
    def __init__(self, cache_dir: Union[str, Path] = "pickle_cache") -> None: ...
    def cache_object(self, key: str, obj: Any, expire_hours: float = 24.0) -> None: ...
    def get_cached_object(self, key: str) -> Optional[Any]: ...
    def clear_cache(self) -> None: ...
    def is_expired(self, key: str) -> bool: ...
    def delete_object(self, key: str) -> bool: ...
    def list_cached_objects(self) -> List[str]: ...
    def get_cache_stats(self) -> Dict[str, Any]: ...

# Utility Functions
def cache_object(key: str, obj: Any, expire_hours: float = 24.0, cache_dir: Union[str, Path] = "pickle_cache") -> None:
    """Cache an object with expiration"""
    ...

def get_cached_object(key: str, cache_dir: Union[str, Path] = "pickle_cache") -> Optional[Any]:
    """Retrieve a cached object"""
    ...

def clear_cache(cache_dir: Union[str, Path] = "pickle_cache") -> None:
    """Clear all cached objects"""
    ...

# Rust Functions (from _diskcache_rs module)
def rust_pickle_dumps(obj: Any) -> Any:
    """High-performance pickle serialization using Rust"""
    ...

def rust_pickle_loads(data: Any) -> Any:
    """High-performance pickle deserialization using Rust"""
    ...

# Backward compatibility
DiskCache = Cache

# All exports
__all__ = [
    "Cache",
    "FanoutCache", 
    "FastCache",
    "FastFanoutCache",
    "PickleCache",
    "cache_object",
    "get_cached_object", 
    "clear_cache",
    "rust_pickle_dumps",
    "rust_pickle_loads",
    "DiskCache",
]
