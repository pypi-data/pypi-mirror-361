from typing import Any, Type, cast

from tortoise import Model
from tortoise.contrib.pydantic import PydanticModel, pydantic_model_creator

from fastapi_mason.types import T


class SchemaMeta:
    include: tuple[str, ...] = ()
    exclude: tuple[str, ...] = ()
    optional: tuple[str, ...] = ()
    computed: tuple[str, ...] = ()

    def to_dict(self):
        return {
            'include': self.include,
            'exclude': self.exclude,
            'optional': self.optional,
            'computed': self.computed,
        }


def generate_schema_meta(
    *meta_structure: SchemaMeta | tuple[str, SchemaMeta], class_name: str = 'SchemaMeta'
) -> type[SchemaMeta]:
    def build_fields(_meta_structure, attr_name: str):
        result = []
        for item in _meta_structure:
            if isinstance(item, tuple):
                field_name, meta_cls = item
                fields = getattr(meta_cls, attr_name, ())
                if fields:
                    result.append(field_name)
                    result.extend(f'{field_name}.{field}' for field in fields)
            else:
                fields = getattr(item, attr_name, ())
                result.extend(fields)
        return tuple(result)

    return type(
        class_name,
        (SchemaMeta,),
        {
            'include': build_fields(meta_structure, 'include'),
            'exclude': build_fields(meta_structure, 'exclude'),
            'optional': build_fields(meta_structure, 'optional'),
            'computed': build_fields(meta_structure, 'computed'),
        },
    )


def generate_schema(
    cls: type[Model],
    *,
    meta: SchemaMeta | tuple[str, SchemaMeta] | None = None,
    name=None,
    exclude_readonly: bool = False,
    **kwargs,
) -> type[PydanticModel]:
    config = {
        'cls': cls,
        'meta_override': generate_schema_meta(meta),
        'name': name,
        'exclude_readonly': exclude_readonly,
        **kwargs,
    }
    schema = pydantic_model_creator(**config)
    schema.model_config['_mason_config'] = config
    return schema


def rebuild_schema(
    schema: type[PydanticModel],
    name=None,
    meta: SchemaMeta | tuple[str, SchemaMeta] | None = None,
    exclude_readonly: bool = False,
    **kwargs,
) -> type[PydanticModel]:
    config: dict[str, Any] = schema.model_config.get('_mason_config')
    if not config:
        raise ValueError('Schema should be generated by fastapi_mason.schemas.generate_schema')
    if name is not None:
        config['name'] = name
    if meta is not None:
        config['meta_override'] = generate_schema_meta(meta)
    if exclude_readonly is not None:
        config['exclude_readonly'] = exclude_readonly
    config.update(kwargs)
    schema = generate_schema(**config)
    return schema


def generate_schema_cls(schema: Type[T], model: Type[Model]) -> Type[T]:
    model_config = schema.model_config
    title = model_config.get('title', schema.__name__ + 'Generated')
    new_cls = type(title, (model, schema), {})
    return cast(Type[T], new_cls)
