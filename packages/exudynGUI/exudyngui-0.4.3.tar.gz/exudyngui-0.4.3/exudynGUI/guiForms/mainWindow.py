# -*- coding: utf-8 -*-
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# This is part of the Exudyn GUI project
#
# Filename: guiForms/mainWindow.py
#
# Description:
#     Main application window for the Exudyn model builder GUI.
#     Provides a complete interface for creating, editing, simulating, and exporting multibody models.
#     Supports model structure visualization, bidirectional connection tracking, and full Exudyn integration.
#     Includes dynamic user function handling, code generation, undo stack, and dependency validation.
#
# Authors:  Michael Pieber
# Date:     2025-05-12
# Notes:    Uses object registry and modelSequence for full flexibility.
#
# License:  BSD-3 license
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import numpy as np
import exudyn as exu # Core Exudyn library
import pprint # For pretty printing
import os
import sys
import time
from pathlib import Path
import json
from datetime import datetime
import tempfile
import os
from exudynGUI.core.debug import debugLog

# Add file logging to capture all output
log_dir = os.path.join(os.path.dirname(__file__), '..', 'logs')
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, f'exudyn_gui_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')

class TeeOutput:
    def __init__(self, file1, file2):
        self.file1 = file1
        self.file2 = file2
    def write(self, data):
        self.file1.write(data)
        self.file2.write(data)
        self.file1.flush()
        self.file2.flush()
    def flush(self):
        self.file1.flush()
        self.file2.flush()

log_handle = open(log_file, 'w', encoding='utf-8')
sys.stdout = TeeOutput(sys.stdout, log_handle)
sys.stderr = TeeOutput(sys.stderr, log_handle)

debugLog(f"üîç Exudyn GUI starting - logging to: {log_file}")
debugLog(f"üîç Timestamp: {datetime.now().isoformat()}")

from exudynGUI.core.rendererState import (
    saveRendererStateFor, 
    restoreRendererStateFor,
    setupRendererTimer,
    restoreViewState,
    saveViewState,
    clearViewState,
)



sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
# Debug output removed - sys.path accessible via debugger if needed

# Import PyQt classes
from PyQt5.QtWidgets import (
    QMainWindow, QDockWidget, QWidget, QVBoxLayout, QTextEdit, QTreeWidget, 
    QDialog, QPushButton, QFileDialog, QMessageBox, QHBoxLayout, QGridLayout, 
    QLabel, QTabWidget, QToolBar, QSplitter, QFrame, QScrollArea,
    QGroupBox, QSizePolicy, QApplication, QAction
)

from PyQt5.QtCore import Qt, QTimer, QSize
from PyQt5.QtGui import QFont, QIcon, QPixmap, QDesktopServices
from PyQt5.QtCore import QUrl
# Jupyter console imports
try:
    from qtconsole.rich_jupyter_widget import RichJupyterWidget
    from qtconsole.manager import QtKernelManager
    JUPYTER_AVAILABLE = True
except ImportError:
    RichJupyterWidget = None
    QtKernelManager = None
    JUPYTER_AVAILABLE = False
    debugLog("‚ö†Ô∏è Jupyter qtconsole not available - using fallback console")

import copy

# Fix imports
from exudynGUI.core.qtImports import *
from exudynGUI.model.objectRegistry import getCategorizedRegistry, registry, evaluateGraphicsDataList, deepSummarize
from exudynGUI.model.modelData import modelSequence
from exudynGUI.core.variableManager import loadUserVariables, setLiveEditor
from exudynGUI.guiForms.addItemDialog import AddItemDialog
from exudynGUI.guiForms.autoGeneratedForm import AutoGeneratedForm
from exudynGUI.guiForms.graphicsDataDialog import GraphicsDataDialog
from exudynGUI.guiForms.inertiaDataDialog import InertiaDataDialog
from exudynGUI.guiForms.userFunctionEditor import UserFunctionEditorDialog
from exudynGUI.guiForms.variableEditor import VariableEditor
from exudynGUI.guiForms.flexibleBodyDialog import FlexibleBodyDialog
from exudynGUI.guiForms.exudynRenderer import ExudynRendererWidget


from exudynGUI.guiForms.exudynNativeRenderer import ExudynNativeRendererWidget
from exudynGUI.functions.flexibleBody import create_flexible_body_from_ngsolve
from exudynGUI.core.modelManager import (
    addItemToModel, editModelItem, removeModelItem, undoLastAction,
    buildSystemFromSequence,
    extractModelStructure, buildModelTree, getActualComponentType, formatComponentLabel
)
from exudynGUI.core.debug import debugLog
from exudynGUI.core.generateCode import generateExudynCodeFromItems
from exudynGUI.core.fieldValidation import *
from exudynGUI.core.specialFields import *

try:
    from exudynGUI.core.modelManager import extractStructureInfo, generateSimulationCode, build_model_item
except ImportError:
    # Fallback if modelManager not available
    def extractStructureInfo(*args, **kwargs):
        return {}
    def generateSimulationCode(*args, **kwargs):
        return ""
    def build_model_item(item):
        return item
from qtconsole.rich_jupyter_widget import RichJupyterWidget
from qtconsole.inprocess import QtInProcessKernelManager as QtKernelManager

# For live editing in variable editor
# from ..core.liveEditor import setLiveEditor  # Removed: file does not exist, use variableManager import above

def _summarize_large_blobs(obj, max_size=1000):
    """Summarize large data structures to avoid overwhelming debug output."""
    if isinstance(obj, dict):
        return {k: _summarize_large_blobs(v, max_size) for k, v in obj.items()}
    elif isinstance(obj, list):
        if len(obj) > 10:
            return f"<list with {len(obj)} items: {[_summarize_large_blobs(obj[i], max_size) for i in range(3)]}...>"
        return [_summarize_large_blobs(item, max_size) for item in obj]
    elif isinstance(obj, str) and len(obj) > max_size:
        return f"<string of length {len(obj)}: '{obj[:50]}...'>"
    elif hasattr(obj, '__dict__') and len(str(obj)) > max_size:
        return f"<{type(obj).__name__} object>"
    else:
        return obj




class JupyterConsoleWidget(RichJupyterWidget):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class MainWindow(QMainWindow):
    lastModelTreeDict = {} # Keep if other parts rely on it
    lastCombinedModelInfoDict = {} # New static variable for the combined info
    graphicsEditAccepted = pyqtSignal(list)
    def __init__(self, parent=None, SC=None, mbs=None, app_version="", pdfBookmarks=None, pdfPath=None):
        super().__init__(parent)
        self.SC = SC
        self.mbs = mbs
        # Initialize simulation settings with defaults
        self.simulationSettings = None
        self.initializeSimulationSettings()

        self.app_version = app_version
        self.setupMenuBar()
        self.setWindowTitle("Exudyn Model Builder")
        
        # Set PDF documentation from parameters (loaded at startup)
        self._pdfBookmarks = pdfBookmarks
        self._pdfPath = pdfPath
        if self._pdfBookmarks:
            debugLog("‚úÖ PDF documentation bookmarks passed from startup", origin="MainWindow")
        else:
            debugLog("‚ö†Ô∏è No PDF documentation bookmarks provided at startup", origin="MainWindow")
        
        # Set minimum size to prevent too small windows
        #self.setMinimumSize(1200, 800)

        # 1. Load any previously‚Äêsaved variables (so self.userVariables is up to date):
        self.userVariables = loadUserVariables()
        # Always use the global modelSequence, not a local copy
        from exudynGUI.model.modelData import modelSequence
        self.modelSequence = modelSequence
        # Ensure all items in modelSequence use the new structure
        for i, item in enumerate(self.modelSequence):
            if not ('data' in item and 'GUI' in item):
                self.modelSequence[i] = build_model_item(item)
        
        # 2. Initialize model tracking state
        #
        
        # Initialize undoStack and other required variables
        self.undoStack = []
        self.structure = {}
        self.rendererStarted = False
        
        # 2. (Keep your existing "model‚Äêtracking" code here‚Ä¶)
        self.resetModelTrackingState()        # Variable Editor is now integrated in the left panel
        # self.variableEditor = VariableEditor(parent=self)  # REMOVED - using integrated version        # Dock widget creation removed - using integrated variable editor

        #    c) Now *that* it exists, load the file from disk into its QTextEdit
        #       (exudynGUI/functions/userVariables.py)
        # self.variableEditor.loadFile()  # REMOVED - using integrated version

        #    d) Tell variableManager which QTextEdit is "live" (so getLiveUserVariableText() works)
        # setLiveEditor(self.variableEditor.editor)  # REMOVED - using integrated version


        # ‚îÄ‚îÄ‚îÄ Now continue with the rest of your setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Create or assign the main SystemContainer
        if SC is not None:
            self.SC = SC
        else:
            import exudyn as exu
            self.SC = exu.SystemContainer()
        # ... existing code ...
        # Cache the default visualization settings from the main SC
        from exudynGUI.core.settingsComparison import cache_default_visualization_settings
        cache_default_visualization_settings(self.SC)
        # ... existing code ...


        # Debug log to verify mbs and SC initialization
        # debugLog(f"Initial mbs state: {self.mbs}", origin="MainWindow")  # Reduced for memory
        # debugLog(f"Initial SC state: {self.SC}", origin="MainWindow")  # Reduced for memory

        # Prevent unnecessary re-initialization
        if not self.mbs:
            self.mbs = self.SC.AddSystem()
            debugLog("mbs was None, re-initialized using SC.AddSystem().", origin="MainWindow")

        # Start the IPython kernel, etc.
        self.kernel_manager = QtKernelManager(kernel_name='python3')
        self.kernel_manager.start_kernel()
        self.kernel_client = self.kernel_manager.client()
        self.kernel_client.start_channels()

        # Add debug logs to verify kernel connection
        # debugLog("Kernel manager initialized.", origin="MainWindow")  # Reduced for memory
        # debugLog("Kernel client channels started.", origin="MainWindow")  # Reduced for memory

        # # Now inject mbs and SC into the kernel
        # self.kernel_client.execute("mbs = None")
        # self.kernel_client.execute("SC = None")

        self.kernel_client.execute("import base64")
        # Add debug logs to verify injection


        # ‚Ä¶ after you've started the kernel_client and before rendering ‚Ä¶
        self.bind_to_kernel(mbs=self.mbs, SC=self.SC)
        
        # Load console bridge module for external connectivity
        # try:
        #     bridge_path = Path(__file__).parent.parent / "gui_console_bridge.py"
        #     if bridge_path.exists():
        #         with open(bridge_path, 'r', encoding='utf-8') as f:
        #             bridge_code = f.read()
        #         self.kernel_client.execute(bridge_code)
        #         self.bind_to_kernel(main_window=self)  # Inject main window reference
        #         debugLog("Console bridge module loaded - external connectivity enabled", origin="MainWindow")
        #     else:
        #         debugLog("Console bridge module not found", origin="MainWindow")
        # except Exception as e:
        #     debugLog(f"Failed to load console bridge: {e}", origin="MainWindow")        
        #######################################################################
        # Create the new organized layout
        self.setupRibbonInterface()
          # Setup renderer timer for DoIdleTasks management
        self.setupRendererTimer()


        self.setMinimumSize(100, 100)  # allow very small window
        self.setMaximumSize(16777215, 16777215)  # allow very large window
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)


        self.legacy_help_cache = {}
        #self._precompute_legacy_help()

    def resizeEvent(self, event):
        super().resizeEvent(event)

    def initializeSimulationSettings(self):
        """Initialize simulation settings with exudyn factory defaults."""
        import exudyn as exu
        import copy
        
        # Use true exudyn factory defaults, not custom "reasonable" defaults
        self.simulationSettings = exu.SimulationSettings()
        
        # Store original settings for comparison
        self.original_simulation_settings = copy.deepcopy(self.simulationSettings)

    def showSimulationSettings(self):
        """Open the simulation settings dialog."""
        from guiForms.simulationSettings import createSimulationSettingsForm, collectSimulationSettingsData, applySimulationSettings
        from exudynGUI.core.debug import debugLog
        import copy
        
        try:
            # Store original settings for comparison
            self.original_simulation_settings = copy.deepcopy(self.simulationSettings)
            
            # Create the dialog with existing settings
            dialog = createSimulationSettingsForm(self, self.simulationSettings)
            
            # Show the dialog
            if dialog.exec_() == dialog.Accepted:
                # Collect the modified settings
                settings_data = collectSimulationSettingsData(dialog)
                
                # Apply the settings to our stored simulation settings
                applySimulationSettings(self.simulationSettings, settings_data)
                
                debugLog("‚úÖ Simulation settings updated successfully", origin="mainWindow.py")
                
                # Optionally show a status message
                self.statusBar().showMessage("Simulation settings updated", 2000)
                
        except Exception as e:
            debugLog(f"‚ùå Error in simulation settings dialog: {e}", origin="mainWindow.py")
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.critical(self, "Error", f"Failed to open simulation settings:\n{str(e)}")


    def setupRendererTimer(self):
        """Setup periodic renderer refresh to handle DoIdleTasks."""
        # Call the imported function from rendererState.py
        setupRendererTimer(self)

    def saveCurrentViewAsReference(self):
        """Save current view as reference."""
        return saveViewState(self, "reference")

    def clearReferenceViewState(self):
        """Clear reference view state."""
        clearViewState("reference")

    def cleanupMemory(self):
        """Clean up memory to prevent OOM issues."""
        try:
            # Limit modelSequence size to prevent unbounded growth
            if hasattr(self, 'modelSequence') and len(self.modelSequence) > 1000:
                # Keep only the last 500 items
                self.modelSequence = self.modelSequence[-500:]
                # Cleaned up modelSequence - reduced to 500 items
            
            # Clear undo stack if it gets too large
            if hasattr(self, 'undoStack') and len(self.undoStack) > 100:
                self.undoStack = self.undoStack[-50:]
                # Cleaned up undoStack - reduced to 50 items
                
            # Force garbage collection
            import gc
            gc.collect()
            
        except Exception as e:
            pass

    def setupMemoryTimer(self):
        """Setup periodic memory cleanup to prevent OOM."""
        if hasattr(self, 'memory_timer'):
            return  # Already setup
            
        from PyQt5.QtCore import QTimer
        self.memory_timer = QTimer()
        self.memory_timer.timeout.connect(self.cleanupMemory)
        self.memory_timer.start(30000)  # Clean up every 30 seconds
        # Memory cleanup timer started (30s interval)


    def startRendererRefresh(self):
        """Start continuous renderer refresh."""
        if hasattr(self, 'renderer_timer') and self.renderer_timer is not None:
            if not self.renderer_refresh_active:
                self.renderer_timer.start(100)  # Refresh every 100ms
                self.renderer_refresh_active = True
                debugLog("üîÑ Started continuous renderer refresh", origin="MainWindow")
        else:
            debugLog("‚ö†Ô∏è Cannot start renderer refresh - timer not initialized", origin="MainWindow")



    def stopRendererRefresh(self):
        """Stop continuous renderer refresh."""
        if hasattr(self, 'renderer_timer') and self.renderer_timer is not None:
            self.renderer_timer.stop()
            self.renderer_timer = None
        self.renderer_refresh_active = False
        debugLog("üõë Stopped continuous renderer refresh", origin="MainWindow")

    def refreshRenderer(self):
        """Refresh the renderer - called by timer."""
        try:
            if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                # Only refresh if renderer is active and window is visible
                renderer_is_active = False
                
                # Check if renderer is active using available methods
                if (hasattr(self, 'solution_viewer') and self.solution_viewer):
                    if hasattr(self.solution_viewer, 'isRendererActive'):
                        renderer_is_active = self.solution_viewer.isRendererActive()
                    elif hasattr(self.solution_viewer, 'renderer_active'):
                        renderer_is_active = getattr(self.solution_viewer, 'renderer_active', False)
                    else:
                        # Fallback: assume renderer is active if solution_viewer exists
                        renderer_is_active = True
                
                if renderer_is_active and self.isVisible():
                    self.SC.renderer.DoIdleTasks(waitSeconds=0.1)
                    
        except Exception as e:
            # Don't spam the log with renderer errors, just log occasionally
            if not hasattr(self, '_last_renderer_error_time'):
                self._last_renderer_error_time = 0
            
            import time
            current_time = time.time()
            if current_time - self._last_renderer_error_time > 5.0:  # Log error every 5 seconds max
                debugLog(f"‚ö†Ô∏è Renderer refresh error: {e}", origin="MainWindow")
                self._last_renderer_error_time = current_time
    
    def saveView(self):
        """Save the current view state (camera position, zoom, etc.)."""
        try:
            if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                # Get current renderer state
                current_state = self.SC.renderer.GetState()
                
                # Convert to JSON-serializable format
                serializable_state = self._convertViewStateToSerializable(current_state)
                
                # Store the view state
                self.saved_view_state = serializable_state
                
                # Show confirmation message
                debugLog("üì∑ View state saved successfully", origin="MainWindow")
                
                # Optional: Show a brief status message
                if hasattr(self, 'statusBar'):
                    self.statusBar().showMessage("View state saved", 2000)
                    
        except Exception as e:
            debugLog(f"‚ùå Failed to save view state: {e}", origin="MainWindow")
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage("Failed to save view state", 3000)
    
    def restoreView(self, retry_count=0):
        """Restore the previously saved view state with multiple fallback strategies."""
        max_retries = 5  # Maximum number of retries
        
        try:
            if not hasattr(self, 'saved_view_state') or not self.saved_view_state:
                debugLog("‚ö†Ô∏è No saved view state to restore", origin="MainWindow")
                if hasattr(self, 'statusBar'):
                    self.statusBar().showMessage("No saved view state to restore", 3000)
                return
                
            # Check if renderer is ready
            if not self._isRendererReady():
                if retry_count < max_retries:
                    debugLog(f"‚è∞ Renderer not ready, scheduling delayed restoration (attempt {retry_count + 1}/{max_retries})...", origin="MainWindow")
                    # Store retry count and use proper callback method
                    self._restore_retry_count = retry_count + 1
                    QTimer.singleShot(1000, self._delayedRestoreView)
                    return
                else:
                    debugLog(f"‚ùå Renderer never became ready after {max_retries} attempts, giving up", origin="MainWindow")
                    if hasattr(self, 'statusBar'):
                        self.statusBar().showMessage("Renderer not ready for view restoration", 3000)
                    return
                
            if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                success = False
                
                # Strategy 1: Try enhanced conversion with type preservation
                try:
                    debugLog("üîÑ Attempting enhanced view state restoration...", origin="MainWindow")
                    exudyn_state = self._convertViewStateFromSerializable(self.saved_view_state)
                    self.SC.renderer.SetState(exudyn_state)
                    success = True
                    debugLog("‚úÖ Enhanced view state restoration successful", origin="MainWindow")
                except Exception as e1:
                    debugLog(f"‚ö†Ô∏è Enhanced restoration failed: {e1}", origin="MainWindow")
                
                # Strategy 2: Try direct restoration (for old format states)
                if not success:
                    try:
                        debugLog("üîÑ Attempting direct view state restoration...", origin="MainWindow")
                        self.SC.renderer.SetState(self.saved_view_state)
                        success = True
                        debugLog("‚úÖ Direct view state restoration successful", origin="MainWindow")
                    except Exception as e2:
                        debugLog(f"‚ö†Ô∏è Direct restoration failed: {e2}", origin="MainWindow")
                
                # Strategy 3: Try simplified state (only basic numeric values)
                if not success:
                    try:
                        debugLog("üîÑ Attempting simplified view state restoration...", origin="MainWindow")
                        simplified_state = self._createSimplifiedViewState(self.saved_view_state)
                        self.SC.renderer.SetState(simplified_state)
                        success = True
                        debugLog("‚úÖ Simplified view state restoration successful", origin="MainWindow")
                    except Exception as e3:
                        debugLog(f"‚ö†Ô∏è Simplified restoration failed: {e3}", origin="MainWindow")
                
                if success:
                    # Show confirmation message
                    debugLog("üì∑ View state restored successfully", origin="MainWindow")
                    if hasattr(self, 'statusBar'):
                        self.statusBar().showMessage("View state restored", 2000)
                else:
                    debugLog("‚ùå All view state restoration strategies failed", origin="MainWindow")
                    if hasattr(self, 'statusBar'):
                        self.statusBar().showMessage("Failed to restore view state", 3000)
                    
        except Exception as e:
            debugLog(f"‚ùå Critical error in view state restoration: {e}", origin="MainWindow")
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage("Failed to restore view state", 3000)
    
    def _delayedRestoreView(self):
        """Callback method for QTimer to handle delayed view restoration."""
        try:
            retry_count = getattr(self, '_restore_retry_count', 0)
            debugLog(f"üîÑ Timer callback: Attempting delayed view restoration (retry {retry_count})...", origin="MainWindow")
            
            # Clear the stored retry count
            if hasattr(self, '_restore_retry_count'):
                delattr(self, '_restore_retry_count')
            
            # Call restoreView with the stored retry count
            self.restoreView(retry_count)
            
        except Exception as e:
            debugLog(f"‚ùå Error in delayed restore callback: {e}", origin="MainWindow")
    
    def _convertViewStateToSerializable(self, state):
        """Convert exudyn view state to JSON-serializable format."""
        if not isinstance(state, dict):
            return state
        
        serializable_state = {}
        for key, value in state.items():
            try:
                # Convert numpy arrays and similar objects to lists with type information
                if hasattr(value, 'tolist'):  # numpy arrays
                    serializable_state[key] = {
                        '__type__': 'numpy_array',
                        '__data__': value.tolist(),
                        '__dtype__': str(value.dtype) if hasattr(value, 'dtype') else 'float64'
                    }
                elif hasattr(value, '__iter__') and not isinstance(value, (str, bytes)):
                    # Convert iterables (like SlimVector3) to lists with type info
                    try:
                        data_list = list(value)
                        serializable_state[key] = {
                            '__type__': type(value).__name__,
                            '__data__': data_list,
                            '__module__': getattr(type(value), '__module__', 'unknown')
                        }
                    except:
                        serializable_state[key] = str(value)  # Fallback to string
                else:
                    # Keep basic types as-is
                    serializable_state[key] = value
            except Exception as e:
                debugLog(f"‚ö†Ô∏è Could not serialize view state key '{key}': {e}", origin="MainWindow")
                # Store as string fallback
                serializable_state[key] = str(value)
        
        return serializable_state
    
    def _convertViewStateFromSerializable(self, serializable_state):
        """Convert JSON-serializable view state back to exudyn format."""
        if not isinstance(serializable_state, dict):
            return serializable_state
        
        exudyn_state = {}
        for key, value in serializable_state.items():
            try:
                # Handle any string values that need conversion
                if isinstance(value, str):
                    # Handle legacy numpy array strings like "array([1, 2, 3])" 
                    if value.startswith('array('):
                        try:
                            import numpy as np
                            # Replace 'array(' with 'np.array(' and evaluate
                            numpy_code = value.replace('array(', 'np.array(')
                            # Use eval in a controlled environment with only numpy available
                            safe_globals = {'np': np, 'numpy': np}
                            exudyn_state[key] = eval(numpy_code, safe_globals, {})
                            continue
                        except Exception as e:
                            debugLog(f"‚ö†Ô∏è Failed to parse legacy numpy array string '{value}': {e}", origin="MainWindow")
                    
                    # Handle numeric strings
                    elif value.replace('.', '').replace('-', '').replace('+', '').replace('e', '').replace('E', '').isdigit():
                        try:
                            if '.' in value or 'e' in value.lower():
                                exudyn_state[key] = float(value)
                            else:
                                exudyn_state[key] = int(value)
                            continue
                        except ValueError:
                            pass
                    
                    # Handle boolean strings
                    elif value.lower() in ('true', 'false'):
                        exudyn_state[key] = value.lower() == 'true'
                        continue
                    
                    # Handle enum strings like "ItemType._None", "LinearSolverType.EigenSparse"
                    elif '.' in value and any(enum_type in value for enum_type in [
                        'ItemType', 'LinearSolverType', 'DynamicSolverType', 'NodeType', 
                        'OutputVariableType', 'AccessFunctionType', 'ConfigurationType', 
                        'ContactTypeIndex', 'CrossSectionType', 'JointType', 'ObjectType'
                    ]):
                        try:
                            import exudyn as exu
                            # Parse enum string like "ItemType._None" 
                            if value.count('.') == 1:
                                enum_class_name, enum_value_name = value.split('.')
                                if hasattr(exu, enum_class_name):
                                    enum_class = getattr(exu, enum_class_name)
                                    if hasattr(enum_class, enum_value_name):
                                        exudyn_state[key] = getattr(enum_class, enum_value_name)
                                        continue
                            # Handle full module path like "exudyn.ItemType._None"
                            elif value.startswith('exudyn.') or value.startswith('exu.'):
                                parts = value.split('.')
                                if len(parts) >= 3:
                                    enum_class_name = parts[-2]
                                    enum_value_name = parts[-1]
                                    if hasattr(exu, enum_class_name):
                                        enum_class = getattr(exu, enum_class_name)
                                        if hasattr(enum_class, enum_value_name):
                                            exudyn_state[key] = getattr(enum_class, enum_value_name)
                                            continue
                        except Exception as e:
                            debugLog(f"‚ö†Ô∏è Failed to parse enum string '{value}': {e}", origin="MainWindow")
                    
                    # Handle list-like strings "[1, 2, 3]"
                    elif value.startswith('[') and value.endswith(']'):
                        try:
                            import ast
                            parsed_list = ast.literal_eval(value)
                            if isinstance(parsed_list, list):
                                # Convert to proper numeric types
                                if all(isinstance(x, (int, float)) for x in parsed_list):
                                    exudyn_state[key] = [float(x) for x in parsed_list]
                                else:
                                    exudyn_state[key] = parsed_list
                                continue
                        except:
                            pass
                    
                    # If string conversion fails, keep as string but log warning
                    debugLog(f"‚ö†Ô∏è Keeping string value for key '{key}': {value}", origin="MainWindow")
                    exudyn_state[key] = value
                    continue
                
                # Check if this is a structured type with type information
                elif isinstance(value, dict) and '__type__' in value and '__data__' in value:
                    type_name = value['__type__']
                    data = value['__data__']
                    
                    if type_name == 'numpy_array':
                        # Try to recreate numpy array
                        try:
                            import numpy as np
                            dtype = value.get('__dtype__', 'float64')
                            exudyn_state[key] = np.array(data, dtype=dtype)
                        except:
                            # Fallback to plain list
                            exudyn_state[key] = [float(x) for x in data]
                    
                    elif type_name == 'SlimVector3' or 'Vector' in type_name:
                        # For exudyn vector types, try to create them or use lists
                        try:
                            # First try to import and create the actual exudyn type
                            import exudyn as exu
                            if hasattr(exu, type_name):
                                vector_class = getattr(exu, type_name)
                                exudyn_state[key] = vector_class(data)
                            else:
                                # Fallback to numpy array or list
                                try:
                                    import numpy as np
                                    exudyn_state[key] = np.array(data, dtype='float64')
                                except:
                                    exudyn_state[key] = [float(x) for x in data]
                        except:
                            # Final fallback to list
                            exudyn_state[key] = [float(x) for x in data]
                    
                    else:
                        # For other special types, try list conversion
                        try:
                            if all(isinstance(x, (int, float)) for x in data):
                                exudyn_state[key] = [float(x) for x in data]
                            else:
                                exudyn_state[key] = data
                        except:
                            exudyn_state[key] = data
                
                elif isinstance(value, list):
                    # Handle plain lists (legacy format)
                    try:
                        if all(isinstance(x, (int, float)) for x in value):
                            exudyn_state[key] = [float(x) for x in value]
                        else:
                            exudyn_state[key] = value
                    except:
                        exudyn_state[key] = value
                
                else:
                    # Keep basic types as-is
                    exudyn_state[key] = value
                    
            except Exception as e:
                debugLog(f"‚ö†Ô∏è Could not deserialize view state key '{key}': {e}", origin="MainWindow")
                # Keep original value if conversion fails
                exudyn_state[key] = value
        
        return exudyn_state
    
    def _createSimplifiedViewState(self, state):
        """Create a simplified view state with only basic numeric values that exudyn can handle."""
        if not isinstance(state, dict):
            return {}
        
        simplified_state = {}
        
        # List of essential view state keys that are typically safe
        safe_keys = [
            'centerPoint', 'maxSceneSize', 'zoom', 'currentWindowSize',
            'rotationMatrix', 'openGL'
        ]
        
        for key, value in state.items():
            try:
                # Only include keys that are likely to be safe
                if any(safe_key in key.lower() for safe_key in ['center', 'zoom', 'size', 'matrix', 'opengl']):
                    
                    if isinstance(value, (int, float, bool)):
                        # Basic types are safe
                        simplified_state[key] = value
                    
                    elif isinstance(value, str):
                        # Try to convert string values
                        try:
                            # Handle numeric strings
                            if value.replace('.', '').replace('-', '').replace('+', '').replace('e', '').replace('E', '').isdigit():
                                if '.' in value or 'e' in value.lower():
                                    simplified_state[key] = float(value)
                                else:
                                    simplified_state[key] = int(value)
                            # Handle boolean strings
                            elif value.lower() in ('true', 'false'):
                                simplified_state[key] = value.lower() == 'true'
                            # Handle list-like strings
                            elif value.startswith('[') and value.endswith(']'):
                                import ast
                                parsed_list = ast.literal_eval(value)
                                if isinstance(parsed_list, list) and all(isinstance(x, (int, float)) for x in parsed_list):
                                    simplified_state[key] = [float(x) for x in parsed_list]
                        except:
                            pass  # Skip if conversion fails
                    
                    elif isinstance(value, (list, tuple)):
                        # Convert lists/tuples to plain Python lists with float values
                        try:
                            if all(isinstance(x, (int, float)) for x in value):
                                simplified_state[key] = [float(x) for x in value]
                        except:
                            pass  # Skip if conversion fails
                    
                    elif isinstance(value, dict) and '__data__' in value:
                        # Handle our enhanced format
                        try:
                            data = value['__data__']
                            if all(isinstance(x, (int, float)) for x in data):
                                simplified_state[key] = [float(x) for x in data]
                        except:
                            pass  # Skip if conversion fails
                    
                    # Also try to handle numpy arrays if present
                    elif hasattr(value, 'tolist'):
                        try:
                            simplified_state[key] = value.tolist()
                        except:
                            pass
                            
            except:
                pass  # Skip any problematic keys
        
        debugLog(f"üìã Created simplified view state with {len(simplified_state)} safe keys: {list(simplified_state.keys())}", origin="MainWindow")
        return simplified_state
    
    def _isRendererReady(self):
        """Check if the renderer is ready to accept state changes."""
        try:
            # Check basic renderer existence
            if not (hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer')):
                debugLog("‚ùå Renderer readiness: SC.renderer not available", origin="MainWindow")
                return False
            
            # Check if solution viewer is active
            if hasattr(self, 'solution_viewer') and self.solution_viewer:
                if hasattr(self.solution_viewer, 'renderer_active'):
                    if not self.solution_viewer.renderer_active:
                        debugLog("‚ùå Renderer readiness: solution_viewer not active", origin="MainWindow")
                        return False
                
                # Additional checks for renderer state
                if hasattr(self.solution_viewer, 'isRendererActive'):
                    if not self.solution_viewer.isRendererActive():
                        debugLog("‚ùå Renderer readiness: isRendererActive() returned False", origin="MainWindow")
                        return False
            
            # Try a simple renderer operation to test readiness
            try:
                # Test if we can get current state (indicates renderer is responsive)
                current_state = self.SC.renderer.GetState()
                if current_state is None:
                    debugLog("‚ùå Renderer readiness: GetState() returned None", origin="MainWindow")
                    return False
                debugLog("‚úÖ Renderer readiness: GetState() test passed", origin="MainWindow")
                
                # Additional test: try to set the same state back (more thorough test)
                try:
                    self.SC.renderer.SetState(current_state)
                    debugLog("‚úÖ Renderer readiness: SetState() test passed", origin="MainWindow")
                except Exception as e:
                    debugLog(f"‚ùå Renderer readiness: SetState() test failed: {e}", origin="MainWindow")
                    return False
                    
            except Exception as e:
                debugLog(f"‚ùå Renderer readiness: GetState() test failed: {e}", origin="MainWindow")
                return False
            
            debugLog("‚úÖ Renderer is ready for state restoration", origin="MainWindow")
            return True
            
        except Exception as e:
            debugLog(f"‚ùå Error checking renderer readiness: {e}", origin="MainWindow")
            return False
 
    def setupRibbonInterface(self):
        """Setup Microsoft Office-style ribbon interface with Data/Model/Simulation tabs."""
        # Initialize the structure first
        self.structure = {}
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main vertical layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(3)
        
        # Create ribbon-style tab widget
        self.ribbonTabs = QTabWidget()
        self.ribbonTabs.setMaximumHeight(150)  # Increased height for ribbon style
        self.ribbonTabs.setMinimumHeight(150)  # Ensure minimum height
        self.ribbonTabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #c0c0c0;
                background-color: #f0f0f0;
                padding-top: 5px;
            }
            QTabWidget::tab-bar {
                alignment: left;
            }
            QTabBar::tab {
                background-color: #e0e0e0;
                border: 1px solid #c0c0c0;
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
            }
            QTabBar::tab:selected {
                background-color: #f0f0f0;
                border-bottom-color: #f0f0f0;
            }
            QTabBar::tab:hover {
                background-color: #e8e8e8;
            }
        """)
          # Create the four main tabs
        self.setupDataRibbonTab()
        self.setupModelRibbonTab() 
        self.setupAddRibbonTab()
        self.ribbonTabs.currentChanged.connect(self.onRibbonTabChanged)
        self.setupAddLegacyRibbonTab()
        self.ribbonTabs.currentChanged.connect(self.onRibbonTabChanged)
        self.setupSimulationRibbonTab()
        self.setupGraphicsRibbonTab()
        self.setupAnalyseRibbonTab()
        

        main_layout.addWidget(self.ribbonTabs)
        # Hide the Graphics tab by default (Qt 5.15+)
        for i in range(self.ribbonTabs.count()):
            tab_text = self.ribbonTabs.tabText(i)
            if "Graphics" in tab_text:
                self.ribbonTabs.setTabVisible(i, False)  # Only works in Qt 5.15+
                break

          # Create main content area with splitters
        content_splitter = QSplitter(Qt.Horizontal)
        content_splitter.setChildrenCollapsible(False)  # Prevent panels from collapsing
        
        # Left panel: Model Structure and Variables
        left_panel = self.createRibbonLeftPanel()
        # Remove or reduce minimum width for left panel
        # left_panel.setMinimumWidth(280)  # Comment out or set to a smaller value
        left_panel.setMinimumWidth(100)  # Allow more flexible resizing
        left_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        
        # Right panel: Visualization area
        right_panel = self.createRibbonRightPanel()
        right_panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        content_splitter.addWidget(left_panel)
        content_splitter.addWidget(right_panel)
        
        # Set proportional sizes based on screen size instead of fixed pixels
        # Left panel gets 20% of width, right panel gets 80%
        content_splitter.setStretchFactor(0, 1)  # Left panel stretch factor
        content_splitter.setStretchFactor(1, 4)  # Right panel stretch factor (4:1 ratio)
        
        main_layout.addWidget(content_splitter)          # Initialize the system
        self.buildSystemAndShowAndRefreshTree()
          # Connect the Jupyter console to the kernel after everything is set up
        self.connectConsoleToKernel()
        
        # Note: startRendererRefresh() will be called automatically when renderer starts
        # via the solution_viewer.rendererStarted signal connection

    def onRibbonTabChanged(self, index):
        tab_text = self.ribbonTabs.tabText(index)
        if "Graphics" in tab_text:
            self.structureTree.hide()
            self.graphicsListWidget.show()
            self.structureLabel.setText("üñºÔ∏è Graphics Structure")  
        else:
            self.graphicsListWidget.hide()
            self.structureTree.show()
            self.structureLabel.setText("üèóÔ∏è Model Structure")   

    def setupGraphicsRibbonTab(self):
        """Setup the Graphics tab with Sketch/Profile and Graphics Constructors (horizontal, similar to Model tab)."""
        from guiForms.addGraphicsDialog import AddGraphicsDialog

        graphics_widget = QWidget()
        layout = QHBoxLayout(graphics_widget)
        layout.setContentsMargins(10, 15, 10, 10)
        layout.setSpacing(15)

        # --- Sketch/Profile group ---
        sketch_group = QGroupBox("‚úèÔ∏è Sketch / Profile")
        sketch_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 5px;
                margin-top: 1ex;
                padding-top: 5px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        sketch_layout = QHBoxLayout(sketch_group)
        sketch_layout.setSpacing(15)
        
        sketch_btn = QPushButton("Sketch")
        sketch_btn.setMinimumHeight(35)
        profile_btn = QPushButton("Profile")
        profile_btn.setMinimumHeight(35)
        sketch_layout.addWidget(sketch_btn)
        sketch_layout.addWidget(profile_btn)
        sketch_group.setLayout(sketch_layout)
        layout.addWidget(sketch_group)


        # --- Graphics Constructors group ---
        constructors_group = QGroupBox("üß© Graphics Constructors")
        constructors_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        constructors_layout = QHBoxLayout(constructors_group)
        constructors_layout.setSpacing(15)
        constructors_layout.setContentsMargins(10, 15, 10, 10)

        # Add Graphics... button (opens dialog)
        add_graphics_btn = QPushButton("Add Graphics...")
        add_graphics_btn.setMinimumHeight(35)
        add_graphics_btn.clicked.connect(self.openAddGraphicsDialog)
        constructors_layout.addWidget(add_graphics_btn)

        constructors_group.setLayout(constructors_layout)
        layout.addWidget(constructors_group)


        # --- Edit Components group (for graphics) ---
        edit_group = QGroupBox("‚úèÔ∏è Edit Components")
        edit_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
                background-color: rgba(76, 175, 80, 0.05);
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                color: #4CAF50;
                font-size: 12px;
            }
        """)
        edit_layout = QHBoxLayout(edit_group)
        edit_layout.setSpacing(15)
        edit_layout.setContentsMargins(10, 15, 10, 10)

        edit_selected_btn = QPushButton("‚úèÔ∏è Edit Selected")
        edit_selected_btn.setMinimumHeight(35)
        edit_selected_btn.clicked.connect(self.editSelectedGraphicsItem)
        edit_layout.addWidget(edit_selected_btn)

        remove_selected_btn = QPushButton("üóëÔ∏è Remove Selected")
        remove_selected_btn.setMinimumHeight(35)
        remove_selected_btn.clicked.connect(self.removeSelectedGraphicsItem)
        edit_layout.addWidget(remove_selected_btn)

        undo_btn = QPushButton("‚Ü∂ Undo Last")
        undo_btn.setMinimumHeight(35)
        undo_btn.clicked.connect(self.undoLastGraphicsAction)
        edit_layout.addWidget(undo_btn)
        layout.addWidget(edit_group)

        # --- Accept/Cancel Graphics group ---
        accept_group = QGroupBox("‚úÖ Accept/Cancel Graphics")
        accept_group.setStyleSheet("""
            QGroupBox {
            font-weight: bold;
            border: 2px solid #cccccc;
            border-radius: 5px;
            margin-top: 1ex;
            padding-top: 5px;
            }
            QGroupBox::title {
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 5px 0 5px;
            }
        """)
        accept_layout = QHBoxLayout(accept_group)
        accept_layout.setSpacing(15)
        # --- Graphics Edit Mode Buttons ---
        self.acceptGraphicsBtn = QPushButton("‚úÖ Accept Graphics Edit")
        self.cancelGraphicsBtn = QPushButton("‚ùå Cancel Graphics Edit")
        self.acceptGraphicsBtn.setMinimumHeight(35)
        self.cancelGraphicsBtn.setMinimumHeight(35)
        self.acceptGraphicsBtn.setVisible(False)
        self.cancelGraphicsBtn.setVisible(False)

        self.acceptGraphicsBtn.clicked.connect(self.finishGraphicsEdit)
        self.cancelGraphicsBtn.clicked.connect(self.cancelGraphicsEdit)

        accept_layout.addWidget(self.acceptGraphicsBtn)
        accept_layout.addWidget(self.cancelGraphicsBtn)
        accept_group.setLayout(accept_layout)
        
        layout.addWidget(accept_group)

        self.addGraphicsBtn = add_graphics_btn
        self.editGraphicsBtn = edit_selected_btn
        self.removeGraphicsBtn = remove_selected_btn
        
        layout.addStretch()
        self.ribbonTabs.addTab(graphics_widget, "üé® Graphics")

    def startGraphicsEdit(self, initialGraphicsList):
        self.enterGraphicsEditMode(initialGraphicsList)
        self.acceptGraphicsBtn.setVisible(True)
        self.cancelGraphicsBtn.setVisible(True)

    def finishGraphicsEdit(self):
        graphicsList = self.acceptGraphicsEdit()
        self.acceptGraphicsBtn.setVisible(False)
        self.cancelGraphicsBtn.setVisible(False)
        self.showAllTabs()
        # Show the form/dialog again
        if hasattr(self, "_autoGeneratedForm") and self._autoGeneratedForm is not None:
            self._autoGeneratedForm.show()
            self._autoGeneratedForm = None
  

    def cancelGraphicsEdit(self):
        self.exitGraphicsEditMode()
        self.acceptGraphicsBtn.setVisible(False)
        self.cancelGraphicsBtn.setVisible(False)
        self.showAllTabs()
        # Show the form/dialog again
        if hasattr(self, "_autoGeneratedForm") and self._autoGeneratedForm is not None:
            self._autoGeneratedForm.show()
            self._autoGeneratedForm = None
        

    def editSelectedGraphicsItem(self):
        """Edit the currently selected graphics item in the temporary list (non-blocking)."""
        selected_items = self.graphicsListWidget.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Please select a graphics item to edit.")
            return

        idx = self.graphicsListWidget.row(selected_items[0])
        graphics_list = getattr(self, '_temporaryGraphicsList', [])
        if idx < 0 or idx >= len(graphics_list):
            QMessageBox.warning(self, "Edit Error", "Invalid selection.")
            return

        graphics_item = graphics_list[idx]
        constructor_name = graphics_item.get('name', None)
        args = graphics_item.get('args', None)
        if not constructor_name or args is None:
            QMessageBox.warning(self, "Edit Error", "Cannot edit this graphics item (missing info).")
            return

        from guiForms.constructorArgsDialog import ConstructorArgsDialog
        argsDlg = ConstructorArgsDialog(constructorName=constructor_name, argsString=str(args), parent=self)
        argsDlg._editIndex = idx
        argsDlg.SC = self.SC
        argsDlg.mbs = self.mbs
        argsDlg.previewCurrentGraphics()

        # Make dialog non-modal and always on top
        argsDlg.setWindowFlags(argsDlg.windowFlags() | Qt.WindowStaysOnTopHint | Qt.Tool)
        argsDlg.show()

        def on_args_accepted():
            new_name = argsDlg.getName()
            new_args = argsDlg.getArgs()
            graphics_list[idx] = {'name': new_name, 'args': new_args}
            self._temporaryGraphicsList = graphics_list
            self.updateTemporaryGraphicsListWidget()
            
            argsDlg.deleteLater()

        # Connect the OK button to our handler
        if hasattr(argsDlg, 'buttonBox'):
            argsDlg.buttonBox.accepted.connect(on_args_accepted)



    def enterGraphicsEditMode(self, initialGraphicsList=None):
        """Save current project, create a new model, and enter graphics edit mode."""
        from PyQt5.QtWidgets import QApplication, QMessageBox
        # Process all pending events
        QApplication.processEvents()
        # Check for open modal dialogs
        if QApplication.activeModalWidget():
            QMessageBox.warning(self, "Action Blocked", "Please close all dialogs before editing graphics.")
            return
        self._graphicsEditTempFile = os.path.join(tempfile.gettempdir(), "__exudyn_graphics_edit_temp.exu")
        self.saveProject2(self._graphicsEditTempFile)
        self.newModel()
        if initialGraphicsList is not None:
            self._temporaryGraphicsList = list(initialGraphicsList)
            self.updateTemporaryGraphicsListWidget()
            self._updateGraphicsPreview()
        self._inGraphicsEditMode = True
        # Optionally: Disable unrelated UI here

    def acceptGraphicsEdit(self):
        """Accept graphics edit, return the graphics list, and restore the original model."""
        graphicsList = getattr(self, "_temporaryGraphicsList", [])
        self.exitGraphicsEditMode()
        self.graphicsEditAccepted.emit(graphicsList)
        return graphicsList

    def exitGraphicsEditMode(self):
        """Restore the original model from the temp file and clean up."""
        from PyQt5.QtWidgets import QApplication, QMessageBox
        # Process all pending events
        QApplication.processEvents()
        # Check for open modal dialogs
        if QApplication.activeModalWidget():
            QMessageBox.warning(self, "Action Blocked", "Please close all dialogs before restoring the model.")
            return
        if hasattr(self, "_graphicsEditTempFile") and os.path.exists(self._graphicsEditTempFile):
            self.newModel()
            self.loadProject2(self._graphicsEditTempFile)
            os.remove(self._graphicsEditTempFile)
        self._inGraphicsEditMode = False


    def _updateGraphicsPreview(self):
        """Update the preview with the current temporary graphics list."""
        try:
            import exudyn.graphics as gfx
            graphicsDataList = []
            
            # Convert all entries to graphics objects
            for entry in self._temporaryGraphicsList:
                try:
                    graphicsDataList.append(
                        eval(f"gfx.{entry['name']}({entry['args']})", {"gfx": gfx})
                    )
                except Exception as e:
                    debugLog(f"Preview: failed to evaluate entry: {e}")

            # Reset and preview all graphics
            self.mbs.Reset()
            self.mbs.CreateGround(referencePosition=[0,0,0], graphicsDataList=graphicsDataList)
            self.mbs.Assemble()

        except Exception as e:
            QMessageBox.critical(self, "Preview Error", f"Failed to create preview:\n{str(e)}")

    def removeSelectedGraphicsItem(self):
        """Remove the currently selected graphics item from the temporary list."""
        selected_items = self.graphicsListWidget.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Please select a graphics item to remove.")
            return

        idx = self.graphicsListWidget.row(selected_items[0])
        if hasattr(self, '_temporaryGraphicsList') and 0 <= idx < len(self._temporaryGraphicsList):
            del self._temporaryGraphicsList[idx]
            self.updateTemporaryGraphicsListWidget()
            self._updateGraphicsPreview()
            
    def undoLastGraphicsAction(self):
        """Undo the last graphics action (remove last item from the temporary list)."""
        if not hasattr(self, '_temporaryGraphicsList') or not self._temporaryGraphicsList:
            QMessageBox.information(self, "Undo", "No graphics items to undo.")
            return
        self._temporaryGraphicsList.pop()
        self.updateTemporaryGraphicsListWidget()
        self._updateGraphicsPreview()

    def updateGraphicsListWidget(self):
        """Refresh the graphics list widget to match graphicsDataList."""
        self.graphicsListWidget.clear()
        if self.graphicsDataList:
            for g in self.graphicsDataList:
                name = getattr(g, '_constructorName', str(type(g)))
                self.graphicsListWidget.addItem(name)
        else:
            self.graphicsListWidget.addItem("No graphics yet")

    def setTemporaryGraphicsList(self, graphicsList):
        """Show and edit the graphics list for the current item (not the whole model)."""
        self._temporaryGraphicsList = list(graphicsList) if graphicsList else []
        self.updateTemporaryGraphicsListWidget()

    def updateTemporaryGraphicsListWidget(self):
        """Update the graphicsListWidget with the temporary graphics list."""
        self.graphicsListWidget.clear()
        if self._temporaryGraphicsList:
            for entry in self._temporaryGraphicsList:
                if isinstance(entry, dict) and 'name' in entry and 'args' in entry:
                    callStr = f"{entry['name'].removeprefix('GraphicsData')}({entry['args']})"
                else:
                    callStr = str(entry)
                self.graphicsListWidget.addItem(callStr)
        else:
            self.graphicsListWidget.addItem("No graphics yet")

    def getTemporaryGraphicsList(self):
        """Return the currently edited graphics list."""
        return list(self._temporaryGraphicsList)


    def openAddGraphicsDialog(self):
        """Open the Add Graphics Constructor dialog and handle selection (non-blocking)."""
        from guiForms.addGraphicsDialog import AddGraphicsDialog
        from guiForms.constructorArgsDialog import ConstructorArgsDialog
        from PyQt5.QtCore import Qt


        # Ensure renderer is docked/visible before opening dialog
        self.initRendererWidget()

        dlg = AddGraphicsDialog(self)
        dlg.setWindowFlags(dlg.windowFlags() | Qt.WindowStaysOnTopHint | Qt.Tool)
        dlg.show()

        def on_constructor_selected():
            selected = dlg.getSelectedConstructor()
            if selected:
                argsDlg = ConstructorArgsDialog(constructorName=selected, parent=self)
                argsDlg.mbs = self.mbs
                argsDlg.SC = self.SC  # Add this line
                argsDlg.setWindowFlags(argsDlg.windowFlags() | Qt.WindowStaysOnTopHint | Qt.Tool)
                argsDlg.show()

                def on_args_accepted():
                    name = argsDlg.getName()
                    args = argsDlg.getArgs()
                    entry = {'name': name, 'args': args}
                    if not hasattr(self, '_temporaryGraphicsList'):
                        self._temporaryGraphicsList = []
                    self._temporaryGraphicsList.append(entry)
                    self.updateTemporaryGraphicsListWidget()
                    #self.previewCurrentGraphics()
                    # Ensure renderer is docked/visible after adding
                    self.initRendererWidget()

                argsDlg.buttonBox.accepted.connect(on_args_accepted)

        dlg.accepted.connect(on_constructor_selected)

    def showAnalyseAndGraphicsTabsOnly(self):
        # Store the current tab index before hiding tabs
        self._lastActiveTabIndex = self.ribbonTabs.currentIndex()
        graphics_index = None
        for i in range(self.ribbonTabs.count()):
            tab_text = self.ribbonTabs.tabText(i).lower()
            if "graphics" in tab_text:
                self.ribbonTabs.setTabVisible(i, True)
                graphics_index = i  # Remember graphics tab index
            elif "analyse" in tab_text:
                self.ribbonTabs.setTabVisible(i, True)
            else:
                self.ribbonTabs.setTabVisible(i, False)
        # --- Switch left panel to Graphics Structure ---
        self.structureTree.hide()
        self.graphicsListWidget.show()
        self.structureLabel.setText("üñºÔ∏è Graphics Structure")
        # Activate the Graphics tab
        if graphics_index is not None:
            self.ribbonTabs.setCurrentIndex(graphics_index)

    from guiForms.graphicsDataDialog import GraphicsDataDialog

    def showAllTabs(self):
        for i in range(self.ribbonTabs.count()):
            tab_text = self.ribbonTabs.tabText(i)
            if "Graphics" in tab_text:
                self.ribbonTabs.setTabVisible(i, False)  # Hide Graphics tab again
            else:
                self.ribbonTabs.setTabVisible(i, True)
        # Restore left panel to Model Structure
        self.graphicsListWidget.hide()
        self.structureTree.show()
        self.structureLabel.setText("üèóÔ∏è Model Structure")
        # Restore the last active tab if it exists, is visible, and is not Graphics
        if hasattr(self, "_lastActiveTabIndex"):
            idx = self._lastActiveTabIndex
            tab_text = self.ribbonTabs.tabText(idx) if 0 <= idx < self.ribbonTabs.count() else ""
            if (
                0 <= idx < self.ribbonTabs.count()
                and self.ribbonTabs.isTabVisible(idx)
                and "Graphics" not in tab_text
            ):
                self.ribbonTabs.setCurrentIndex(idx)
            else:
                # Fallback: activate the first visible (non-Graphics) tab
                for i in range(self.ribbonTabs.count()):
                    tab_text = self.ribbonTabs.tabText(i)
                    if self.ribbonTabs.isTabVisible(i) and "Graphics" not in tab_text:
                        self.ribbonTabs.setCurrentIndex(i)
                        break



    def setupAnalyseRibbonTab(self):
        """Setup the Analyse tab with measurement tools."""
        analyse_widget = QWidget()
        layout = QHBoxLayout(analyse_widget)
        layout.setContentsMargins(10, 5, 10, 5)
        layout.setSpacing(15)


        # Measurement group
        measure_group = QGroupBox("üìè Measurement")
        measure_group.setMinimumWidth(250)  # Set minimum width
        measure_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        measure_layout = QHBoxLayout(measure_group)
        measure_layout.setSpacing(15)

        # Measurement dropdown button
        measure_btn = QToolButton()
        measure_btn.setText("Measure")
        measure_btn.setMinimumWidth(200)
        measure_btn.setMinimumHeight(35)
        measure_btn.setPopupMode(QToolButton.MenuButtonPopup)
        measure_menu = QMenu(measure_btn)
        measure_menu.addAction("Summary")
        measure_menu.addAction("Length")
        measure_menu.addAction("Distance")
        measure_menu.addAction("Angle")
        measure_menu.addAction("Diameter")
        measure_menu.addAction("Area")
        measure_menu.addAction("Volume")
        measure_menu.addAction("Transform")
        measure_btn.setMenu(measure_menu)
        measure_layout.addWidget(measure_btn)

        measure_group.setLayout(measure_layout)
        layout.addWidget(measure_group)
        layout.addStretch()

        self.ribbonTabs.addTab(analyse_widget, "üßÆ Analyse")

    def setupDataRibbonTab(self):
        """Setup the Data tab with file operations."""
        data_widget = QWidget()
        layout = QHBoxLayout(data_widget)
        layout.setContentsMargins(10, 5, 10, 5)
        
        # File Operations Group
        file_group = QGroupBox("üìÅ File Operations")
        file_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        file_layout = QHBoxLayout(file_group)  # Changed from QGridLayout to QHBoxLayout
        file_layout.setSpacing(15)  # Add spacing between buttons
          # Load/Save buttons
        new_project_btn = QPushButton("üÜï New Project")
        new_project_btn.clicked.connect(lambda: self.newModel(confirm_save=True))
        new_project_btn.setMinimumHeight(35)
        file_layout.addWidget(new_project_btn)
        
        # load_model_btn = QPushButton("üìÇ Load Model")
        # load_model_btn.clicked.connect(self.loadModel)
        # load_model_btn.setMinimumHeight(35)
        # file_layout.addWidget(load_model_btn)
        
        # save_model_btn = QPushButton("üíæ Save Model")  
        # save_model_btn.clicked.connect(self.saveModel)
        # save_model_btn.setMinimumHeight(35)
        # file_layout.addWidget(save_model_btn)
        
        load_project_btn = QPushButton("üìÅ Load Project")
        load_project_btn.clicked.connect(self.loadProject)
        load_project_btn.setMinimumHeight(35)
        file_layout.addWidget(load_project_btn)        
        
        save_project_btn = QPushButton("üíº Save Project")
        save_project_btn.clicked.connect(self.saveProject)
        save_project_btn.setMinimumHeight(35)
        file_layout.addWidget(save_project_btn)
        
        exit_btn = QPushButton("üö™ Exit")
        exit_btn.clicked.connect(self.exitApplication)
        exit_btn.setMinimumHeight(35)
        exit_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
        """)
        file_layout.addWidget(exit_btn)
        
        layout.addWidget(file_group)
        
        # Add stretch to push everything to the left
        layout.addStretch()
        
        self.ribbonTabs.addTab(data_widget, "üìä Data")

    def setupModelRibbonTab(self):
        """Setup the Model tab with editing operations."""
        model_widget = QWidget()
        layout = QHBoxLayout(model_widget)
        layout.setContentsMargins(10, 5, 10, 5)
        
        # Add Components Group
        add_group = QGroupBox("‚ûï Add Components")
        add_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        add_layout = QHBoxLayout(add_group)  # Changed from QGridLayout to QHBoxLayout
        add_layout.setSpacing(15)  # Add spacing between buttons
        
        add_create_btn = QPushButton("üöÄ Add (Create)")
        add_create_btn.clicked.connect(self.addCreateItem)
        add_create_btn.setMinimumHeight(35)
        add_layout.addWidget(add_create_btn)
        
        add_legacy_btn = QPushButton("üîß Add (Legacy)")
        add_legacy_btn.clicked.connect(self.addLegacyItem)
        add_legacy_btn.setMinimumHeight(35)
        add_layout.addWidget(add_legacy_btn)
        
        add_flexible_btn = QPushButton("üîó Add Flexible Body")
        add_flexible_btn.clicked.connect(self.addFlexibleBody)
        add_flexible_btn.setMinimumHeight(35)
        add_layout.addWidget(add_flexible_btn)
        
        layout.addWidget(add_group)
        
        # Edit Components Group
        edit_group = QGroupBox("‚úèÔ∏è Edit Components")
        edit_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        edit_layout = QHBoxLayout(edit_group)  # Changed from QGridLayout to QHBoxLayout
        edit_layout.setSpacing(15)  # Add spacing between buttons
        edit_layout.setContentsMargins(10, 5, 10, 5)
        
        edit_selected_btn = QPushButton("‚úèÔ∏è Edit Selected")
        edit_selected_btn.clicked.connect(self.editSelectedItem)
        edit_selected_btn.setMinimumHeight(35)
        edit_layout.addWidget(edit_selected_btn)
        
        remove_selected_btn = QPushButton("üóëÔ∏è Remove Selected")
        remove_selected_btn.clicked.connect(self.removeSelectedItem)
        remove_selected_btn.setMinimumHeight(35)
        edit_layout.addWidget(remove_selected_btn)
        
        undo_btn = QPushButton("‚Ü∂ Undo Last")
        undo_btn.clicked.connect(self.undoLast)
        undo_btn.setMinimumHeight(35)
        edit_layout.addWidget(undo_btn)
        
        layout.addWidget(edit_group)
        
        # Python Code Group
        python_group = QGroupBox("üêç Python Editor")
        python_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
                background-color: rgba(76, 175, 80, 0.05);
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                color: #4CAF50;
                font-size: 12px;
            }
        """)
        python_layout = QHBoxLayout(python_group)
        python_layout.setSpacing(15)
        python_layout.setContentsMargins(10, 5, 10, 5)
        
        # Python Snippet button
        snippet_btn = QPushButton("üìù Quick Snippet")
        snippet_btn.setMinimumHeight(35)

        snippet_btn.clicked.connect(self.openPythonSnippetDialog)
        python_layout.addWidget(snippet_btn)
        

        layout.addWidget(python_group)
        
        # Add stretch to push everything to the left
        layout.addStretch()
        
        self.ribbonTabs.addTab(model_widget, "üîß Model")

    def setupSimulationRibbonTab(self):
        """Setup the Simulation tab with simulation operations."""
        sim_widget = QWidget()
        layout = QHBoxLayout(sim_widget)
        layout.setContentsMargins(10, 5, 10, 5)
        
        # Simulation Group
        sim_group = QGroupBox("üöÄ Simulation & Output")
        sim_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 8px;
                margin-top: 1ex;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
                font-size: 12px;
            }
        """)
        sim_layout = QHBoxLayout(sim_group)  # Changed from QGridLayout to QHBoxLayout
        sim_layout.setSpacing(15)  # Add spacing between buttons        

        # Add simulation settings button
        settings_btn = QPushButton("‚öôÔ∏è Visualization Settings")
        settings_btn.clicked.connect(self.showVisualizationSettings)
        settings_btn.setMinimumHeight(35)
        settings_btn.setToolTip("Configure visualization parameters")
        sim_layout.addWidget(settings_btn)

        # Add simulation settings button
        settings_btn = QPushButton("‚öôÔ∏è Simulation Settings")
        settings_btn.clicked.connect(self.showSimulationSettings)
        settings_btn.setMinimumHeight(35)
        settings_btn.setToolTip("Configure simulation parameters and solver settings")
        sim_layout.addWidget(settings_btn)

        simulate_btn = QPushButton("‚ñ∂Ô∏è Simulate")
        simulate_btn.clicked.connect(self.simulateModel)
        simulate_btn.setMinimumHeight(35)
        sim_layout.addWidget(simulate_btn)
        
        generate_script_btn = QPushButton("üìú Generate Full Script")
        generate_script_btn.clicked.connect(self.generateScript)
        generate_script_btn.setMinimumHeight(35)
        sim_layout.addWidget(generate_script_btn)
        
        # Removed deprecated Start Renderer and Stop Renderer buttons - renderer is now integrated
          # üîß Add button to toggle between docked and undocked renderer modes
        self.docking_toggle_btn = QPushButton("ÔøΩ Docked")
        self.docking_toggle_btn.clicked.connect(self.toggleRendererDocking)
        self.docking_toggle_btn.setMinimumHeight(35)
        self.docking_toggle_btn.setCheckable(True)  # Make it a toggle button
        self.docking_toggle_btn.setChecked(False)  # Start in docked mode by default
        self.docking_toggle_btn.setStyleSheet("""
            QPushButton {
                background-color: #4b6b9a;
                color: white;
                border: 2px solid #3d5875;
                border-radius: 5px;
                font-weight: bold;
                padding: 2px 8px;
            }
            QPushButton:hover {
                background-color: #5a7fad;
            }
            QPushButton:checked {
                background-color: #2ecc71;
                border: 2px solid #27ae60;
            }
        """)
        self.docking_toggle_btn.setToolTip("Toggle between docked (embedded) and undocked (separate window) renderer modes")
        sim_layout.addWidget(self.docking_toggle_btn)
        
        layout.addWidget(sim_group)
        
        # Add stretch to push everything to the left
        layout.addStretch()
        
        self.ribbonTabs.addTab(sim_widget, "üöÄ Simulation")




    def setupAddLegacyRibbonTab(self):
        from guiForms.addItemDialog import CATEGORY_ICONS, CATEGORY_DESCRIPTIONS, CATEGORY_TO_TYPES
        from PyQt5.QtGui import QIcon
        from PyQt5.QtCore import QSize
        from PyQt5.QtWidgets import QGroupBox, QHBoxLayout, QVBoxLayout, QPushButton, QWidget
        import os

        add_widget = QWidget()
        main_layout = QHBoxLayout(add_widget)
        main_layout.setContentsMargins(10, 5, 10, 5)
        main_layout.setSpacing(15)

        # Define main legacy categories, grouping all Objects into one
        MAIN_LEGACY_CATEGORIES = [
            ("Nodes", ["Nodes"]),
            ("Objects", [
                "Objects (Body)",
                "Objects (SuperElement)",
                "Objects (FiniteElement)",
                "Objects (Joint)",
                "Objects (Connector)",
                "Objects (Constraint)",
                "Objects (Object)"
            ]),
            ("Markers", ["Markers"]),
            ("Loads", ["Loads"]),
            ("Sensors", ["Sensors"])
        ]

        # Emoji and color for each group, matching "+Create" style
        GROUP_EMOJIS = {
            "Nodes": "üèóÔ∏è",
            "Objects": "üîó",
            "Markers": "üéØ",
            "Loads": "‚ö°",
            "Sensors": "üì°"
        }
        GROUP_DESCRIPTIONS = {
            "Nodes": "Add legacy node types (e.g. Point, Rigid, etc.)",
            "Objects": "Add legacy object types (bodies, joints, connectors, etc.)",
            "Markers": "Add legacy marker types (position, body, etc.)",
            "Loads": "Add legacy loads (force, torque, etc.)",
            "Sensors": "Add legacy sensors (position, velocity, etc.)"
        }

        def open_legacy_category_dialog(category):
            from guiForms.addItemDialog import AddModelElementDialog
            from PyQt5.QtCore import QTimer
            dlg = AddModelElementDialog(
                parent=self,
                pdfBookmarks=self._pdfBookmarks,
                pdfPath=self._pdfPath
            )
            dlg._showTypes(category)
            # Guard to prevent multiple form openings
            if not hasattr(self, '_autoGeneratedFormOpenGuard'):
                self._autoGeneratedFormOpenGuard = False
            def handle_type_selected(typeName):
                if not self._autoGeneratedFormOpenGuard:
                    self._autoGeneratedFormOpenGuard = True
                    QTimer.singleShot(0, lambda: self.openCreateItemEditor(typeName))
                # Always disconnect after first use
                try:
                    dlg.typeSelected.disconnect(handle_type_selected)
                except Exception:
                    pass
            dlg.typeSelected.connect(handle_type_selected)
            dlg.exec_()
            # Reset guard after dialog closes
            self._autoGeneratedFormOpenGuard = False


        for group_name, category_list in MAIN_LEGACY_CATEGORIES:
            emoji = GROUP_EMOJIS.get(group_name, "")
            group_title = f"{emoji} {group_name}"
            group_box = QGroupBox(group_title)
            group_box.setStyleSheet("""
                QGroupBox {
                    font-weight: bold;
                    border: 2px solid #cccccc;
                    border-radius: 5px;
                    margin-top: 1ex;
                    padding-top: 15px;
                    padding-bottom: 5px;
                    background-color: #f0f0f0;
                }
                QGroupBox::title {
                
                    subcontrol-origin: margin;
                    left: 10px;
                    padding: 0 5px 0 5px;
                }
            """)

            # --- Container for group content with background ---
            container = QWidget()
            container.setStyleSheet("background-color: #f0f0f0; border: none;")
            group_layout = QHBoxLayout(container)
            # Standardize margins and spacing for perfect alignment
            group_layout.setContentsMargins(5, 10, 5, 5)
            group_layout.setSpacing(5)

            # For Objects, show a button for each subcategory
            if group_name == "Objects":
                for cat in category_list:
                    icon_filename = CATEGORY_ICONS.get(cat)
                    icon_path = None
                    if icon_filename:
                        icon_path = os.path.join(os.path.dirname(__file__), "..", "design", "legacyItems", icon_filename)
                        if not os.path.exists(icon_path):
                            icon_path = None
                    btn = QPushButton()
                    btn.setMinimumHeight(50)
                    btn.setMaximumHeight(50)
                    btn.setMinimumWidth(50)
                    btn.setMaximumWidth(50)
                    btn.setText("")
                    btn_icon = QIcon(icon_path) if icon_path else None
                    if btn_icon:
                        btn.setIcon(btn_icon)
                        btn.setIconSize(QSize(36, 36))
                    # Rich tooltip
                    desc = CATEGORY_DESCRIPTIONS.get(cat, cat)
                    tooltip = f"""
                    <div style='max-width: 300px;'>
                        <h3 style='margin-bottom: 5px; color: #2c3e50;'>{cat}</h3>
                        <p style='margin: 0; line-height: 1.4; color: #34495e;'>
                            {desc}
                        </p>
                        <hr style='margin: 8px 0; border: none; border-top: 1px solid #bdc3c7;'>
                        <small style='color: #7f8c8d;'>Click to add {cat} (legacy) to your model</small>
                    </div>
                    """
                    btn.setToolTip(tooltip)
                    btn.clicked.connect(lambda checked, c=cat: open_legacy_category_dialog(c))
                    btn.setStyleSheet("""
                        QPushButton {
                            border: 1px solid #bdc3c7;
                            border-radius: 6px;
                            background-color: #ecf0f1;
                            padding: 8px;
                        }
                        QPushButton:hover {
                            background-color: #d5dbdb;
                            border: 2px solid #3498db;
                        }
                        QPushButton:pressed {
                            background-color: #bdc3c7;
                        }
                    """)
                    group_layout.addWidget(btn)
            else:
                # For other groups, just one button as before
                cat = category_list[0]
                icon_filename = CATEGORY_ICONS.get(cat)
                icon_path = None
                if icon_filename:
                    icon_path = os.path.join(os.path.dirname(__file__), "..", "design", "legacyItems", icon_filename)
                    if not os.path.exists(icon_path):
                        icon_path = None
                btn = QPushButton()
                btn.setMinimumHeight(50)
                btn.setMaximumHeight(50)
                btn.setMinimumWidth(50)
                btn.setMaximumWidth(50)
                btn.setText("")
                btn_icon = QIcon(icon_path) if icon_path else None
                if btn_icon:
                    btn.setIcon(btn_icon)
                    btn.setIconSize(QSize(36, 36))
                # Rich tooltip
                desc = CATEGORY_DESCRIPTIONS.get(cat, cat)
                tooltip = f"""
                <div style='max-width: 300px;'>
                    <h3 style='margin-bottom: 5px; color: #2c3e50;'>{cat}</h3>
                    <p style='margin: 0; line-height: 1.4; color: #34495e;'>
                        {desc}
                    </p>
                    <hr style='margin: 8px 0; border: none; border-top: 1px solid #bdc3c7;'>
                    <small style='color: #7f8c8d;'>Click to add {cat} (legacy) to your model</small>
                </div>
                """
                btn.setToolTip(tooltip)
                
                btn.clicked.connect(lambda checked, c=cat: open_legacy_category_dialog(c))
                btn.setStyleSheet("""
                    QPushButton {
                        border: 1px solid #bdc3c7;
                        border-radius: 6px;
                        background-color: #ecf0f1;
                        padding: 8px;
                    }
                    QPushButton:hover {
                        background-color: #d5dbdb;
                        border: 2px solid #3498db;
                    }
                    QPushButton:pressed {
                        background-color: #bdc3c7;
                    }
                """)
                group_layout.addWidget(btn)
            group_layout.addStretch()
            # Add the container to the group box
            group_box.setLayout(QHBoxLayout())
            group_box.layout().setContentsMargins(0, 0, 0, 0)
            group_box.layout().setSpacing(0)
            group_box.layout().addWidget(container)
            main_layout.addWidget(group_box)

        main_layout.addStretch()
        self.ribbonTabs.addTab(add_widget, "‚ûï Legacy")





    def setupAddRibbonTab(self):
        """Setup the Add (Create) tab with organized CREATE items for quick access."""
        add_widget = QWidget()
        main_layout = QHBoxLayout(add_widget)
        main_layout.setContentsMargins(10, 5, 10, 5)  # Reduced top/bottom margins
        main_layout.setSpacing(15)
        
        # Define categories and their items with icon mappings
        categories = {
            "Bodies": {
                "items": ["CreateGround", "CreateMassPoint", "CreateRigidBody"],
                "icon": "üèóÔ∏è",
                "descriptions": {
                    "CreateGround": "Creates a fixed ground body that cannot move. Use as a reference for constraints and connections.",
                    "CreateMassPoint": "Creates a point mass with translational degrees of freedom. Ideal for simple particles or concentrated masses.",
                    "CreateRigidBody": "Creates a rigid body with full 6-DOF motion (3 translation + 3 rotation). The fundamental building block for multibody systems."
                }
            },
            "Connectors": {
                "items": ["CreateDistanceConstraint", "CreateSpringDamper", "CreateCartesianSpringDamper", "CreateRigidBodySpringDamper", "CreateCoordinateConstraint", "CreateTorsionalSpringDamper"],
                "icon": "üîó",
                "descriptions": {
                    "CreateDistanceConstraint": "Constrains the distance between two points to be constant. Creates a rigid connection.",
                    "CreateSpringDamper": "Creates a spring-damper element between two points. Provides force proportional to distance and velocity.",
                    "CreateCartesianSpringDamper": "Creates a 3D Cartesian spring-damper with separate stiffness and damping in X, Y, Z directions.",
                    "CreateRigidBodySpringDamper": "Creates a 6-DOF spring-damper between rigid bodies with translational and rotational components.",
                    "CreateCoordinateConstraint": "Constrains a coordinate (position, velocity, or acceleration) to follow a prescribed motion or value.",
                    "CreateTorsionalSpringDamper": "Creates a torsional spring-damper element providing rotational stiffness and damping between bodies."
                }
            },
            "Joints": {
                "items": ["CreatePrismaticJoint", "CreateRevoluteJoint", "CreateSphericalJoint", "CreateGenericJoint", "CreateRollingDisc", "CreateRollingDiscPenalty"],
                "icon": "‚öôÔ∏è",
                "descriptions": {
                    "CreatePrismaticJoint": "Creates a prismatic (sliding) joint allowing translation along one axis while constraining rotation.",
                    "CreateRevoluteJoint": "Creates a revolute (hinge) joint allowing rotation about one axis while constraining translation.",
                    "CreateSphericalJoint": "Creates a spherical (ball) joint allowing 3-DOF rotation while constraining translation.",
                    "CreateGenericJoint": "Creates a generic joint with customizable constraints for complex kinematic relationships.",
                    "CreateRollingDisc": "Creates a rolling disc constraint that enforces no-slip rolling contact between a disc and surface.",
                    "CreateRollingDiscPenalty": "Creates a penalty-based rolling disc constraint with configurable contact stiffness and damping."
                }
            },
            "Loads": {
                "items": ["CreateForce", "CreateTorque"],
                "icon": "‚ö°",
                "descriptions": {
                    "CreateForce": "Applies a force vector to a point on a body. Can be constant, time-dependent, or user-defined.",
                    "CreateTorque": "Applies a torque (moment) vector to a rigid body. Used for rotational actuation and loading."
                }
            },
            "Special": {
                "items": ["CreateDistanceSensor", "CreateDistanceSensorGeometry", "CreateKinematicTree"],
                "icon": "üîç",
                "descriptions": {
                    "CreateDistanceSensor": "Creates a sensor to measure distance between two points during simulation.",
                    "CreateDistanceSensorGeometry": "Creates a geometric distance sensor for complex distance measurements between bodies.",
                    "CreateKinematicTree": "Creates a kinematic tree structure for efficient multi-body dynamics with tree topology."
                }
            },
            "Contact": {
                "items": ["CreateSphereTriangleContact", "CreateSphereQuadContact", "CreateSphereSphereContact"],
                "icon": "üîÑ",
                "descriptions": {
                    "CreateSphereTriangleContact": "Creates contact between a sphere and triangular mesh geometry with collision detection and response.",
                    "CreateSphereQuadContact": "Creates contact between a sphere and quadrilateral mesh geometry for surface contact modeling.",
                    "CreateSphereSphereContact": "Creates contact between two spheres with collision detection, penetration handling, and contact forces."
                }
            }
        }
        
        # Map item names to icon filenames
        icon_name_mapping = {
            "CreateGround": "Ground.png",
            "CreateMassPoint": "MassPoint.png", 
            "CreateRigidBody": "RigidBody.png",
            "CreateDistanceConstraint": "DistanceConstraint.png",
            "CreateSpringDamper": "SpringDamper.png",
            "CreateCartesianSpringDamper": "CartesianSpringDamper.png",
            "CreateRigidBodySpringDamper": "RigidBodySpringDamper.png",
            "CreateCoordinateConstraint": "CoordinateConstraint.png",
            "CreateTorsionalSpringDamper": "TorsionalSpringDamper.png",
            "CreatePrismaticJoint": "PrismaticJoint.png",
            "CreateRevoluteJoint": "RevoluteJoint.png",
            "CreateSphericalJoint": "SphericalJoint.png",
            "CreateGenericJoint": "GenericJoint.png",
            "CreateRollingDisc": "RollingDisc.png",
            "CreateRollingDiscPenalty": "RollingDiscPenalty.png",
            "CreateForce": "Force.png",
            "CreateTorque": "Torque.png",
            "CreateDistanceSensor": "DistanceSensor.png",
            "CreateDistanceSensorGeometry": "DistanceSensorGeometry.png",
            "CreateKinematicTree": "KinematicTree.png",
            "CreateSphereTriangleContact": "SphereTriangleContact.png",
            "CreateSphereQuadContact": "SphereQuadContact.png",
            "CreateSphereSphereContact": "SphereSphereContact.png"
        }
        
        # Create category groups
        for category_name, category_data in categories.items():
            group = QGroupBox(f"{category_data['icon']} {category_name}")
            group.setStyleSheet("""
                QGroupBox {
                    font-weight: bold;
                    border: 2px solid #cccccc;
                    border-radius: 5px;
                    margin-top: 1ex;
                    padding-top: 15px;
                    padding-bottom: 5px;
                }
                QGroupBox::title {
                    subcontrol-origin: margin;
                    left: 10px;
                    padding: 0 5px 0 5px;
                }
            """)
            
            # Create horizontal layout for buttons in each category
            group_layout = QHBoxLayout(group)  
            group_layout.setSpacing(5)
            group_layout.setContentsMargins(5, 10, 5, 5)  # Add top margin for group title
            
            # Add buttons for each item with icons only - text appears on hover
            for item_name in category_data["items"]:
                btn = QPushButton()  # No text - icon only!
                
                btn.clicked.connect(lambda checked, name=item_name: self.openCreateItemEditor(name))
                btn.setMinimumHeight(50)  # Increased height
                btn.setMaximumHeight(50)
                btn.setMinimumWidth(50)   # Increased width  
                btn.setMaximumWidth(50)
                
                # Set icon if available
                icon_filename = icon_name_mapping.get(item_name)
                if icon_filename:
                    icon_path = os.path.join(os.path.dirname(__file__), "..", "design", "createItems", icon_filename)
                    if os.path.exists(icon_path):
                        icon = QIcon(icon_path)
                        btn.setIcon(icon)
                        btn.setIconSize(QSize(36, 36))  # Larger icon size for bigger buttons
                
                # Rich tooltip with description (shows on hover)
                item_description = category_data["descriptions"].get(item_name, f"Create {item_name.replace('Create', '')}")
                clean_name = item_name.replace("Create", "")
                rich_tooltip = f"""
                <div style="max-width: 300px;">
                    <h3 style="margin-bottom: 5px; color: #2c3e50;">{clean_name}</h3>
                    <p style="margin: 0; line-height: 1.4; color: #34495e;">
                        {item_description}
                    </p>
                    <hr style="margin: 8px 0; border: none; border-top: 1px solid #bdc3c7;">
                    <small style="color: #7f8c8d;">Click to add {clean_name} to your model</small>
                </div>
                """
                btn.setToolTip(rich_tooltip)
                
                # Style the button for icon-only display
                btn.setStyleSheet("""
                    QPushButton {
                        border: 1px solid #bdc3c7;
                        border-radius: 6px;
                        background-color: #ecf0f1;
                        padding: 8px;
                    }
                    QPushButton:hover {
                        background-color: #d5dbdb;
                        border: 2px solid #3498db;
                    }
                    QPushButton:pressed {
                        background-color: #bdc3c7;
                    }
                """)
                
                group_layout.addWidget(btn)
            
            # Add stretch to push buttons to top
            group_layout.addStretch()
            main_layout.addWidget(group)
        
        # Add main stretch to push everything to the left
        main_layout.addStretch()
        
        self.ribbonTabs.addTab(add_widget, "‚ûï Create")


    def createRibbonLeftPanel(self):
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(5, 5, 5, 5)

        # Create and assign the label as an instance variable
        self.structureLabel = QLabel("üèóÔ∏è Model Structure")
        self.structureLabel.setFont(QFont("Arial", 10, QFont.Bold))
        self.structureLabel.setStyleSheet("""
            QLabel {
                background-color: #e9ecef;
                padding: 5px;
                border-radius: 3px;
                border: 1px solid #dee2e6;
            }
        """)
        left_layout.addWidget(self.structureLabel)

        # Add 'Show Documentation' button
        from PyQt5.QtWidgets import QPushButton, QMessageBox
        from theDocHelper.theDocFieldHelp import getLegacyItemPageRange, SectionPdfImageDialog
        # docButton = QPushButton("Show Documentation for Selected")
        # docButton.setToolTip("Open PDF documentation for the selected item in the model structure.")
        # left_layout.addWidget(docButton)

        def show_selected_doc():
            from guiForms.addItemDialog import AddModelElementDialog
            import exudyn as exu
            import inspect
            item = self.structureTree.currentItem()
            if not item:
                QMessageBox.information(self, "Documentation", "No item selected in the model structure.")
                return
            compKey = item.data(0, Qt.UserRole)
            if hasattr(self, 'guiModelMapping') and compKey in self.guiModelMapping:
                entry = self.guiModelMapping[compKey]
                data = entry.get('data', {})
                objectType = data.get('objectType') or data.get('type')
                help_text = self.legacy_help_cache.get(objectType)
                if not help_text:
                    try:
                        dlg = AddModelElementDialog(parent=self, pdfBookmarks=self._pdfBookmarks, pdfPath=self._pdfPath)
                        if objectType.startswith("Create"):
                            func = getattr(exu.MainSystem, objectType, None)
                            if func is None:
                                func = getattr(exu, objectType, None)
                            help_lines = []
                            help_lines.append(f"Exudyn {objectType} - High-Level Creation Function")
                            help_lines.append("=" * 60)
                            help_lines.append("")
                            try:
                                sig = inspect.signature(func)
                                help_lines.append("Function signature:")
                                help_lines.append(f"  {objectType}{sig}")
                                help_lines.append("")
                            except Exception:
                                pass
                            doc = func.__doc__
                            if not doc:
                                import io
                                from contextlib import redirect_stdout
                                f = io.StringIO()
                                with redirect_stdout(f):
                                    help(func)
                                doc = f.getvalue()
                            if doc:
                                help_lines.append(doc.strip())
                            help_lines.append("")
                            help_lines.append("Usage Note:")
                            help_lines.append("This is a high-level creation function that automatically handles")
                            help_lines.append("the creation of nodes, objects, markers, and constraints as needed.")
                            help_lines.append("")
                            help_lines.append("For more detailed documentation, use the PDF help button.")
                            help_text = '\n'.join(help_lines)
                        else:
                            help_text = dlg._getLegacyHelpFromMetadata(objectType)
                    except Exception:
                        help_text = None
                # Try to find PDF help if available (bookmarks already loaded at startup)
                page_range = None
                has_pdf_help = False
                from theDocHelper.theDocFieldHelp import getLegacyItemPageRange, getCreateItemPageRange, SectionPdfImageDialog
                import os
                
                # Use already-loaded bookmarks from global cache
                if hasattr(self, '_pdfBookmarks') and self._pdfBookmarks is not None:
                    pdfBookmarks = self._pdfBookmarks
                    pdfPath = getattr(self, '_pdfPath', None)
                else:
                    # Fallback if bookmarks weren't loaded from global cache
                    debugLog("‚ö†Ô∏è PDF bookmarks not available from global cache, skipping PDF help", origin="MainWindow")
                    pdfBookmarks = None
                    pdfPath = None

                # Only try to get PDF help if bookmarks and path are available
                if pdfBookmarks is not None and pdfPath is not None:
                    if objectType.startswith(("Object", "Node", "Marker", "Load", "Sensor")):
                        start_page, end_page = getLegacyItemPageRange(pdfPath, pdfBookmarks, objectType)
                        if start_page and end_page:
                            page_range = list(range(start_page, end_page + 1))
                            has_pdf_help = True
                    elif objectType.startswith("Create"):
                        start_page, end_page = getCreateItemPageRange(pdfPath, pdfBookmarks, objectType)
                        if start_page and end_page:
                            page_range = list(range(start_page, end_page + 1))
                            has_pdf_help = True
                else:
                    debugLog("‚ö†Ô∏è PDF bookmarks or path not available, skipping PDF help", origin="MainWindow")
                    # Optionally, show a user-friendly message
                    # QMessageBox.information(self, "PDF Documentation Not Available", "PDF documentation is not available. Please check your installation.")

                if help_text:
                    from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton, QHBoxLayout, QLabel
                    help_dialog = QDialog(self)
                    help_dialog.setWindowTitle(f"Help: {objectType}")
                    help_dialog.setModal(False)
                    help_dialog.resize(800, 600)
                    layout = QVBoxLayout(help_dialog)
                    header = QLabel(f"<b>Exudyn Internal Documentation for {objectType}</b>")
                    header.setStyleSheet("padding: 10px; background-color: #e8f4fd; border: 1px solid #b3d9ff;")
                    layout.addWidget(header)
                    text_edit = QTextEdit()
                    text_edit.setPlainText(help_text)
                    text_edit.setReadOnly(True)
                    text_edit.setFont(self.font())
                    layout.addWidget(text_edit)
                    button_layout = QHBoxLayout()
                    if has_pdf_help and page_range:
                        page_count = len(page_range)
                        pdf_btn = QPushButton(f"üìñ View PDF Documentation ({page_count} pages)")
                        def open_pdf():
                            dialog = SectionPdfImageDialog(pdfPath, page_range, parent=self)
                            dialog.show()
                        pdf_btn.clicked.connect(open_pdf)
                        button_layout.addWidget(pdf_btn)
                    button_layout.addStretch()
                    close_btn = QPushButton("Close")
                    close_btn.clicked.connect(help_dialog.close)
                    button_layout.addWidget(close_btn)
                    layout.addLayout(button_layout)
                    help_dialog.show()
                    return
                elif has_pdf_help and page_range:
                    dialog = SectionPdfImageDialog(pdfPath, page_range, parent=self)
                    dialog.show()
                    return
                else:
                    QMessageBox.information(self, "Help", f"No specific help found for '{objectType}'.\n\nThis function is part of the Exudyn library. Please refer to the Exudyn documentation for more details.")
                    return

        # docButton.clicked.connect(show_selected_doc)

        # Tree widget for model structure
        self.structureTree = QTreeWidget()
        self.structureTree.setHeaderLabels(["Components"])
        # Start with tree collapsed for better overview
        self.structureTree.setExpandsOnDoubleClick(True)  # Allow double-click to expand/collapse
        left_layout.addWidget(self.structureTree)
        left_layout.setStretchFactor(self.structureTree, 3)  # 3 parts for structure tree

        # Modern button bar below the tree
        button_bar = QHBoxLayout()
        button_bar.setSpacing(10)
        button_bar.setAlignment(Qt.AlignCenter)

        from PyQt5.QtGui import QIcon
        from PyQt5.QtWidgets import QStyle
        style = self.style()
        # Use standard Qt icons if available, else fallback to text
        expand_icon = style.standardIcon(QStyle.SP_ArrowDown) if hasattr(QStyle, 'SP_ArrowDown') else None
        collapse_icon = style.standardIcon(QStyle.SP_ArrowUp) if hasattr(QStyle, 'SP_ArrowUp') else None
        help_icon = style.standardIcon(QStyle.SP_DialogHelpButton) if hasattr(QStyle, 'SP_DialogHelpButton') else None

        expand_all_btn = QPushButton()
        expand_all_btn.setToolTip("Expand all tree nodes")
        if expand_icon:
            expand_all_btn.setIcon(expand_icon)
        else:
            expand_all_btn.setText("Expand All")
        expand_all_btn.clicked.connect(lambda: self.structureTree.expandAll())
        button_bar.addWidget(expand_all_btn)

        collapse_all_btn = QPushButton()
        collapse_all_btn.setToolTip("Collapse all tree nodes")
        if collapse_icon:
            collapse_all_btn.setIcon(collapse_icon)
        else:
            collapse_all_btn.setText("Collapse All")
        collapse_all_btn.clicked.connect(lambda: self.structureTree.collapseAll())
        button_bar.addWidget(collapse_all_btn)

        doc_btn = QPushButton()
        doc_btn.setToolTip("Show documentation for selected item")
        if help_icon:
            doc_btn.setIcon(help_icon)
        else:
            doc_btn.setText("Help")
        doc_btn.clicked.connect(show_selected_doc)
        button_bar.addWidget(doc_btn)

        # Button 4: Copy/Duplicate
        copy_icon = style.standardIcon(QStyle.SP_FileDialogDetailedView) if hasattr(QStyle, 'SP_FileDialogDetailedView') else None
        copy_btn = QPushButton()
        copy_btn.setToolTip("Copy selected item and create duplicate")
        if copy_icon:
            copy_btn.setIcon(copy_icon)
        else:
            copy_btn.setText("Copy")
        copy_btn.clicked.connect(self.copySelectedItem)
        button_bar.addWidget(copy_btn)

        left_layout.addLayout(button_bar)

        # Graphics List widget (hidden by default)
        self.graphicsListWidget = QListWidget()
        self.graphicsListWidget.addItem("No graphics yet")
        self.graphicsListWidget.hide()
        left_layout.addWidget(self.graphicsListWidget)
        left_layout.setStretchFactor(self.graphicsListWidget, 3)  # 3 parts for graphics list (match structureTree)
        
        # Integrated Variable Editor below Model Structure
        variables_group = QGroupBox("üìù User Variables")
        variables_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #28a745;
                border-radius: 5px;
                margin-top: 1ex;
                padding-top: 5px;
                background-color: #f8fff8;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #28a745;
            }
        """)
        variables_layout = QVBoxLayout(variables_group)
        self.variableEditor = VariableEditor()
        self.variableEditor.setMaximumHeight(150)
        self.variableEditor.setMinimumHeight(120)
        setLiveEditor(self.variableEditor.editor)
        variables_layout.addWidget(self.variableEditor)
        left_layout.addWidget(variables_group)
        left_layout.setStretchFactor(variables_group, 1)  # 1 part
        
        return left_widget

    def initRendererWidget(self):
        try:
            if not hasattr(self, 'solution_viewer'):
                self.solution_viewer = ExudynNativeRendererWidget()
                self.solution_viewer.setMinimumHeight(300)
                self.solution_viewer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                self.solution_viewer.setExudynObjects(self.SC, self.mbs)
                self.solution_viewer.rendererStarted.connect(self.startRendererRefresh)
                # Add to the right panel layout after the label (index 1)
                if hasattr(self, 'right_panel_layout'):
                    self.right_panel_layout.insertWidget(1, self.solution_viewer, 1)
                else:
                    debugLog("‚ö†Ô∏è right_panel_layout not available for renderer widget")
        except Exception as e:
            debugLog(f"‚ùå Error initializing renderer widget: {e}")
            import traceback
            traceback.print_exc()

    def createRibbonRightPanel(self):
        """Create the right panel with GUI solution viewer and console for ribbon interface."""
        right_widget = QWidget()
        self.right_panel_layout = QVBoxLayout(right_widget)
        self.right_panel_layout.setContentsMargins(5, 5, 5, 5)

        # GUI Solution Viewer section (label only for now)
        viewer_label = QLabel("üéØ Exudyn OpenGL window")
        viewer_label.setFont(QFont("Arial", 10, QFont.Bold))
        viewer_label.setStyleSheet("""
            QLabel {
                background-color: #e9ecef;
                padding: 5px;
                border-radius: 3px;
                border: 1px solid #dee2e6;
            }
        """)
        self.right_panel_layout.addWidget(viewer_label)
        # (Renderer widget will be added later by initRendererWidget)

        # Console section
        console_label = QLabel("üíª Console")
        console_label.setFont(QFont("Arial", 10, QFont.Bold))
        console_label.setStyleSheet("""
            QLabel {
                background-color: #e9ecef;
                padding: 5px;
                border-radius: 3px;
                border: 1px solid #dee2e6;
            }
        """)
        self.right_panel_layout.addWidget(console_label)
        if JUPYTER_AVAILABLE and hasattr(self, 'kernel_manager'):
            self.console = RichJupyterWidget()
            self.console.kernel_manager = self.kernel_manager
            self.console.kernel_client = self.kernel_client
            self.console.setMinimumHeight(120)
            self.console.setMaximumHeight(150)
            self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
            self.console.setStyleSheet("""
                RichJupyterWidget {
                    background-color: #2d3748;
                    color: #e2e8f0;
                    border: 1px solid #4a5568;
                    border-radius: 3px;
                    font-family: Consolas, monospace;
                    font-size: 11px;
                }
            """)
            self.right_panel_layout.addWidget(self.console)
        else:
            self.console = QTextEdit()
            self.console.setReadOnly(True)
            self.console.setStyleSheet("""
                QTextEdit {
                    background-color: #2d3748;
                    color: #e2e8f0;
                    border: 1px solid #4a5568;
                    border-radius: 3px;
                    font-family: Consolas, monospace; font-size: 11px;
                }
            """)
            self.console.setPlainText("Exudyn GUI Console\n>>> Jupyter console not available - using fallback...")
            self.console.setMinimumHeight(120)
            self.console.setMaximumHeight(150)
            self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
            self.right_panel_layout.addWidget(self.console)
        
        return right_widget

    def bind_to_kernel(self, **kwargs):
        """Directly bind Python objects into the in-process kernel namespace."""
        kernel = self.kernel_manager.kernel
        shell  = kernel.shell  # IPython's InteractiveShell instance
        shell.user_ns.update(kwargs)
        debugLog(f"Bound {list(kwargs)} directly into kernel namespace",
                 origin="MainWindow")

    def resetModelTrackingState(self):
        self.createToComponents = {}
        self.inferredComponentTypes = {
            'nodes': {},
            'markers': {},
            'objects': {},
            'loads': {},
            'sensors': {},
        }
        self.componentIndexToType = {
            'nodes': {},
            'markers': {},
            'objects': {},
            'loads': {},
            'sensors': {},
        }

    def closeEvent(self, event):
        """Handle window close event with save prompt."""
        # Check if there are unsaved changes
        has_changes = len(self.modelSequence) > 0 or bool(self.userVariables)
        
        if has_changes:
            # Ask user if they want to save current project
            reply = QMessageBox.question(
                self, 
                "Save Project Before Exit?", 
                "You have unsaved changes. Do you want to save your project before exiting?",
                QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                QMessageBox.Yes
            )
            
            if reply == QMessageBox.Cancel:
                event.ignore()  # Cancel the close event
                return
            elif reply == QMessageBox.Yes:
                # Save current project first
                self.saveProject()
        
        # Confirm exit
        confirm_reply = QMessageBox.question(
            self, 
            "Exit Application", 
            "Are you sure you want to exit Exudyn Model Builder?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if confirm_reply == QMessageBox.No:
            event.ignore()  # Cancel the close event
            return
          # Proceed with cleanup and exit
        debugLog("üëã Exiting Exudyn Model Builder...", origin="MainWindow")
        try:
            # Stop renderer refresh before cleanup
            self.stopRendererRefresh()
            # Cleanup kernel
            self.kernel_client.stop_channels()
            self.kernel_manager.shutdown_kernel()
        except:
            pass  # Ignore cleanup errors during exit
        
        event.accept()  # Accept the close event
        super().closeEvent(event)

    def focusInEvent(self, event):
        """üîÑ Restore Focus on Qt MainWindow Re-activation"""
        super().focusInEvent(event)
        
        # Set focus to renderer when main window gains focus
        try:
            if hasattr(self, 'solution_viewer') and self.solution_viewer:
                self.solution_viewer.setFocusToRenderer()
        except Exception as e:
            debugLog(f"‚ö†Ô∏è Could not set focus to renderer: {e}", origin="MainWindow")
        
        # Update renderer with DoIdleTasks when gaining focus
        try:
            if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                self.SC.renderer.DoIdleTasks(waitSeconds=0.1)
        except Exception as e:
            debugLog(f"‚ö†Ô∏è Focus renderer refresh error: {e}", origin="MainWindow")

    # Also fix the addItem method which has the most critical issue:
    def addItem(self, mode="all"):
        dialog = AddItemDialog(self, mode=mode, pdfBookmarks=self._pdfBookmarks, pdfPath=self._pdfPath)
        legacy_handled = False
        if mode == "legacy":
            from PyQt5.QtCore import QTimer
            def handle_type_selected(typeName):
                nonlocal legacy_handled
                legacy_handled = True
                QTimer.singleShot(0, lambda: self.openCreateItemEditor(typeName))
            dialog.typeSelected.connect(handle_type_selected)
        result = dialog.exec_()
        # If legacy was handled via signal, skip the normal add logic
        if mode == "legacy" and legacy_handled:
            return
        if result:
            typeName = dialog.selectedType()
            debugLog(f"[MainWindow.addItem] Calling addItemToModel for type: {typeName}", origin="mainWindow.py")
            # üîß CRITICAL FIX: Save renderer state AFTER dialog closes (after user moved view)
            # but BEFORE model rebuild
            debugLog("üîÑ Saving renderer state after dialog closed, before rebuild...", origin="mainWindow.py")
            captured_view_state = saveRendererStateFor(self)
            # Call addItemToModel without expecting view state return (since we captured it ourselves)
            index = addItemToModel(typeName, self)
            if mode == "legacy" and index is not None:
                self.modelSequence[index]['isLegacy'] = True  # Item metadata
                self.modelSequence[index]['data']['isLegacy'] = True  # Data level (for build process)
            debugLog(f"[MainWindow.addItem] addItemToModel returned index: {index}", origin="mainWindow.py")
            if index is not None:
                self.undoStack.append({'action': 'add', 'index': index})
                # Build system (auto-restore will handle view preservation)
                self.buildSystemAndShowAndRefreshTree()
                debugLog(f"[MainWindow.addItem] Finished buildSystemAndShowAndRefreshTree()")



    def editSelectedItem(self):
        item = self.structureTree.currentItem()
        if not item:
            return
        createIdx = self.resolveModelSequenceIndex(item)
        if createIdx is None:
            return
        result, oldData = editModelItem(createIdx, self)
        if result:
            self.undoStack.append({'action': 'edit', 'index': createIdx, 'oldData': oldData})
            self.buildSystemAndShowAndRefreshTree()

    def copySelectedItem(self):
        """Copy the selected item and open AutoGeneratedForm for duplication."""
        item = self.structureTree.currentItem()
        if not item:
            QMessageBox.information(self, "Copy Item", "Please select an item to copy.")
            return
        
        createIdx = self.resolveModelSequenceIndex(item)
        if createIdx is None:
            QMessageBox.warning(self, "Copy Item", "Unable to resolve the selected item for copying.")
            return
        
        # Import and call the copy function
        from exudynGUI.core.modelManager import copyModelItem
        result, copiedData = copyModelItem(createIdx, self)
        if result:
            self.undoStack.append({'action': 'add', 'index': len(self.modelSequence) - 1, 'oldData': None})
            self.buildSystemAndShowAndRefreshTree()

    def removeSelectedItem(self):
        item = self.structureTree.currentItem()
        if not item:
            return
        createIdx = self.resolveModelSequenceIndex(item)
        if createIdx is None:
            return
        
        removed = removeModelItem(createIdx, self)
        if removed:
            self.undoStack.append({'action': 'remove', 'index': createIdx, 'oldData': removed})
            self.buildSystemAndShowAndRefreshTree()
    
    def undoLastAction(self):
        undoLastAction(self.undoStack, self)
        self.buildSystemAndShowAndRefreshTree()
    
    def buildSystemAndShow(self):

        
        # === REBUILD SYSTEM ===
        self.resetModelTrackingState()
        buildSystemFromSequence(self)
        
        self.structure, self.componentToCreate = extractModelStructure(self.mbs, self.modelSequence)
        buildModelTree(self, self.modelSequence)        # === RESTORE VIEW STATE AFTER REBUILD (WITH PROPER TIMING) ===



    def getAvailableObjects(self):
        objects = []
        structure = getattr(self, 'structure', {}).get('objects', {})
        for idx, entry in structure.items():
            name = entry.get('name', f"Object {idx}")
            objType = entry.get('type', 'Unknown')
            objects.append((idx, name, objType))
        return objects
    def getAvailableBodies(self):
        bodies = []
        objects = self.structure.get('objects', {})
        objectCategories = self.structure.get('categories', {}).get('objects', {})
        debugLog(f"getAvailableBodies ‚Üí objects = {list(objects.keys())}")
        debugLog(f"getAvailableBodies ‚Üí objectCategories = {objectCategories}")
    
        for idx, entry in objects.items():
            category = objectCategories.get(idx, '')
            debugLog(f"idx = {idx}, category = '{category}', entry = {entry}")
            if "Body" in category:  # or == "Objects (Body)"
                name = entry.get('name', f"Body {idx}")
                objType = entry.get('type', 'Unknown')
                bodies.append((idx, name, objType))
    
        debugLog(f"‚úÖ Final availableBodies = {bodies}")
        return bodies



    
    def getAvailableMarkers(self):
        markers = []
        structure = getattr(self, 'structure', {}).get('markers', {})
        for idx, entry in structure.items():
            name = entry.get('name', f"Marker {idx}")
            markerType = entry.get('type', 'Unknown')
            markers.append((idx, name, markerType))
        return markers
    
    def getAvailableNodes(self):
        nodes = []
        for idx in self.mbs.GetNodeNumbers():
            try:
                nodeData = self.mbs.GetNode(idx)
                name = nodeData.get('name', f"Node {idx}")
                nodeType = nodeData.get('nodeType', 'Unknown')
                nodes.append((idx, name, nodeType))
            except Exception as e:
                import traceback
                debugLog(f"Exception in getAvailableNodes: {e}", origin="mainWindow.py:getAvailableNodes")
                traceback.print_exc()
                continue  # Skip invalid or deleted indices
        return nodes

    
    def getAvailableSensors(self):
        sensors = []
        structure = getattr(self, 'structure', {}).get('sensors', {})
        for idx, entry in structure.items():
            name = entry.get('name', f"Sensor {idx}")
            sensorType = entry.get('type', 'Unknown')
            sensors.append((idx, name, sensorType))
        return sensors

    def getAvailableItems(self, category):
        """
        Return a list of (index, name, type) for a given category:
        category ‚àà { "node", "marker", "object", "sensor", "load", "body" }
        """
        nameByIndex = {}
        typeByIndex = {}

        for item in self.modelSequence:
            gui = item.get('GUI', {})
            # Defensive: prefer GUI fields, fallback to modelSequence if needed
            if "returnInfo" in gui:
                for k, v in gui["returnInfo"].items():
                    if isinstance(v, int):
                        if k.lower().endswith("number"):
                            nameByIndex[v] = gui.get("name", "")
                            typeByIndex[v] = k[:-6]  # strip "Number"
            objIndex = gui.get("objIndex")
            if isinstance(objIndex, int):
                idx = objIndex
                nameByIndex[idx] = gui.get("name", "")
                typeByIndex[idx] = gui.get("exudynType", "")

        if category == "body":
            # Subset of object numbers, filtered by category "Objects (Body)"
            indices = list(self.mbs.GetObjectNumbers())
            results = []
            for idx in indices:
                obj = self.mbs.GetObject(idx)
                objType = obj.get("objectType", "")
                if "body" in objType.lower():  # crude filter
                    results.append((idx, nameByIndex.get(idx, f"[{idx}]"), objType))
            return results

        getterMap = {
            "object": self.mbs.GetObjectNumbers,
            "node": self.mbs.GetNodeNumbers,
            "marker": self.mbs.GetMarkerNumbers,
            "sensor": self.mbs.GetSensorNumbers,
            "load": self.mbs.GetLoadNumbers,
        }

        indices = getterMap.get(category, lambda: [])()
        results = []
        for idx in indices:
            label = nameByIndex.get(idx, f"[{idx}]")
            objType = ""
            try:
                if category == "object":
                    objType = self.mbs.GetObject(idx)["objectType"]
                elif category == "node":
                    objType = self.mbs.GetNode(idx)["nodeType"]
                elif category == "marker":
                    objType = self.mbs.GetMarker(idx)["markerType"]
                elif category == "sensor":
                    objType = self.mbs.GetSensor(idx)["sensorType"]
                elif category == "load":
                    objType = self.mbs.GetLoad(idx)["loadType"]
            except:
                pass
            results.append((idx, label, objType))
        return results
    
    def buildSystemAndShowAndRefreshTree(self):
       
        # === EXECUTE ORIGINAL LOGIC ===
        # ‚úÖ Save variable edits from dock before build
        if hasattr(self, 'variableEditor'):
            self.variableEditor.saveFile()  # persist changes
        
        # ‚úÖ Load latest variable definitions
        from exudynGUI.core.variableManager import loadUserVariables
        self.userVariables = loadUserVariables()
    
        # ‚úÖ Reset internal tracking (crucial for model tree!)
        self.resetModelTrackingState()
    
        # Step 1: Build the MBS system from modelSequence
        buildSystemFromSequence(self)

        # Step 2: Extract structure and mapping (must come before debug prints)
        self.structure, _ = extractModelStructure(self.mbs, self.modelSequence)

        # Mirror compKey-style mapping for editing
        self.componentToCreate = {}
        for createIdx, compDict in self.createToComponents.items():
            for compType, indices in compDict.items():
                for idx in indices:
                    self.componentToCreate[f"{compType[:-1]}_{idx}"] = createIdx        # Debug: Print modelSequence and structure after adding
        debugInfo(f"modelSequence after build: {self.modelSequence}", origin="mainWindow.py", category=DebugCategory.MODEL)
        debugInfo(f"structure after extractModelStructure: {self.structure}", origin="mainWindow.py", category=DebugCategory.MODEL)
        debugInfo(f"createToComponents: {self.createToComponents}", origin="mainWindow.py", category=DebugCategory.MODEL)
        debugInfo(f"componentToCreate: {self.componentToCreate}", origin="mainWindow.py", category=DebugCategory.MODEL)

        # üîß Infer actual types and categories for labels
        for compType in ['objects', 'nodes', 'markers', 'loads', 'sensors']:
            items = self.structure.get(compType, [])
            categories = self.structure.get('categories', {}).get(compType, {})
            for item in items:
                idx = item['index']
                typ = item['data'].get(f'{compType[:-1]}Type', '?')  # e.g. 'objectType'
                cat = categories.get(idx, None)
                createIdx = self.componentToCreate.get(f"{compType[:-1]}_{idx}", None)
                if createIdx is not None and createIdx < len(self.modelSequence):
                    createEntry = self.modelSequence[createIdx]
                    enriched = createEntry.get('enrichedReturnValues', {})
                    enrichedData = enriched.get(f"{compType[:-1]}Number", {})
                    if isinstance(enrichedData, dict):
                        typ = enrichedData.get(f"{compType[:-1]}Type", typ)
                self.inferredComponentTypes[compType][idx] = typ
                self.componentIndexToType[compType][idx] = cat

        # Update rawModelSequence and structuredModelTree
        self.rawModelSequence = self.modelSequence
        self.structuredModelTree = self.structure

        # --- Build and store the combined mapping for all created items, including UFs and graphics ---
        self.combinedModelInfoDict = {}
        for i, item in enumerate(self.modelSequence):
            data = item.get('data', {})
            entry = {
                'type': item.get('type'),
                'name': item.get('GUI', {}).get('name'),
                'index': i,
                'objIndex': item.get('GUI', {}).get('objIndex'),
                'label': f"{item.get('type')}_{item.get('GUI', {}).get('name')} [Index {i}] [Created ID {item.get('GUI', {}).get('objIndex','?')}]",
                'model_tree_entry': None,
                'userFunctions': [],
                'graphicsData': [],
            }
            # Find corresponding model tree entry (by objIndex for objects, or by name/index for others)
            found = False
            for compType in ['objects', 'nodes', 'markers', 'loads', 'sensors']:
                for struct_entry in self.structure.get(compType, []):
                    if struct_entry['index'] == data.get('objIndex') or struct_entry['data'].get('name') == data.get('name'):
                        entry['model_tree_entry'] = struct_entry
                        found = True
                        break
                if found:
                    break
            # UserFunctions
            for k, v in data.items():
                if k.endswith('UserFunction'):
                    if isinstance(v, str) and v.startswith('UF'):
                        entry['userFunctions'].append({k: v})
                    elif callable(v) and hasattr(v, '__name__') and v.__name__.startswith('UF'):
                        entry['userFunctions'].append({k: v.__name__})            # Graphics/visualization
            gDataList = data.get('graphicsDataList', [])
            if gDataList is None:
                debugWarning('graphicsDataList is None, replacing with empty list')
                gDataList = []
            vDataList = data.get('VgraphicsData', [])
            if vDataList is None:
                debugWarning('VgraphicsData is None, replacing with empty list')
                vDataList = []
            for gEntry in gDataList:
                if isinstance(gEntry, dict) and 'name' in gEntry and 'args' in gEntry:
                    # Old dict format
                    name = gEntry.get('name', '?')
                    args = gEntry.get('args', '')
                    entry['graphicsData'].append(f"{name}({args})")
                elif isinstance(gEntry, str):
                    # New compact string format - use as-is
                    entry['graphicsData'].append(gEntry)
                else:
                    # Fallback for unknown format
                    entry['graphicsData'].append(str(gEntry))
            for vEntry in vDataList:
                entry['graphicsData'].append(str(vEntry))
            self.combinedModelInfoDict[i] = entry        # Ensure the model structure tree is refreshed after any model change or simulation
        buildModelTree(self, self.modelSequence)        # Update the Exudyn renderer with the new model
        
        # Start with tree collapsed for better overview
        self.structureTree.collapseAll()
        if hasattr(self, 'solution_viewer') and hasattr(self.solution_viewer, 'setExudynObjects'):
            debugLog("[DEBUG] Updating renderer with SC:", self.SC, "mbs:", self.mbs)
            # setExudynObjects will automatically call updateModel() if renderer is active
            self.solution_viewer.setExudynObjects(self.SC, self.mbs)



    def onTreeItemClicked(self, item, column):
        compKey = item.data(0, Qt.UserRole)
        if compKey:
            mapping = getattr(self, 'componentToCreate', {})
            if compKey in mapping:
                createIndex = mapping[compKey]
                debugTrace(f"Component {compKey} belongs to Create* item at index {createIndex}")
                self.openCreateItemEditor(createIndex)
            else:
                self.openMarkerEditor(compKey)

    def openCreateItemEditor(self, typeName):
        """Open AutoGeneratedForm to create a new item of the specified type."""
        # Prevent opening multiple forms at once
        if hasattr(self, '_autoGeneratedForm') and self._autoGeneratedForm is not None:
            if self._autoGeneratedForm.isVisible():
                return
        index = addItemToModel(typeName, self)
        if index is not None:
            self.undoStack.append({'action': 'add', 'index': index})
            self.buildSystemAndShowAndRefreshTree()
            # --- Show the AutoGeneratedForm for the new item ---
            # Only one form at a time
            # if hasattr(self, '_autoGeneratedForm') and self._autoGeneratedForm is not None:
            #     try:
            #         self._autoGeneratedForm.close()
            #     except Exception:
            #         pass
            #     self._autoGeneratedForm = None
            # from guiForms.autoGeneratedForm import AutoGeneratedForm
            # self._autoGeneratedForm = AutoGeneratedForm(typeName, parent=self, SC=self.SC)
            # self._autoGeneratedForm.show()






    def openMarkerEditor(self, compKey):
        # Extract index and open marker dialog normally
        # Example compKey: 'marker_5'
        idx = int(compKey.split('_')[1])
        # Show marker dialog for marker idx...
        self.infoBox.setPlainText(f"Open Marker Editor for Marker {idx}")

    def openStandaloneComponentEditor(self, compKey):
        # compKey example: "node_3", "object_1", etc.
        # Extract component type and index
        try:
            compType, compIndexStr = compKey.split('_')
            compIndex = int(compIndexStr)
        except Exception as e:
            debugLog(f"Invalid component key: {compKey}")
            return
    
        # Find modelSequence item matching compIndex
        # We need to find which item in modelSequence corresponds to this component index
        # This depends on how you map component indices to modelSequence indices
    
        # If you have parentWindow.componentToCreate (componentKey -> create index),
        # you might want to find the create item, or just search modelSequence for matching objIndex
    
        for idx, item in enumerate(modelSequence):
            data = item['data']
            # Check if objIndex or returnValues contain the compIndex
            # This logic depends on your data structure; here is an example:
            objIndex = data.get('objIndex')
            if objIndex == compIndex:
                # Found the item, call editModelItem
                success, oldData = editModelItem(idx, self)
                if success:
                    # Rebuild model to update UI after edit
                    self.buildSystemAndShow()
                return
    
    def showFullScript(self):
        # üîç DEBUG: Log the actual modelSequence structure from GUI
        debugLog(f"üîç [GUI DEBUG] modelSequence has {len(self.modelSequence)} items")
        for i, item in enumerate(self.modelSequence[:2]):  # Only log first 2 items
            debugLog(f"üîç [GUI DEBUG] Item {i} keys: {list(item.keys())}")
            debugLog(f"üîç [GUI DEBUG] Item {i} full structure: {item}")
        
        code = generateSimulationCode(self.modelSequence, self.userVariables, self.mbs)
        dialog = QDialog(self)
        dialog.setWindowTitle("Generated Full Exudyn Script")
        layout = QVBoxLayout(dialog)
        textEdit = QTextEdit()
        textEdit.setReadOnly(True)
        textEdit.setPlainText(code)
        layout.addWidget(textEdit)
        dialog.resize(900, 600)
        dialog.exec_()

    def updateStructureTree(self):
        # Custom: show PythonSnippet entries as [Snippet] label
        self.structureTree.clear()
        for idx, item in enumerate(self.modelSequence):
            if item.get('type') == 'PythonSnippet':
                label = item['data'].get('label', f'Snippet {idx}')
                node = QTreeWidgetItem([f'[Snippet] {label}'])
                self.structureTree.addTopLevelItem(node)
            else:
                # Fallback to existing extraction logic
                extractStructureInfo(self)
                break

    def getSymbolicName(self, item):
        objType = item.get('objectType', 'CreateObject')
        name = item.get('name', '')
        idx = item.get('creationIndex', item.get('objIndex', 0))
        
        # For CREATE items, use the standard prefix mapping
        if objType.startswith('Create'):
            prefixMap = {
                'CreateGround': 'cGround', 'CreateRigidBody': 'cRigidBody', 'CreateMassPoint': 'cMassPoint',
                'CreateMarker': 'cMarker', 'CreateMarkerBodyPosition': 'cMarkerBodyPosition',
                'CreateForce': 'cForce', 'CreateTorque': 'cTorque', 'CreateLoad': 'cLoad',
                'CreateSensor': 'cSensor', 'CreateNode': 'cNode',
                'CreateCartesianSpringDamper': 'cCartesianSpringDamper', 'CreateCoordinateConstraint': 'cCoordinateConstraint',
                'CreateSpringDamper': 'cSpringDamper',
            }
            prefix = prefixMap.get(objType, f'c{objType[6:]}')  # Strip 'Create' prefix
            return prefix
        else:
            # For legacy items, use the 'l' prefix + name pattern
            if name:
                return f"l{name}"
            else:
                # Determine prefix based on object type
                if objType.startswith('Sensor'):
                    return f"l{objType[6:]}{idx}"  # lBody0, lNode1, etc.
                elif objType.startswith('Object'):
                    return f"l{objType[6:]}{idx}"  # lMassPoint0, lGround1, etc.
                elif objType.startswith('Node'):
                    return f"l{objType[4:]}{idx}"   # lPoint0, lRigidBody1, etc.
                elif objType.startswith('Marker'):
                    return f"l{objType[6:]}{idx}"   # lNodeCoordinate0, etc.                elif objType.startswith('Load'):
                    return f"l{objType[4:]}{idx}"   # lForce0, lTorque1, etc.
                else:
                    return f"l{objType}{idx}"

    def onStructureTreeItemClicked(self, item, column):
        compKey = item.data(0, Qt.UserRole)
        debugLog(f"[DEBUG] Tree item clicked: compKey={compKey}, type={type(compKey)}")
        
        if isinstance(compKey, int):  # top-level created item (both CREATE and legacy)
            # Use the up-to-date guiModelMapping for code generation
            model_entry = self.guiModelMapping.get(compKey)
            debugLog(f"[DEBUG] Model entry found: {model_entry is not None}")
            if model_entry and 'data' in model_entry:
                data = model_entry['data']
                debugLog(f"[DEBUG] Item data - objectType: {data.get('objectType')}, objIndex: {data.get('objIndex')}")
                
                if 'objectType' in data:
                    try:
                        # Get all items for context (needed for symbolic reference resolution)
                        allItems = [entry for entry in self.guiModelMapping.values() if 'data' in entry]
                        allItemsData = [entry['data'] for entry in allItems]
                        
                        # Build proper symbolic name mapping using the corrected getSymbolicName
                        globalIndexMap = {}
                        for it in allItemsData:
                            if 'objIndex' in it and it['objIndex'] is not None:
                                symbolic_name = self.getSymbolicName(it)
                                globalIndexMap[it['objIndex']] = symbolic_name
                                debugLog(f"[DEBUG] Mapped objIndex {it['objIndex']} -> {symbolic_name}")
                        
                        tempSC = exu.SystemContainer()
                        tempMbs = tempSC.AddSystem()
                        debugLog(f"[DEBUG] Generating code for item: {data.get('objectType')} with globalIndexMap: {globalIndexMap}")
                        
                        # Generate code for the single clicked item, but with full context
                        code = generateExudynCodeFromItems([data], tempMbs, globalIndexMap=globalIndexMap, fullScript=False)
                        self.infoBox.setPlainText(code)
                        debugLog(f"[DEBUG] Code generation successful")
                    except Exception as e:
                        error_msg = f"# ‚ö†Ô∏è Error generating code for {data.get('objectType', 'unknown')}: {str(e)}"
                        self.infoBox.setPlainText(error_msg)
                        debugLog(f"[DEBUG] Code generation failed: {e}")
                        import traceback
                        debugLog(f"[DEBUG] Full traceback: {traceback.format_exc()}")
                else:
                    self.infoBox.setPlainText("# ‚ö†Ô∏è Invalid item: missing objectType.")
            else:
                self.infoBox.setPlainText("# ‚ö†Ô∏è Invalid item: missing data.")

        elif isinstance(compKey, str):  # component like 'object_0'
            if compKey in self.componentToCreate:
                createIdx = self.componentToCreate[compKey]
                itemData = self.modelSequence[createIdx].get('data', {})
                if 'objectType' in itemData and 'objIndex' in itemData:
                    allItems = [entry['data'] for entry in self.modelSequence]
                    globalIndexMap = {
                        it['objIndex']: f"{self.getSymbolicName(it)}"
                        for it in allItems if 'objIndex' in it
                    }
                    # Use a temporary MainSystem for code generation
                    tempSC = exu.SystemContainer()
                    tempMbs = tempSC.AddSystem()
                    code = generateExudynCodeFromItems([itemData], tempMbs, globalIndexMap=globalIndexMap)
                    self.infoBox.setPlainText(code)
                else:
                    self.infoBox.setPlainText("# ‚ö†Ô∏è Invalid item: missing objectType or objIndex.")
            else:
                self.infoBox.setPlainText(f"# ‚ö†Ô∏è No creation entry found for: {compKey}")
        else:
            self.infoBox.setPlainText(item.text(0))



    def editFromStructure(self, item, _column):
        createIdx = self.resolveModelSequenceIndex(item)
        if createIdx is not None:
            self.structureTree.setCurrentItem(item)
            self.editSelectedItem()

    def onTreeItemDoubleClicked(self, item, column):
        self.editFromStructure(item, column)

    def printCombinedModelInfo(self):
        """Prints combined model information in various formats and injects it into the Jupyter kernel."""
        # Always refresh the model structure before printing
        self.buildSystemAndShowAndRefreshTree()
        import pprint        # Print model tree structure
        debugLog("=== Model Tree Structure (self.structure) ===")
        from pprint import pformat
        debugLog(pformat(_summarize_large_blobs(self.structure)))

        # Print human-readable model tree
        def indent(s, level):
            return '    ' * level + s
        debugLog("=== Human-Readable Model Tree ===")
        debugLog("=== GUI ‚Üî Model Tree Full Mapping (All Model Data) ===")
        from pprint import pformat
        for idx, model_entry in getattr(self, 'guiModelMapping', {}).items():
            debugLog(f"[Index {idx}]:")
            debugLog(pformat(_summarize_large_blobs(model_entry), compact=True, width=120))
        debugLog("=== End of Full Model Data Mapping ===")
        debugLog("=== End of Model Tree ===")

        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.information(self, "Debug Info", "Combined model information has been printed to the console.")

    def inject_variable(self, name, value):
        """Inject `value` into the kernel under the name `name` without ever printing the blob."""
        import pickle, base64
        # serialize & encode
        pickled = base64.b64encode(pickle.dumps(value)).decode('ascii')

        # log only the name
        debugLog(f"Injecting variable '{name}' into kernel namespace (data omitted)",
                 origin="MainWindow")

        # ensure pickle & base64 are available (silent + no history)
        self.kernel_client.execute(
            "import pickle, base64",
            silent=True,
            store_history=False
        )

        # now do the real assignment, also silent + no history
        cmd = (            f"{name} = pickle.loads("
            f"    base64.b64decode('{pickled}')"
            f")"
        )
        self.kernel_client.execute(
            cmd,
            silent=True,
            store_history=False
        )

    def inject_debug_variables(self):
        """Inject mbs, SC, and PrintCombinedModelInfo helper into the kernel."""
        # Note: we already injected the actual objects above.
        # Here we just push a tiny helper function:
        self.kernel_client.execute(
            "def PrintCombinedModelInfo():\n"
            "    print('Use the GUI to access PrintCombinedModelInfo')",
            silent=True, store_history=False
        )
        debugLog("Injected PrintCombinedModelInfo helper into kernel namespace.",
                 origin="MainWindow")
          # üöÄ Auto-inject QtConsole integration on GUI startup
        try:
            # Get the absolute path to the qtconsole_launcher.py file
            import os
            import exudynGUI
            package_dir = os.path.dirname(exudynGUI.__file__)
            qtconsole_launcher_path = os.path.join(package_dir, 'guiConsole', 'qtconsole_launcher.py')
            
            qtconsole_injection_code = f"""
# üöÄ ExudynGUI QtConsole Integration Auto-Injection
try:
    exec(open(r'{qtconsole_launcher_path}', encoding='utf-8').read())
    print('‚úÖ QtConsole integration auto-loaded on GUI startup!')
except Exception as e:
    print(f'‚ö†Ô∏è QtConsole integration not available: {{e}}')
    print('üí° To find installation path: import exudynGUI, os; print(os.path.join(os.path.dirname(exudynGUI.__file__), "guiConsole", "qtconsole_launcher.py"))')
"""
            self.kernel_client.execute(qtconsole_injection_code, silent=False, store_history=False)
            debugLog("Auto-injected QtConsole integration into kernel namespace.",
                     origin="MainWindow")
        except Exception as e:
            debugLog(f"Failed to auto-inject QtConsole integration: {e}", origin="MainWindow")

    def get_structured_model_tree_dict(self):
        """Returns the structured model tree as a dictionary."""
        if not hasattr(self, 'structure'):
            debugLog("Structure is not initialized.", origin="MainWindow")
            return {}
        return self.structure

    def updateVariablesDisplay(self):
        """Update the variables display in the left panel."""
        try:
            # Get current variables from the variable editor
            if hasattr(self, 'variableEditor') and self.variableEditor:
                # The variable editor is already showing the current content,
                # no need for a separate display since we're using an integrated editor
                variables_text = self.variableEditor.editor.toPlainText()
                debugLog(f"Variables display updated, content length: {len(variables_text)}", origin="MainWindow")
            else:
                debugLog("Variable editor not available for display update", origin="MainWindow")
        except Exception as e:
            debugLog(f"Failed to update variables display: {e}", origin="MainWindow")
    
    def openVariableEditor(self, event=None):
        """Focus on the integrated variable editor."""
        try:
            if hasattr(self, 'variableEditor') and self.variableEditor:
                # Focus on the integrated variable editor
                self.variableEditor.editor.setFocus()
        except Exception as e:
            debugLog(f"Failed to focus variable editor: {e}", origin="MainWindow")

    def addCreateItem(self):
        """Add a new Create-type item to the model."""
        try:
            self.addModelItem(itemType="create")
        except Exception as e:
            debugLog(f"Failed to add create item: {e}", origin="MainWindow")

    def addLegacyItem(self):
        """Add a new Legacy-type item to the model."""
        try:
            self.addModelItem(itemType="legacy")
        except Exception as e:
            debugLog(f"Failed to add legacy item: {e}", origin="MainWindow")




    def addFlexibleBody(self):
        """Add a flexible body to the model."""
        try:
            dialog = FlexibleBodyDialog(parent=self)
            if dialog.exec_():
                # Handle flexible body creation
                debugLog("Flexible body dialog completed", origin="MainWindow")
        except Exception as e:
            debugLog(f"Failed to add flexible body: {e}", origin="MainWindow")

    def simulateModel(self):
        """Run simulation with proper 5-step workflow: save state ‚Üí undock ‚Üí pause GUI ‚Üí simulate with restored state ‚Üí dock."""
        try:
            # Stop continuous renderer refresh during simulation
            self.stopRendererRefresh()
            
            # =====================================
            # STEP 1: SAVE RENDERER STATE FIRST (BEFORE ANY CHANGES)
            # =====================================
            debugLog("üíæ STEP 1/5: Saving renderer state before any changes...", origin="MainWindow")
            saved_renderer_state = None
            saved_window_geometry = None
            
            try:
                # Save renderer state
                if hasattr(self, 'solution_viewer') and self.solution_viewer:
                    saved_renderer_state = self.solution_viewer.saveRendererState()
                    if saved_renderer_state:
                        debugLog("‚úÖ Renderer state saved successfully", origin="MainWindow")
                    else:
                        debugLog("‚ö†Ô∏è Could not save renderer state", origin="MainWindow")
                else:
                    debugLog("‚ö†Ô∏è No solution_viewer available for state saving", origin="MainWindow")
                
                # Save main window geometry to prevent unwanted resizing
                saved_window_geometry = self.saveGeometry()
                debugLog("‚úÖ Main window geometry saved", origin="MainWindow")
                
                debugLog("‚úÖ STEP 1/5 COMPLETE: States saved successfully", origin="MainWindow")
                
            except Exception as e:
                debugLog(f"‚ö†Ô∏è STEP 1/5 FAILED: Error saving states: {e}", origin="MainWindow")

            # =====================================
            # STEP 2: UNDOCK OPENGL WINDOW SECOND (AFTER SAVING STATE)
            # =====================================
            debugLog("üîì STEP 2/5: Undocking OpenGL window for simulation...", origin="MainWindow")
            was_originally_docked = False  # Track original state for restoration

            if hasattr(self, 'solution_viewer') and self.solution_viewer:
                try:
                    # Check if renderer is currently docked
                    is_currently_docked = not self.docking_toggle_btn.isChecked() if hasattr(self, 'docking_toggle_btn') else True
                    was_originally_docked = is_currently_docked  # Remember original state

                    if is_currently_docked:
                        debugLog("üîÑ Triggering undocking using SAME method as dock button...", origin="MainWindow")
                          # Do EXACTLY what the dock/undock button does
                        if hasattr(self, 'docking_toggle_btn'):
                            # Set button to undocked state (this is what the button click would do)
                            self.docking_toggle_btn.setChecked(True)  # True = undocked
                            
                            # Call the SAME method the dock button uses
                            self.toggleRendererDocking()
                            
                            debugLog("‚úÖ Undocking triggered - now waiting for completion...", origin="MainWindow")                        # ‚è∞ WAIT FOR UNDOCKING TO ACTUALLY COMPLETE (check for independent window)
                        debugLog("‚è∞ Waiting for actual undocking to complete (checking for independent window)...", origin="MainWindow")
                        start_time = time.time()
                        undocking_complete = False
                        max_wait_time = 3.0  # Wait up to 3 seconds for undocking
                        
                        while time.time() - start_time < max_wait_time:
                            QApplication.processEvents()  # Keep GUI responsive during wait
                            
                            # Check if there's an independent Exudyn window
                            if hasattr(self.solution_viewer, 'checkForIndependentWindow'):
                                if self.solution_viewer.checkForIndependentWindow():
                                    undocking_complete = True
                                    debugLog("‚úÖ Independent Exudyn window detected!", origin="MainWindow")
                                    break
                            
                            # Also check button state and renderer status
                            if (hasattr(self, 'docking_toggle_btn') and 
                                self.docking_toggle_btn.isChecked() and 
                                hasattr(self.solution_viewer, '_prefer_undocked') and 
                                self.solution_viewer._prefer_undocked):
                                # Additional check: see if renderer is active and window exists
                                if (hasattr(self.solution_viewer, 'renderer_active') and 
                                    self.solution_viewer.renderer_active):
                                    undocking_complete = True
                                    debugLog("‚úÖ Renderer active in undocked mode!", origin="MainWindow")
                                    break
                            
                            time.sleep(0.1)  # Check every 100ms
                          # Verify undocking completed
                        if undocking_complete:
                            QApplication.processEvents()
                            debugLog("‚úÖ STEP 2/5 COMPLETE: OpenGL window undocked successfully", origin="MainWindow")
                        else:
                            QApplication.processEvents()
                            debugLog("‚ö†Ô∏è STEP 2/5 WARNING: Undocking may not have completed within timeout", origin="MainWindow")
                            debugLog(f"‚ö†Ô∏è Button checked: {getattr(self.docking_toggle_btn, 'isChecked', lambda: 'N/A')()}", origin="MainWindow")
                            debugLog(f"‚ö†Ô∏è Prefer undocked: {getattr(self.solution_viewer, '_prefer_undocked', 'N/A')}", origin="MainWindow")
                            debugLog(f"‚ö†Ô∏è Renderer active: {getattr(self.solution_viewer, 'renderer_active', 'N/A')}", origin="MainWindow")
                        
                    else:
                        debugLog("‚úÖ STEP 2/5 SKIPPED: OpenGL window already undocked", origin="MainWindow")

                except Exception as e:
                    debugLog(f"‚ö†Ô∏è STEP 2/5 FAILED: Could not undock OpenGL window: {e}", origin="MainWindow")
            else:
                debugLog("‚ö†Ô∏è STEP 2/5 SKIPPED: No solution_viewer available for undocking", origin="MainWindow")            # =====================================
            # STEP 3: PAUSE GUI THIRD (AFTER UNDOCKING)
            # =====================================
            debugLog("üö´ STEP 3/5: Pausing GUI for simulation...", origin="MainWindow")
            self.pauseGUIForSimulation()
            debugLog("‚úÖ STEP 3/5 COMPLETE: GUI paused successfully", origin="MainWindow")

            # =====================================
            # STEP 4: RUN SIMULATION FOURTH (NOW FULLY ISOLATED)
            # =====================================
            debugLog("üöÄ STEP 4/5: Starting simulation...", origin="MainWindow")
            
            # Build the system first
            self.buildSystemAndShow()
            
                        # Ensure the system is assembled
            self.mbs.Assemble()
            
            # =====================================
            # INJECT SAVED VIEW STATE AFTER ASSEMBLY
            # =====================================
            debugLog("üì∑ Attempting to restore saved view state after system assembly...", origin="MainWindow")
            try:
                # First try to restore from saved_view_state (from Save View menu)
                if hasattr(self, 'saved_view_state') and self.saved_view_state:
                    if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                        # Use restoreView() method which includes proper conversion
                        #.SC.renderer.DoIdleTasks(0.5)  # Ensure renderer is ready before simulation
                        self.restoreView()
                        QApplication.processEvents()
                        debugLog("‚úÖ View state restored from menubar Save View", origin="MainWindow")
                    else:
                        debugLog("‚ö†Ô∏è SC.renderer not available for view state restoration", origin="MainWindow")
                else:
                    debugLog("‚ÑπÔ∏è No saved view state from menubar to restore", origin="MainWindow")
                    
                    # =====================================
                    # FALLBACK: RESTORE RENDERER STATE FROM BEFORE SIMULATION
                    # =====================================
                    debugLog("üîÑ Restoring renderer state before first DoIdleTasks()...", origin="MainWindow")
                    try:
                        if saved_renderer_state and hasattr(self, 'solution_viewer') and self.solution_viewer:
                            restore_success = self.solution_viewer.restoreRendererState(saved_renderer_state)
                            if restore_success:
                                debugLog("‚úÖ Renderer state restored before simulation", origin="MainWindow")
                            else:
                                debugLog("‚ö†Ô∏è Failed to restore renderer state before simulation", origin="MainWindow")
                        else:
                            debugLog("‚ö†Ô∏è No saved renderer state to restore", origin="MainWindow")
                    except Exception as e:
                        debugLog(f"‚ö†Ô∏è Error restoring renderer state: {e}", origin="MainWindow")
                    
            except Exception as e:
                debugLog(f"‚ö†Ô∏è Failed to restore saved view state: {e}", origin="MainWindow")




            if self.simulationSettings is None:
                self.initializeSimulationSettings()
            

            self.SC.renderer.DoIdleTasks() 
            self.restoreView()
            QApplication.processEvents()
            # Run the simulation (GUI is paused, OpenGL window is independent)
            self.SC.renderer.DoIdleTasks()  # Ensure renderer is ready before simulation

            exu.SolveDynamic(self.mbs, self.simulationSettings)            
            debugLog("‚úÖ STEP 4/5 COMPLETE: Simulation finished successfully", origin="MainWindow")
            
            # Post-simulation renderer updates
            try:
                # Update SC.renderer with simulation results
                if hasattr(self.SC, 'renderer'):
                    debugLog("Updating SC.renderer with simulation results", origin="MainWindow")
                    self.SC.renderer.DoIdleTasks()
                    debugLog("‚úÖ SC.renderer.DoIdleTasks() completed", origin="MainWindow")
            except Exception as e:
                debugLog(f"SC.renderer update issue: {e}", origin="MainWindow")            # =====================================
            # STEP 5: RE-DOCK OPENGL WINDOW FIFTH
            # =====================================
            debugLog("üîó STEP 5/5: Re-docking OpenGL window after simulation...", origin="MainWindow")
              # Only re-dock if it was originally docked
            if was_originally_docked:
                try:
                    if hasattr(self, 'solution_viewer') and self.solution_viewer:
                        # Directly re-dock using the renderer's docking method
                        debugLog("üîÑ Re-docking renderer after simulation...", origin="MainWindow")
                        
                        if hasattr(self.solution_viewer, 'restartRendererDocked'):
                            success = self.solution_viewer.restartRendererDocked()
                            if success:
                                # Update button to reflect docked status
                                if hasattr(self, 'docking_toggle_btn'):
                                    self.docking_toggle_btn.setChecked(False)  # False = docked
                                    self.docking_toggle_btn.setText("üîó Restart Renderer")
                                
                                # Restore main window geometry to prevent unwanted resizing
                                if saved_window_geometry:
                                    debugLog("üîÑ Restoring main window geometry...", origin="MainWindow")
                                    self.restoreGeometry(saved_window_geometry)
                                    QApplication.processEvents()
                                    debugLog("‚úÖ Main window geometry restored", origin="MainWindow")
                                
                                debugLog("‚úÖ STEP 5/5 COMPLETE: OpenGL window re-docked successfully", origin="MainWindow")
                            else:
                                debugLog("‚ö†Ô∏è STEP 5/5 FAILED: OpenGL window re-docking failed", origin="MainWindow")
                        else:
                            debugLog("‚ö†Ô∏è STEP 5/5 FAILED: Renderer does not support docking", origin="MainWindow")
                    else:
                        debugLog("‚ö†Ô∏è STEP 5/5 FAILED: No solution_viewer available for re-docking", origin="MainWindow")
                        
                except Exception as e:
                    debugLog(f"‚ö†Ô∏è STEP 5/5 FAILED: Could not re-dock OpenGL window: {e}", origin="MainWindow")

            else:
                debugLog("‚úÖ STEP 5/5 SKIPPED: Window was originally undocked, leaving undocked", origin="MainWindow")
                # Even if we didn't re-dock, restore window geometry if it was saved
                if saved_window_geometry:
                    debugLog("üîÑ Restoring main window geometry (undocked mode)...", origin="MainWindow")
                    self.restoreGeometry(saved_window_geometry)
                    debugLog("‚úÖ Main window geometry restored", origin="MainWindow")

            # Restore the saved view state after re-docking
            if saved_renderer_state:
                debugLog("üîÑ Restoring original view state after re-docking...", origin="MainWindow")
                restore_success = self.solution_viewer.restoreRendererState(saved_renderer_state)
                if restore_success:
                    debugLog("‚úÖ Original view state restored after simulation", origin="MainWindow")
                else:
                    debugLog("‚ö†Ô∏è Failed to restore original view state after simulation", origin="MainWindow")

            
            # Refresh the GUI tree and model view
            self.buildSystemAndShowAndRefreshTree()
            
            # Process any pending events
            QApplication.processEvents()

            debugLog("üéâ ALL STEPS COMPLETE: Simulation workflow finished successfully", origin="MainWindow")
              # RESUME GUI: Re-enable all controls after successful simulation
            self.resumeGUIAfterSimulation()

            # Ensure renderer timer is initialized before starting idle loop
            from core.rendererState import setupRendererTimer
            setupRendererTimer(self)          
            # Restart continuous renderer refresh after simulation
            self.startRendererRefresh()
            
            # After rebuilding or simulating
            if hasattr(self.solution_viewer, "startIdleStateLoop"):
                self.solution_viewer.startIdleStateLoop()


        except Exception as e:
            debugLog(f"‚ùå SIMULATION WORKFLOW FAILED: {e}", origin="MainWindow")              
            # CRITICAL: Always resume GUI even if simulation failed
            self.resumeGUIAfterSimulation()
            
            # Always restart renderer refresh even if simulation failed
            self.startRendererRefresh()
            
            # Try to restore original docking state and window geometry if something went wrong
            try:
                if 'was_originally_docked' in locals() and was_originally_docked:
                    if hasattr(self, 'solution_viewer') and self.solution_viewer:
                        if hasattr(self.solution_viewer, 'restartRendererDocked'):
                            success = self.solution_viewer.restartRendererDocked()
                            if success and hasattr(self, 'docking_toggle_btn'):
                                self.docking_toggle_btn.setChecked(False)  # False = docked
                                self.docking_toggle_btn.setText("üîó Docked")
                        debugLog("üîß Emergency re-dock completed after simulation failure", origin="MainWindow")
                
                # Always try to restore window geometry, even after failure
                if 'saved_window_geometry' in locals() and saved_window_geometry:
                    debugLog("üîÑ Emergency restore of main window geometry...", origin="MainWindow")
                    self.restoreGeometry(saved_window_geometry)
                    debugLog("‚úÖ Main window geometry restored after failure", origin="MainWindow")
                    
            except Exception as restore_error:
                debugLog(f"‚ö†Ô∏è Could not restore states after failure: {restore_error}", origin="MainWindow")
            
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.critical(self, "Simulation Error", f"Failed to run simulation: {str(e)}")

    def generateScript(self):
        """Generate and display the full Exudyn script for code export (not simulation execution)."""
        try:
            # Check if there are any model items to generate code from
            if not self.modelSequence:
                QMessageBox.warning(self, "Code Generation", "No model items found. Please add some components to your model first.")
                return
                
            # Generate the complete script code for export/display purposes
            # Always use true factory defaults for comparison, not the last dialog state
            
            # Capture current view state for injection into code
            current_view_state = None
            try:
                if hasattr(self, 'SC') and self.SC and hasattr(self.SC, 'renderer'):
                    current_view_state = self.SC.renderer.GetState()
                    debugLog(f"üì∏ Captured current view state for code generation")
            except Exception as e:
                debugLog(f"‚ö†Ô∏è Could not capture view state: {e}")
            
            # Always use true factory defaults for comparison
            import exudyn as exu
            factory_default_simulation_settings = exu.SimulationSettings()
            
            code = generateExudynCodeFromItems(
                self.modelSequence, 
                self.mbs, 
                fullScript=True,
                simulationSettings=self.simulationSettings,
                visualizationSettings=self.SC,
                viewState=current_view_state,
                original_simulation_settings=factory_default_simulation_settings,
                original_visualization_settings=getattr(self, 'original_visualization_settings', None)
            )
            if code and code.strip():  # Check if code is not empty or just whitespace
                # Display in a new dialog or save to file
                from PyQt5.QtWidgets import QDialog, QTextEdit, QVBoxLayout, QPushButton
                
                dialog = QDialog(self)
                dialog.setWindowTitle("Generated Exudyn Script")
                dialog.resize(800, 600)
                
                layout = QVBoxLayout(dialog)
                
                text_edit = QTextEdit()
                text_edit.setPlainText(code)
                text_edit.setFont(QFont("Courier New", 10))
                layout.addWidget(text_edit)
                
                # Add save button
                save_btn = QPushButton("Save to File")
                save_btn.clicked.connect(lambda: self.saveGeneratedScript(code))
                layout.addWidget(save_btn)

                # Add copy all button
                copy_btn = QPushButton("Copy All")
                layout.addWidget(copy_btn)
                def copy_all():
                    text_edit.selectAll()
                    text_edit.copy()
                    orig_text = copy_btn.text()
                    copy_btn.setText("Copied!")
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(1000, lambda: copy_btn.setText(orig_text))
                copy_btn.clicked.connect(copy_all)
                
                dialog.exec_()
            else:
                QMessageBox.warning(self, "Code Generation", "No code could be generated. Please check your model items.")
        except Exception as e:
            debugLog(f"Failed to generate script: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Code Generation Error", f"Failed to generate script: {str(e)}")
            QMessageBox.critical(self, "Code Generation Error", f"Failed to generate script: {str(e)}")

    def saveGeneratedScript(self, code):
        """Save the generated script to a file."""
        try:
            filename, _ = QFileDialog.getSaveFileName(
                self, 
                "Save Generated Script", 
                "exudyn_model.py", 
                "Python Files (*.py)"
            )
            if filename:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(code)
                QMessageBox.information(self, "Save Complete", f"Script saved to {filename}")
        except Exception as e:
            debugLog(f"Failed to save generated script: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Save Error", f"Failed to save script: {str(e)}")

    def addModelItem(self, itemType="all"):
        """Add a model item with the specified type filter."""
        try:
            self.addItem(mode=itemType)
        except Exception as e:
            debugLog(f"Failed to add model item: {e}", origin="MainWindow")

    def undoLast(self):
        """Undo the last action."""
        try:
            self.undoLastAction()
        except Exception as e:
            debugLog(f"Failed to undo last action: {e}", origin="MainWindow")

    def newModel(self, confirm_save=False):
        """Create a new model.  If confirm_save=True, ask first; otherwise clear silently."""
        try:
             # Check if there are unsaved changes (model has components)
            has_changes = len(self.modelSequence) > 0
             
            if has_changes and confirm_save:
                # Ask user if they want to save current model
                reply = QMessageBox.question(
                    self, 
                    "Save Current Model?", 
                    "The current model has unsaved changes. Do you want to save it before creating a new model?",
                    QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.Cancel:
                    return            # back out
                if reply == QMessageBox.Yes:
                    self.saveModel()
 
            # Clear the current model
            self.clearModel()           
        
        except Exception as e:
           debugLog(f"Failed to create new model: {e}", origin="MainWindow")
           QMessageBox.critical(self, "New Model Error", f"Failed to create new model: {str(e)}")

    def clearModel(self):
        """Clear the current model and reset everything."""
        try:
            # Clear model sequence
            self.modelSequence.clear()
            

            # Reset SystemContainer and mbs (create completely fresh instances)
            # self.SC = exu.SystemContainer()
            # self.mbs = self.SC.AddSystem()
            
            # Reset user variables
            self.userVariables.clear()
            
            # Clear undo stack
            self.undoStack.clear()
            
            # Reset all state variables
            self.resetModelTrackingState()
            self.structure = {}
            self.combinedModelInfoDict = {}
            
            # Clear any other state variables that might interfere
            if hasattr(self, 'componentToCreate'):
                self.componentToCreate = {}
            if hasattr(self, 'rawModelSequence'):
                self.rawModelSequence = []
            if hasattr(self, 'structuredModelTree'):
                self.structuredModelTree = {}
            
            # Rebuild the system and refresh tree (this also updates the renderer and clears GUI tree)
            self.buildSystemAndShowAndRefreshTree()
              # Restart renderer with new SystemContainer and dock it to GUI
            if hasattr(self, 'solution_viewer') and self.solution_viewer:
                debugLog("üîÑ Restarting renderer with fresh SystemContainer...")
                # Update renderer with new SC and mbs
                self.solution_viewer.setExudynObjects(self.SC, self.mbs)
                # Restart renderer in docked mode
                if hasattr(self.solution_viewer, 'restartRendererDocked'):
                    success = self.solution_viewer.restartRendererDocked()
                    if success:
                        debugLog("‚úÖ Renderer restarted and docked successfully")
                        # Update docking button to show docked state
                        if hasattr(self, 'docking_toggle_btn'):
                            self.docking_toggle_btn.setChecked(False)  # False = docked
                            self.docking_toggle_btn.setText("üîó Docked")
                    else:
                        debugLog("‚ö†Ô∏è Renderer restart failed, but model was cleared")
                else:
                    debugLog("‚ö†Ô∏è Renderer restart not available, using setExudynObjects only")
            
            debugLog("üÜï Model cleared and reset successfully")
            debugLog("üîç Fresh SystemContainer created with new system")
            
        except Exception as e:
            debugLog(f"Failed to clear model: {e}", origin="MainWindow")
            raise


    def pauseGUIForSimulation(self):
        """
        Completely pause the main GUI during simulation to prevent Windows event handling conflicts.
        This suspends Qt event processing, disables all GUI elements, and minimizes Windows communication.
        The GUI enters a true idle state until simulation completes.
        """
        try:
            debugLog("üö´ COMPLETE GUI PAUSE: Suspending Qt event loop and Windows communication", origin="MainWindow")
            
            # Store the original enabled state
            self._gui_was_enabled = self.isEnabled()
            
            # 1. DISABLE ENTIRE GUI: Prevent all user interaction
            self.setEnabled(False)
            
            # 2. HIDE MAIN WINDOW: Minimize Windows communication
            self._window_was_visible = self.isVisible()
            if self._window_was_visible:
                self.hide()  # Remove from Windows desktop completely
            
            # 3. SUSPEND TIMERS: Stop all Qt timers to reduce event processing
            from PyQt5.QtWidgets import QApplication
            from PyQt5.QtCore import QTimer
            
            # Store active timers and stop them
            self._suspended_timers = []
            app = QApplication.instance()
            if app:
                # Find all active timers in the application
                for widget in app.allWidgets():
                    for timer in widget.findChildren(QTimer):
                        if timer.isActive():
                            self._suspended_timers.append(timer)
                            timer.stop()
                            debugLog(f"Suspended timer: {timer.objectName()}", origin="MainWindow")
            
            # 4. BLOCK EVENT PROCESSING: Install event filter to block Windows messages
            self._event_filter_installed = False
            if app:
                try:
                    # Create custom event filter that blocks most events
                    from PyQt5.QtCore import QObject, QEvent
                    
                    class SimulationEventFilter(QObject):
                        def eventFilter(self, obj, event):
                            # Block most GUI events during simulation
                            blocked_events = [
                                QEvent.MouseButtonPress, QEvent.MouseButtonRelease, QEvent.MouseMove,
                                QEvent.KeyPress, QEvent.KeyRelease, QEvent.FocusIn, QEvent.FocusOut,
                                QEvent.WindowActivate, QEvent.WindowDeactivate, QEvent.Paint,
                                QEvent.Resize, QEvent.Move, QEvent.Show, QEvent.Hide,
                                QEvent.Timer  # Block timer events
                            ]
                            return event.type() in blocked_events
                    
                    self._simulation_event_filter = SimulationEventFilter()
                    app.installEventFilter(self._simulation_event_filter)
                    self._event_filter_installed = True
                    debugLog("‚úÖ Event filter installed - blocking GUI events", origin="MainWindow")
                    
                except Exception as e:
                    debugLog(f"‚ö†Ô∏è Could not install event filter: {e}", origin="MainWindow")
            
            # 5. FINAL EVENT FLUSH: Process remaining events then stop
            QApplication.processEvents()
            
            # 6. CREATE MINIMAL NOTIFICATION: Simple label instead of complex dialog
            try:
                from PyQt5.QtWidgets import QLabel, QDialog
                from PyQt5.QtCore import Qt
                from PyQt5.QtGui import QFont
                
                self._simulation_notification = QLabel("üîÑ SIMULATION RUNNING\n\nGUI suspended until completion")
                self._simulation_notification.setWindowTitle("Exudyn Simulation")
                self._simulation_notification.setAlignment(Qt.AlignCenter)
                self._simulation_notification.setWindowFlags(
                    Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool
                )
                self._simulation_notification.setStyleSheet("""
                    QLabel {
                        background-color: #2d2d2d;
                        color: #ffffff;
                        border: 2px solid #555555;
                        border-radius: 10px;
                        padding: 20px;
                        font-size: 14px;
                        font-weight: bold;
                    }
                """)
                font = QFont()
                font.setPointSize(12)
                font.setBold(True)
                self._simulation_notification.setFont(font)
                self._simulation_notification.resize(300, 120)
                
                # Position in center of screen
                screen = QApplication.desktop().screenGeometry()
                self._simulation_notification.move(
                    (screen.width() - 300) // 2,
                    (screen.height() - 120) // 2
                )
                
                self._simulation_notification.show()
                
            except Exception as e:
                debugLog(f"‚ö†Ô∏è Could not create notification: {e}", origin="MainWindow")
            
            debugLog("‚úÖ COMPLETE GUI PAUSE: Qt events blocked, Windows communication minimized", origin="MainWindow")
            
        except Exception as e:
            debugLog(f"‚ùå Failed to pause GUI completely: {e}", origin="MainWindow")            # Fallback: at least disable the main window
            self.setEnabled(False)

    def resumeGUIAfterSimulation(self):
        """
        Resume the main GUI after simulation completes.
        This restores Qt event processing, re-enables all GUI elements, and resumes Windows communication.
        """
        try:
            debugLog("‚úÖ COMPLETE GUI RESUME: Restoring Qt event loop and Windows communication", origin="MainWindow")            
            # 1. REMOVE EVENT FILTER: Restore normal event processing
            if hasattr(self, '_event_filter_installed') and self._event_filter_installed:
                try:
                    app = QApplication.instance()
                    if app and hasattr(self, '_simulation_event_filter'):
                        app.removeEventFilter(self._simulation_event_filter)
                        del self._simulation_event_filter
                        self._event_filter_installed = False
                        debugLog("‚úÖ Event filter removed - GUI events restored", origin="MainWindow")
                except Exception as e:
                    debugLog(f"‚ö†Ô∏è Could not remove event filter: {e}", origin="MainWindow")
            
            # 2. RESTORE TIMERS: Restart all suspended timers
            if hasattr(self, '_suspended_timers'):
                try:
                    for timer in self._suspended_timers:
                        if timer and not timer.isActive():
                            timer.start()
                            debugLog(f"Restored timer: {timer.objectName()}", origin="MainWindow")
                    del self._suspended_timers
                except Exception as e:
                    debugLog(f"‚ö†Ô∏è Could not restore timers: {e}", origin="MainWindow")
            
            # 3. CLOSE SIMULATION NOTIFICATION: Remove the minimal notification
            if hasattr(self, '_simulation_notification') and self._simulation_notification:
                try:
                    self._simulation_notification.close()
                    self._simulation_notification.deleteLater()
                    self._simulation_notification = None
                    debugLog("‚úÖ Simulation notification closed", origin="MainWindow")
                except Exception as e:
                    debugLog(f"‚ö†Ô∏è Could not close notification: {e}", origin="MainWindow")
            
            # 4. RESTORE MAIN WINDOW: Show if it was visible before
            if hasattr(self, '_window_was_visible') and self._window_was_visible:
                self.show()
                debugLog("‚úÖ Main window restored to visible state", origin="MainWindow")
            
            # 5. RE-ENABLE GUI: Restore all interactive elements
            if hasattr(self, '_gui_was_enabled'):
                self.setEnabled(self._gui_was_enabled)
            else:
                self.setEnabled(True)  # Default to enabled
            
            # 6. ACTIVATE WINDOW: Bring GUI back to foreground
            self.raise_()
            self.activateWindow()
            
            # 7. PROCESS PENDING EVENTS: Allow Qt to update the GUI
            QApplication.processEvents()
            
            debugLog("üîÑ COMPLETE GUI RESUME: All systems restored, GUI fully operational", origin="MainWindow")
            
        except Exception as e:
            debugLog(f"‚ùå Failed to resume GUI completely: {e}", origin="MainWindow")
            # Fallback: at least re-enable the main window
            self.setEnabled(True)
            self.show()

    def loadModel(self):
        """Load a model from file."""
        try:
            filename, _ = QFileDialog.getOpenFileName(
                self, 
                "Load Model", 
                "", 
                "JSON Files (*.json);;All Files (*)"
            )
            if filename:
                with open(filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                # Load the model data
                self.modelSequence.clear()
                self.modelSequence.extend(data.get('modelSequence', []))
                self.buildSystemAndShowAndRefreshTree()
                QMessageBox.information(self, "Load Complete", f"Model loaded from {filename}")
        except Exception as e:
            debugLog(f"Failed to load model: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Load Error", f"Failed to load model: {str(e)}")

    def saveModel(self):
        """Save the current model to file."""
        try:
            filename, _ = QFileDialog.getSaveFileName(
                self, 
                "Save Model", 
                "exudyn_model.json", 
                "JSON Files (*.json)"
            )
            if filename:
                data = {
                    'modelSequence': self.modelSequence,
                    'userVariables': self.userVariables
                }
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=2, default=str)
                QMessageBox.information(self, "Save Complete", f"Model saved to {filename}")
        except Exception as e:
            debugLog(f"Failed to save model: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Save Error", f"Failed to save model: {str(e)}")

    def getSimulationSettingsAsDict(self):
        """Convert simulation settings to a dictionary for saving."""
        from guiForms.simulationSettings import simulationSettingsToDict
        return simulationSettingsToDict(self.simulationSettings)

    def setSimulationSettingsFromDict(self, settings_dict):
        """Apply simulation settings from a dictionary."""
        from guiForms.simulationSettings import simulationSettingsFromDict
        from exudynGUI.core.debug import debugLog
        
        # Initialize if needed
        if self.simulationSettings is None:
            self.initializeSimulationSettings()
        
        # Apply the settings
        self.simulationSettings = simulationSettingsFromDict(settings_dict, self.simulationSettings)
        
        debugLog("‚úÖ Simulation settings loaded from project file", origin="mainWindow.py")

    def getVisualizationSettingsAsDict(self):
        """Convert visualization settings to a dictionary for saving."""
        from guiForms.visualizationSettings import visualizationSettingsToDict
        if hasattr(self, 'SC') and self.SC is not None:
            return visualizationSettingsToDict(self.SC.visualizationSettings, self.SC)
        return {}

    def setVisualizationSettingsFromDict(self, settings_dict):
        """Apply visualization settings from a dictionary."""
        from guiForms.visualizationSettings import visualizationSettingsFromDict
        from exudynGUI.core.debug import debugLog
        
        # Ensure SystemContainer exists
        if not hasattr(self, 'SC') or self.SC is None:
            import exudyn as exu
            self.SC = exu.SystemContainer()
        
        # Apply the settings
        self.SC = visualizationSettingsFromDict(settings_dict, self.SC)
        
        debugLog("‚úÖ Visualization settings loaded from project file", origin="mainWindow.py")

    def showVisualizationSettings(self):
        """Open the visualization settings dialog."""
        from guiForms.visualizationSettings import createVisualizationSettingsForm, collectVisualizationSettingsData, applyVisualizationSettings
        from exudynGUI.core.debug import debugLog
        import copy
        
        try:
            # Ensure SystemContainer exists
            if not hasattr(self, 'SC') or self.SC is None:
                import exudyn as exu
                self.SC = exu.SystemContainer()
            
            # Store original visualization settings structure for comparison (not the entire SC)
            from exudynGUI.guiForms.visualizationSettings import discoverVisualizationSettingsStructure
            self.original_visualization_settings = discoverVisualizationSettingsStructure(self.SC)
            
            # Create and show the dialog
            dialog = createVisualizationSettingsForm(self, self.SC)
            
            if dialog.exec_() == QDialog.Accepted:
                # Collect user changes
                data = collectVisualizationSettingsData(dialog)
                
                # Apply to SystemContainer
                applyVisualizationSettings(self.SC, data)
                
                debugLog("‚úÖ Visualization settings applied", origin="mainWindow.py")
                
        except Exception as e:
            debugLog(f"‚ùå Error in visualization settings: {e}", origin="mainWindow.py")
            QMessageBox.critical(self, "Error", f"Failed to open visualization settings: {str(e)}")


    def loadProject(self):
        """Load a project (model + additional settings)."""
        try:
            filename, _ = QFileDialog.getOpenFileName(
                self, 
                "Load Project", 
                "", 
                "JSON Files (*.json);;All Files (*)"
            )
            if filename:
                with open(filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                # Load both model and settings
                self.modelSequence.clear()
                self.modelSequence.extend(data.get('modelSequence', []))
                self.userVariables = data.get('userVariables', {})
                
                # ‚Üê ADD THIS BLOCK
                # Load simulation settings if available
                if 'simulationSettings' in data:
                    self.setSimulationSettingsFromDict(data['simulationSettings'])
                else:
                    # Initialize with defaults for older project files
                    self.initializeSimulationSettings()
                
                # Load visualization settings if available
                if 'visualizationSettings' in data:
                    self.setVisualizationSettingsFromDict(data['visualizationSettings'])
                
                # =====================================
                # LOAD AND RESTORE VIEW STATE
                # =====================================
                view_state = data.get('viewState')
                if view_state:
                    debugLog("üì∑ Loading view state from project file...", origin="MainWindow")
                    self.saved_view_state = view_state
                
                if hasattr(self, 'variableEditor'):
                    # Update the variable editor with loaded variables
                    self.variableEditor.updateFromVariables(self.userVariables)
                self.buildSystemAndShowAndRefreshTree()
                self.updateVariablesDisplay()
                
                # =====================================
                # AUTOMATICALLY RESTORE VIEW STATE AFTER LOADING
                # =====================================
                if view_state:
                    debugLog("üì∑ Auto-restoring view state after project load...", origin="MainWindow")
                    # Use a slight delay to ensure the system is fully built and renderer is ready
                    QTimer.singleShot(500, self.restoreView)  # Delay 500ms for system to be ready
                else:
                    debugLog("‚ÑπÔ∏è No view state found in project file", origin="MainWindow")
                
                QMessageBox.information(self, "Load Complete", f"Project loaded from {filename}")
        except Exception as e:
            debugLog(f"Failed to load project: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Load Error", f"Failed to load project: {str(e)}")

    def saveProject(self):
        """Save the current project (model + additional settings)."""
        try:
            filename, _ = QFileDialog.getSaveFileName(
                self, 
                "Save Project", 
                "exudyn_project.json", 
                "JSON Files (*.json)"
            )
            if filename:
                # =====================================
                # AUTOMATICALLY SAVE CURRENT VIEW STATE
                # =====================================
                debugLog("üì∑ Auto-saving current view state during project save...", origin="MainWindow")
                self.saveView()  # Explicitly save current view state
                
                data = {
                    'modelSequence': self.modelSequence,
                    'userVariables': self.userVariables,
                    'simulationSettings': self.getSimulationSettingsAsDict(),  # ‚Üê ADD THIS
                    'visualizationSettings': self.getVisualizationSettingsAsDict(),  # ‚Üê ADD THIS
                    'viewState': getattr(self, 'saved_view_state', None),  # ‚Üê ADD VIEW STATE
                    'metadata': {
                        'created': datetime.now().isoformat(),
                        'version': '1.0'
                    }
                }
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=2, default=str)
                QMessageBox.information(self, "Save Complete", f"Project saved to {filename}")
        except Exception as e:
            debugLog(f"Failed to save project: {e}", origin="MainWindow")
            QMessageBox.critical(self, "Save Error", f"Failed to save project: {str(e)}")



    def loadProject2(self, filename=None):
        """Load a project (model + additional settings)."""
        # Ensure main window is enabled and visible before showing dialog
        self.setEnabled(True)
        self.show()
        QApplication.processEvents()
        try:
            if filename is None:
                filename, _ = QFileDialog.getOpenFileName(
                    self, 
                    "Load Project", 
                    "", 
                    "JSON Files (*.json);;All Files (*)"
                )
                if not filename:
                    return  # User cancelled
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            # Load both model and settings
            self.modelSequence.clear()
            self.modelSequence.extend(data.get('modelSequence', []))
            self.userVariables = data.get('userVariables', {})
            if hasattr(self, 'variableEditor'):
                # Update the variable editor with loaded variables
                self.variableEditor.updateFromVariables(self.userVariables)
            
            # =====================================
            # LOAD AND RESTORE VIEW STATE
            # =====================================
            view_state = data.get('viewState')
            if view_state:
                debugLog("üì∑ Loading view state from project file...", origin="MainWindow")
                self.saved_view_state = view_state
            
            self.buildSystemAndShowAndRefreshTree()
            self.updateVariablesDisplay()
            
            # =====================================
            # AUTOMATICALLY RESTORE VIEW STATE AFTER LOADING
            # =====================================
            if view_state:
                debugLog("üì∑ Auto-restoring view state after project load...", origin="MainWindow")
                # Use a slight delay to ensure the system is fully built and renderer is ready
                QTimer.singleShot(500, self.restoreView)  # Delay 500ms for system to be ready
            else:
                debugLog("‚ÑπÔ∏è No view state found in project file", origin="MainWindow")
        except Exception as e:
            debugLog(f"Failed to load project: {e}", origin="MainWindow")



    def saveProject2(self, filename=None):
        # Ensure main window is enabled and visible before showing dialog
        self.setEnabled(True)
        self.show()
        QApplication.processEvents()
        """Save the current project (model + additional settings)."""
        try:
            if filename is None:
                filename, _ = QFileDialog.getSaveFileName(
                    self, 
                    "Save Project", 
                    "exudyn_project.json", 
                    "JSON Files (*.json)"
                )
                if not filename:
                    return  # User cancelled
            
            # =====================================
            # AUTOMATICALLY SAVE CURRENT VIEW STATE
            # =====================================
            debugLog("üì∑ Auto-saving current view state during project save...", origin="MainWindow")
            self.saveView()  # Explicitly save current view state
            
            # Deep copy and filter out unserializable objects
            serializable_modelSequence = self.modelSequence #make_serializable(copy.deepcopy(self.modelSequence))
            serializable_userVariables = self.userVariables #make_serializable(copy.deepcopy(self.userVariables))
            
            # Use the saved view state (now guaranteed to be current)
            view_state = getattr(self, 'saved_view_state', None)
            
            data = {
                'modelSequence': serializable_modelSequence,
                'userVariables': serializable_userVariables,
                'viewState': view_state,
                'metadata': {
                    'created': datetime.now().isoformat(),
                    'version': '1.0'
                }
            }
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, default=str)
            
            debugLog(f"‚úÖ Project saved with current view state to {filename}", origin="MainWindow")

        except Exception as e:
            debugLog(f"Failed to save project: {e}", origin="MainWindow")
            # silent on failure (you can add more logging here if you like)

    def exitApplication(self):
        """Exit the application (triggered by Exit button)."""
        try:
            # Simply close the window - closeEvent will handle save prompts
            self.close()
        except Exception as e:
            debugLog(f"Failed to exit application: {e}", origin="MainWindow")
            # Exit anyway to avoid getting stuck
            self.close()

    def connectConsoleToKernel(self):
        """Connect the Jupyter console to the kernel after both are initialized."""
        if (JUPYTER_AVAILABLE and 
            hasattr(self, 'console') and 
            hasattr(self, 'kernel_manager') and 
            hasattr(self, 'kernel_client') and
            isinstance(self.console, RichJupyterWidget)):
            
            try:
                self.console.kernel_manager = self.kernel_manager
                self.console.kernel_client = self.kernel_client
                debugLog("‚úÖ Jupyter console connected to kernel", origin="MainWindow")
            except Exception as e:
                debugLog(f"‚ùå Failed to connect console to kernel: {e}", origin="MainWindow")

    def resolveModelSequenceIndex(self, item):
        """Resolve tree item to modelSequence index for editing."""
        compKey = item.data(0, Qt.UserRole)
        debugLog(f"[resolveModelSequenceIndex] compKey = {compKey}, type = {type(compKey)}")
        
        if isinstance(compKey, int):
            # Direct modelSequence index
            if 0 <= compKey < len(self.modelSequence):
                return compKey
            else:
                debugLog(f"[resolveModelSequenceIndex] Invalid direct index: {compKey}")
                return None
        
        
        elif isinstance(compKey, str):
            # Component key like "node_0", "object_1", etc.
            # Need to map component to its Create item in modelSequence
            if hasattr(self, 'componentToCreate') and compKey in self.componentToCreate:
                createIdx = self.componentToCreate[compKey]
                debugLog(f"[resolveModelSequenceIndex] Mapped {compKey} -> createIdx {createIdx}")
                return createIdx
            else:
                debugLog(f"[resolveModelSequenceIndex] No mapping found for {compKey}")
                return None
        
        else:
            debugLog(f"[resolveModelSequenceIndex] Unknown compKey type: {type(compKey)}")
            return None

    # =======================================================================
    # Exudyn Renderer Control Methods
    # =======================================================================
    # Removed deprecated startExudynRenderer and stopExudynRenderer methods    # Renderer is now integrated and managed automatically
    def toggleRendererDocking(self):
        """Toggle between docked (embedded) and undocked (separate window) renderer modes using restart, preserving view state."""
        debugLog("üîß Docking toggle button clicked!")
        try:
            if not hasattr(self, 'solution_viewer') or not self.solution_viewer:
                debugLog("‚ö†Ô∏è No renderer available to toggle docking mode")
                return
            renderer = self.solution_viewer
            # Save renderer state before toggling
            saved_state = saveRendererStateFor(self)
            def delayed_restore():
                restoreRendererStateFor(self, saved_state)
            if self.docking_toggle_btn.isChecked():
                # Switch to undocked mode using restart
                debugLog("üîÑ Restarting renderer in undocked mode...")
                if hasattr(renderer, 'restartRendererUndocked'):
                    success = renderer.restartRendererUndocked()
                    if success:
                        self.docking_toggle_btn.setText("üì± Restart Renderer")
                        debugLog("‚úÖ Renderer restarted in undocked mode (avoids Windows message delivery issues)")
                        # Restore renderer state after undocking (delayed)
                        QTimer.singleShot(2000, delayed_restore)
                    else:
                        self.docking_toggle_btn.setText("üì± Restart Renderer")
                        self.docking_toggle_btn.setChecked(False)
                        debugLog("‚ùå Failed to restart renderer in undocked mode, staying docked")
                else:
                    debugLog("‚ö†Ô∏è Renderer does not support restart methods")
            else:
                # Switch to docked mode using restart
                debugLog("üîÑ Restarting renderer in docked mode...")
                if hasattr(renderer, 'restartRendererDocked'):
                    success = renderer.restartRendererDocked()
                    if success:
                        self.docking_toggle_btn.setText("üì± Restart Renderer")
                        debugLog("‚úÖ Renderer restarted in docked mode")
                        # Restore renderer state after docking (delayed)
                        QTimer.singleShot(2000, delayed_restore)
                    else:
                        self.docking_toggle_btn.setText("üì± Restart Renderer")
                        self.docking_toggle_btn.setChecked(True)
                        debugLog("‚ùå Failed to restart renderer in docked mode, staying undocked")
                else:
                    debugLog("‚ö†Ô∏è Renderer does not support restart methods")
                
        except Exception as e:
            debugLog(f"‚ùå Error toggling renderer docking: {e}")
            # Reset button to safe state (docked)
            self.docking_toggle_btn.setChecked(False)
            self.docking_toggle_btn.setText("ÔøΩ Restart Renderer")

    def setupMenuBar(self):
        from exudynGUI.guiForms.menubar import createMenuBar
        self.menu_bar_handler = createMenuBar(self)

    def showAboutDialog(self):
        # Optionally stop focus timer if it exists
        focus_timer = None
        if hasattr(self, 'solution_viewer') and hasattr(self.solution_viewer, '_focus_timer'):
            focus_timer = self.solution_viewer._focus_timer
            focus_timer.stop()
        dlg = AboutDialog(self, version=self.app_version)
        dlg.exec_()
        # Restart focus timer after dialog closes
        if focus_timer is not None:
            focus_timer.start(100)

    def showOnlineDocumentationDialog(self):
        # Optionally stop focus timer if it exists
        focus_timer = None
        if hasattr(self, 'solution_viewer') and hasattr(self.solution_viewer, '_focus_timer'):
            focus_timer = self.solution_viewer._focus_timer
            focus_timer.stop()
        dlg = OnlineDocumentationDialog(self)
        dlg.exec_()
        # Restart focus timer after dialog closes
        if focus_timer is not None:
            focus_timer.start(100)

    def showPdfDocumentation(self):
        # Optionally stop focus timer if it exists
        focus_timer = None
        if hasattr(self, 'solution_viewer') and hasattr(self.solution_viewer, '_focus_timer'):
            focus_timer = self.solution_viewer._focus_timer
            focus_timer.stop()
        dlg = showPdfDocumentation(self)
        dlg.exec_()
        # Restart focus timer after dialog closes
        if focus_timer is not None:
            focus_timer.start(100)

    def openPythonSnippetDialog(self):
        from .pythonSnippetDialog import PythonSnippetDialog
        kernel_client = getattr(self, 'kernel_client', None)
        dlg = PythonSnippetDialog(self, kernel_client=kernel_client)
        def on_snippet_saved(snippet):
            # Add to modelSequence and update tree
            self.modelSequence.append({
                'type': 'PythonSnippet',
                'data': snippet
            })
            self.buildSystemAndShowAndRefreshTree()
        dlg.snippetSaved.connect(on_snippet_saved)
        dlg.exec_()

    def execute_python_code(self, code):
        """Execute Python code in the global context. Used by MonacoDialog and other editors."""
        try:
            exec(code, globals())
        except Exception as e:
            debugLog(f'Error: {e}')


class AboutDialog(QDialog):
    def __init__(self, parent=None, version=""):
        super().__init__(parent)
        self.setWindowTitle("About Exudyn Model Builder")
        self.setModal(True)
        self.setWindowModality(Qt.ApplicationModal)
        # self.setFixedSize(400, 320)  # Remove fixed size to allow resizing
        layout = QVBoxLayout(self)

        # Logo
        logo_path = os.path.join(os.path.dirname(__file__), "..", "design", "assets", "exudynLogo.png")
        pixmap = QPixmap(logo_path)
        logo_label = QLabel()
        logo_label.setPixmap(pixmap.scaledToWidth(120))
        logo_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(logo_label)

        # App info
        app_name = "<b>Exudyn Model Builder</b>"
        version_str = version
        copyright_text = "¬© 2025 Michael Pieber / Exudyn GUI Team"
        website = '<a href="https://github.com/jgerstmayr/EXUDYN">Exudyn on GitHub</a>'
        info_label = QLabel(f"{app_name}<br>{version_str}<br>{copyright_text}<br>{website}")
        info_label.setOpenExternalLinks(True)
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)
        layout.addSpacing(10)

        # Description
        desc = QLabel("An extensible GUI for building and simulating multibody systems with Exudyn.<br>"
                      "For documentation, tutorials, and updates, visit the Exudyn website.")
        desc.setWordWrap(True)
        desc.setAlignment(Qt.AlignCenter)
        layout.addWidget(desc)

        # Close button
        btns = QHBoxLayout()
        btns.addStretch()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        btns.addWidget(close_btn)
        btns.addStretch()
        layout.addLayout(btns)


class OnlineDocumentationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Exudyn Online Documentation")
        self.setModal(True)
        self.setWindowModality(Qt.ApplicationModal)
        self.resize(400, 180)  # Make the dialog wider
        layout = QVBoxLayout(self)
        info = QLabel(
            'Access the latest Exudyn documentation online:<br>'
            '<a href="https://exudyn.readthedocs.io/">'
            'https://exudyn.readthedocs.io/</a>'
        )
        info.setOpenExternalLinks(True)
        info.setWordWrap(True)
        layout.addWidget(info)
        layout.addSpacing(10)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)


class showPdfDocumentation(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Exudyn Documentation")
        self.setModal(True)
        self.setWindowModality(Qt.ApplicationModal)
        self.resize(400, 250)  # Make the dialog taller
        layout = QVBoxLayout(self)




        # Local PDF Documentation
        local_group = QGroupBox("Local Documentation")
        local_layout = QVBoxLayout()
        
        # Open PDF button
        open_pdf_btn = QPushButton("Open Local PDF Documentation")
        open_pdf_btn.clicked.connect(self.openLocalPdf)
        local_layout.addWidget(open_pdf_btn)
        
        local_group.setLayout(local_layout)
        layout.addWidget(local_group)

        layout.addSpacing(10)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)

    def openLocalPdf(self):
        import os
        import subprocess
        import platform
        
        # Get the path to theDoc.pdf
        pdf_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'theDocHelper', 'theDoc.pdf')
        
        if os.path.exists(pdf_path):
            try:
                if platform.system() == 'Windows':
                    os.startfile(pdf_path)  # Windows will use the default PDF viewer
                elif platform.system() == 'Darwin':  # macOS
                    subprocess.run(['open', pdf_path])
                else:  # Linux
                    subprocess.run(['xdg-open', pdf_path])
            except Exception as e:
                QMessageBox.warning(self, "Error Opening PDF", 
                                  f"Could not open the PDF with your default viewer:\n{str(e)}\n\n"
                                  f"The PDF is located at:\n{pdf_path}")
        else:
            QMessageBox.warning(self, "PDF Not Found", 
                              f"Could not find the local PDF documentation at:\n{pdf_path}\n\n"
                              "Please check your installation.")
