# coding: utf-8

"""
    PDS Registry Search API

    Registry API enabling advanced search on PDS data and metadata. The API provides end-points to search for bundles, collections and any PDS products with advanced search queries. It also enables to browse the archive hierarchically downward (e.g. collection/s products) or upward (e.g. bundles containing a product). 

    The version of the OpenAPI document: 1.6.0
    Contact: pds-operator@jpl.nasa.gov
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pds.api_client.models.pds_products import PdsProducts

from pds.api_client.api_client import ApiClient, RequestSerialized
from pds.api_client.api_response import ApiResponse
from pds.api_client.rest import RESTResponseType


class ByProductClassesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def class_list(
        self,
        var_class: Annotated[StrictStr, Field(description="syntax: one of the allowable enum values  This is a shortcut for doing a query with ... ")],
        fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. ")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored ")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: limit=10  behavior: maximum number of matching results returned, for pagination ")] = None,
        q: Annotated[Optional[StrictStr], Field(description="syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present ")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="syntax: sort=field0,field1,...  behavior: currently only sorts ascending ")] = None,
        search_after: Annotated[Optional[List[StrictStr]], Field(description="syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time ")] = None,
        facet_fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" ")] = None,
        facet_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PdsProducts:
        """returns all PDS products of the given PDS product class that meet all given constraints. 


        :param var_class: syntax: one of the allowable enum values  This is a shortcut for doing a query with ...  (required)
        :type var_class: str
        :param fields: syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. 
        :type fields: List[str]
        :param keywords: syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored 
        :type keywords: List[str]
        :param limit: syntax: limit=10  behavior: maximum number of matching results returned, for pagination 
        :type limit: int
        :param q: syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present 
        :type q: str
        :param sort: syntax: sort=field0,field1,...  behavior: currently only sorts ascending 
        :type sort: List[str]
        :param search_after: syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time 
        :type search_after: List[str]
        :param facet_fields: syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" 
        :type facet_fields: List[str]
        :param facet_limit: syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets 
        :type facet_limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._class_list_serialize(
            var_class=var_class,
            fields=fields,
            keywords=keywords,
            limit=limit,
            q=q,
            sort=sort,
            search_after=search_after,
            facet_fields=facet_fields,
            facet_limit=facet_limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdsProducts",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def class_list_with_http_info(
        self,
        var_class: Annotated[StrictStr, Field(description="syntax: one of the allowable enum values  This is a shortcut for doing a query with ... ")],
        fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. ")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored ")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: limit=10  behavior: maximum number of matching results returned, for pagination ")] = None,
        q: Annotated[Optional[StrictStr], Field(description="syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present ")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="syntax: sort=field0,field1,...  behavior: currently only sorts ascending ")] = None,
        search_after: Annotated[Optional[List[StrictStr]], Field(description="syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time ")] = None,
        facet_fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" ")] = None,
        facet_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PdsProducts]:
        """returns all PDS products of the given PDS product class that meet all given constraints. 


        :param var_class: syntax: one of the allowable enum values  This is a shortcut for doing a query with ...  (required)
        :type var_class: str
        :param fields: syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. 
        :type fields: List[str]
        :param keywords: syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored 
        :type keywords: List[str]
        :param limit: syntax: limit=10  behavior: maximum number of matching results returned, for pagination 
        :type limit: int
        :param q: syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present 
        :type q: str
        :param sort: syntax: sort=field0,field1,...  behavior: currently only sorts ascending 
        :type sort: List[str]
        :param search_after: syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time 
        :type search_after: List[str]
        :param facet_fields: syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" 
        :type facet_fields: List[str]
        :param facet_limit: syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets 
        :type facet_limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._class_list_serialize(
            var_class=var_class,
            fields=fields,
            keywords=keywords,
            limit=limit,
            q=q,
            sort=sort,
            search_after=search_after,
            facet_fields=facet_fields,
            facet_limit=facet_limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdsProducts",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def class_list_without_preload_content(
        self,
        var_class: Annotated[StrictStr, Field(description="syntax: one of the allowable enum values  This is a shortcut for doing a query with ... ")],
        fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. ")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored ")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: limit=10  behavior: maximum number of matching results returned, for pagination ")] = None,
        q: Annotated[Optional[StrictStr], Field(description="syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present ")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="syntax: sort=field0,field1,...  behavior: currently only sorts ascending ")] = None,
        search_after: Annotated[Optional[List[StrictStr]], Field(description="syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time ")] = None,
        facet_fields: Annotated[Optional[List[StrictStr]], Field(description="syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" ")] = None,
        facet_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """returns all PDS products of the given PDS product class that meet all given constraints. 


        :param var_class: syntax: one of the allowable enum values  This is a shortcut for doing a query with ...  (required)
        :type var_class: str
        :param fields: syntax: fields=field1,field2,...  behavior: this parameter and the headder Accept: type determine what content is packaged for the result. While the types application/csv, application/kvp+json, and text/csv return only the fields requesteted, all of the other types have a minimal set of fields that must be returned. Duplicating a minimally required field in this parameter has not effect. The types vnd.nasa.pds.pds4+json and vnd.nasa.pds.pds4+xml have a complete set of fields that must be returned; meaning this parameter does not impact their content. When fields is not used, then the minimal set of fields, or all when minimal is an empty set, is returned.  notes: the blob fields are blocked unless specifically requrested and only for the */csv and application/kvp+csv types. 
        :type fields: List[str]
        :param keywords: syntax: keyword=keyword1,keyword2,...  behavior: free text search on title and description (if set q is ignored 
        :type keywords: List[str]
        :param limit: syntax: limit=10  behavior: maximum number of matching results returned, for pagination 
        :type limit: int
        :param q: syntax: q=\"vid eq 13.0\"  behavior: query uses eq,ne,gt,ge,lt,le,(,),not,and,or operators. Properties are named as in 'properties' attributes, literals are strings between quotes, like \"animal\", or numbers. Detailed query specification is available at https://bit.ly/3h3D54T  note: ignored when keyword is present 
        :type q: str
        :param sort: syntax: sort=field0,field1,...  behavior: currently only sorts ascending 
        :type sort: List[str]
        :param search_after: syntax: search-after=sortField0Value,sortField1Value,...  behavior: for each field specified in the \"sort\" qparam, specify the field value for the last result returned in the previous page   It is strongly recommended to use ops:Harvest_Info/ops:harvest_date_time as your final sort field, to ensure successful pagination.   Remember to url-encode special characters, ex. /products?limit=10&sort=ops%3AHarvest_Info%2Fops%3Aharvest_date_time 
        :type search_after: List[str]
        :param facet_fields: syntax: facet-fields=field1&facet-fields=field2...  behavior: Return bucket aggregations for each field specified, as part of the response.   The facet values and counts will be accessible via attribute \"bucket_by_$field\" 
        :type facet_fields: List[str]
        :param facet_limit: syntax: facet-limit=10  behavior: set the number n for which facets will return the n-most-populous buckets 
        :type facet_limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._class_list_serialize(
            var_class=var_class,
            fields=fields,
            keywords=keywords,
            limit=limit,
            q=q,
            sort=sort,
            search_after=search_after,
            facet_fields=facet_fields,
            facet_limit=facet_limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PdsProducts",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _class_list_serialize(
        self,
        var_class,
        fields,
        keywords,
        limit,
        q,
        sort,
        search_after,
        facet_fields,
        facet_limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields': 'multi',
            'keywords': 'multi',
            'sort': 'multi',
            'search-after': 'multi',
            'facet-fields': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if var_class is not None:
            _path_params['class'] = var_class
        # process the query parameters
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if search_after is not None:
            
            _query_params.append(('search-after', search_after))
            
        if facet_fields is not None:
            
            _query_params.append(('facet-fields', facet_fields))
            
        if facet_limit is not None:
            
            _query_params.append(('facet-limit', facet_limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/csv', 
                    'application/json', 
                    'application/kvp+json', 
                    'application/vnd.nasa.pds.pds4+json', 
                    'application/vnd.nasa.pds.pds4+xml', 
                    'application/xml', 
                    'text/csv', 
                    'text/html', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/classes/{class}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def classes(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """returns a list of the available PDS product class at this API. This is not all of the PDS product class available in the database, but simply the names that can be used in the /classes/{class} endpoints. 


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._classes_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def classes_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """returns a list of the available PDS product class at this API. This is not all of the PDS product class available in the database, but simply the names that can be used in the /classes/{class} endpoints. 


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._classes_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def classes_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """returns a list of the available PDS product class at this API. This is not all of the PDS product class available in the database, but simply the names that can be used in the /classes/{class} endpoints. 


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._classes_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
            '501': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _classes_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*', 
                    '*/*', 
                    'application/csv', 
                    'application/json', 
                    'application/kvp+json', 
                    'application/vnd.nasa.pds.pds4+json', 
                    'application/vnd.nasa.pds.pds4+xml', 
                    'application/xml', 
                    'text/csv', 
                    'text/html', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/classes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


