{
  "version": "1.0",
  "model_sequence": [
    {
      "type": "NodePoint",
      "data": {
        "name": "Point",
        "referenceCoordinates": "[L,0,0]",
        "initialCoordinates": "[u0,0,0]",
        "initialVelocities": "[v0,0,0]",
        "Vshow": true,
        "VdrawSize": -1.0,
        "Vcolor": [
          0.0,
          0.0,
          1.0,
          1.0
        ],
        "creationUID": "3c07928c-0266-4cee-bd75-f1e3dba9ca86",
        "objectType": "NodePoint",
        "summaryPythonCode": {
          "nodeType": "Point"
        },
        "objIndex": null,
        "returnValues": {
          "nodeNumber": 0
        },
        "returnInfo": "Vshow=True / isLegacy=True",
        "isLegacy": true,
        "nodeType": "Point"
      },
      "isLegacy": true,
      "summaryPythonCode": {
        "nodeType": "exu.NodeType.Point"
      }
    },
    {
      "type": "NodePointGround",
      "data": {
        "name": "PointGround",
        "referenceCoordinates": [
          0.0,
          0.0,
          0.0
        ],
        "Vshow": true,
        "VdrawSize": -1.0,
        "Vcolor": [
          0.5,
          0.5,
          0.5,
          1.0
        ],
        "creationUID": "183263bf-d251-488e-b1eb-bac357647422",
        "objectType": "NodePointGround",
        "summaryPythonCode": {
          "nodeType": "PointGround"
        },
        "objIndex": null,
        "returnValues": {
          "nodeNumber": 1
        },
        "returnInfo": "Vshow=True / isLegacy=True",
        "isLegacy": true,
        "nodeType": "PointGround"
      },
      "isLegacy": true,
      "summaryPythonCode": {
        "nodeType": "exu.NodeType.PointGround"
      }
    },
    {
      "type": "ObjectMassPoint",
      "data": {
        "name": "MassPoint",
        "objectType": "ObjectMassPoint",
        "physicsMass": "mass",
        "nodeNumber": 0,
        "Vshow": true,
        "VgraphicsData": [
          {
            "name": "Sphere",
            "args": "point=[0.0, 0.0, 0.0], radius=0.1, color=[0.0, 0.0, 1.0, 1.0], nTiles=8, addEdges=False, edgeColor=[0.0, 0.0, 0.0, 1.0], addFaces=True"
          }
        ],
        "objIndex": 0,
        "returnInfo": "nodeNumber=0 / Vshow=True",
        "returnValues": {
          "objectNumber": 0
        },
        "summaryPythonCode": {
          "VgraphicsData": [
            "Sphere(point=[0.0, 0.0, 0.0], radius=0.1, color=[0.0, 0.0, 1.0, 1.0], nTiles=8, addEdges=False, edgeColor=[0.0, 0.0, 0.0, 1.0], addFaces=True)"
          ]
        }
      },
      "isLegacy": true
    },
    {
      "type": "MarkerNodeCoordinate",
      "data": {
        "name": "NodeCoordinate",
        "nodeNumber": 0,
        "coordinate": 0,
        "Vshow": true,
        "creationUID": "49f9462d-55b4-488f-866e-8b8896a2bb87",
        "objectType": "MarkerNodeCoordinate",
        "objIndex": 0,
        "returnValues": {
          "markerNumber": 0
        },
        "returnInfo": "nodeNumber=0 / coordinate=0 / Vshow=True / isLegacy=True",
        "isLegacy": true,
        "markerType": "NodeCoordinate"
      },
      "isLegacy": true
    },
    {
      "type": "MarkerNodeCoordinate",
      "data": {
        "name": "NodeCoordinate2",
        "nodeNumber": 1,
        "coordinate": 0,
        "Vshow": true,
        "creationUID": "861b6ffc-e5d2-4ab1-8a92-d95be5cc6368",
        "objectType": "MarkerNodeCoordinate",
        "objIndex": 1,
        "returnValues": {
          "markerNumber": 1
        },
        "returnInfo": "nodeNumber=1 / coordinate=0 / Vshow=True / isLegacy=True",
        "isLegacy": true,
        "markerType": "NodeCoordinate"
      },
      "isLegacy": true
    },
    {
      "type": "ObjectConnectorCoordinateSpringDamper",
      "data": {
        "name": "ConnectorCoordinateSpringDamper",
        "objectType": "ObjectConnectorCoordinateSpringDamper",
        "markerNumbers": [
          0,
          1
        ],
        "stiffness": 4000,
        "damping": 8,
        "offset": 0.5,
        "activeConnector": true,
        "springForceUserFunction": 0,
        "Vshow": true,
        "VdrawSize": -1.0,
        "Vcolor": [
          0.0,
          0.0,
          1.0,
          1.0
        ],
        "objIndex": null,
        "returnInfo": "stiffness=4000 / damping=8 / activeConnector=True / springForceUserFunction=0 / Vshow=True",
        "returnValues": {
          "objectNumber": 1
        }
      },
      "isLegacy": true,
      "summaryPythonCode": {
        "springForceUserFunction": "0"
      }
    },
    {
      "type": "LoadCoordinate",
      "data": {
        "name": "Coordinate",
        "loadType": "Coordinate",
        "markerNumber": 0,
        "load": "f",
        "loadUserFunction": 0,
        "Vshow": true,
        "creationUID": "93ccf726-152b-457c-9a0b-3b5ca5e244d1",
        "objectType": "LoadCoordinate",
        "objIndex": 0,
        "returnValues": {
          "loadNumber": 0
        },
        "returnInfo": "markerNumber=0 / loadUserFunction=0 / Vshow=True / isLegacy=True",
        "isLegacy": true
      },
      "isLegacy": true,
      "summaryPythonCode": {
        "loadUserFunction": "0"
      }
    }
  ],
  "user_variables": {
    "L": 0.5,
    "mass": 1.6,
    "spring": 4000,
    "damper": 8,
    "f": 80,
    "u0": -0.08,
    "v0": 1,
    "x0": 0.02
  },
  "python_files": {
    "userVariables.py": "L=0.5 #reference position of mass\nmass = 1.6 #mass in kg\nspring = 4000 #stiffness of spring-damper in N/m\ndamper = 8 #damping constant in N/(m/s)\nf =80 #force on mass\nu0=-0.08 #initial displacement\nv0=1 #initial velocity\nx0=f/spring #static displacement",
    "userFunctions.py": "# -*- coding: utf-8 -*-\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n# This is part of the Exudyn GUI project\n#\n# Filename: functions/userFunctions.py\n#\n# Description:\n#     Contains user-defined Python functions (UF*) for use in the Exudyn GUI.\n#     These functions can be assigned to fields like load, offset, or sensor\n#     callbacks and are dynamically loaded by the GUI at startup.\n#\n# Authors:  Michael Pieber\n# Date:     2025-05-12\n# Notes:    Extend this file with additional UF* functions as needed.\n#\n# License:  BSD-3 license\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\ndef UFload(mbs, t, load):\n    import numpy as np\n    return [100* np.sin(10 * (2*np.pi) * t),0,0]\n\ndef UFspringForce(mbs, t, load):\n    import numpy as np\n    return [100* np.sin(10 * (2*np.pi) * t),0,0]\n\nuserFunctions = {\n    \"UFload\": UFload,\n    \"UFspringForce\": UFspringForce,\n}",
    "inertiaDefinitions.py": "# -*- coding: utf-8 -*-\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n# This is part of the Exudyn GUI project\n#\n# Filename: functions/inertiaDefinitions.py\n#\n# Description:\n#     Contains user-defined Python functions (UF*) for use in the Exudyn GUI.\n#     These functions can be assigned to fields like load, offset, or sensor\n#     callbacks and are dynamically loaded by the GUI at startup.\n#\n# Authors:  Michael Pieber\n# Date:     2025-05-12\n# Notes:    Extend this file with additional UF* functions as needed.\n#\n# License:  BSD-3 license\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\ninertiaRegistry = {\n    \"InertiaSphere\": {\n        \"name\": \"InertiaSphere\",\n        \"args\": \"mass=1.0, radius=0.1\"\n    },\n    \"InertiaMassPoint\": {\n        \"name\": \"InertiaMassPoint\",\n        \"args\": \"mass=1\"\n    },\n}",
    "graphicsVisualizations.py": "# -*- coding: utf-8 -*-\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n# This is part of the Exudyn GUI project\n#\n# Filename: functions/graphicsVisualizations.py\n#\n# Description:\n#     Stores default graphicsData configurations used by the Exudyn GUI.\n#     Each entry corresponds to a specific Create* or Add* constructor and\n#     provides default visual representations (e.g., spheres, checkerboards).\n#     These settings are editable in the GUI and restored when reloading items.\n#\n# Authors:  Michael Pieber\n# Date:     2025-05-12\n# Notes:    Automatically updated when users add or edit visualizations.\n#\n# License:  BSD-3 license\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\ngraphicsDataRegistry = {\n    'CreateGround': [],\n    'CreateMassPoint':  [],\n    'CreateForce': [],\n    'CreateCartesianSpringDamper': [],\n    'CreateRevoluteJoint': [],\n    'CreateRigidBody':  [],\n    'CreateRigidBodySpringDamper': [],\n    'CreateTorque': [],\n    'CreatePrismaticJoint': [],\n    'NodePoint': [],\n    'ObjectGround': [],\n    'Node1D': [],\n    'NodePoint2D': [],\n    'ObjectMassPoint': [],\n    'CreateGenericJoint': [],\n    'NodePointGround': [],\n    'MarkerNodeCoordinate': [],\n    'ObjectConnectorCoordinateSpringDamper': [],\n    'LoadCoordinate': [],\n    'LoadForceVector': [],\n}\n",
    "flexibleBody.py": "# -*- coding: utf-8 -*-\n\"\"\"\nFlexible Body (FEM/FFRF) utilities for Exudyn GUI\n\nThis module provides functions to:\n- Generate or import a mesh (Netgen/NGsolve)\n- Set up FEMinterface and compute modes\n- Create FFRF/CMS elements and add them to an Exudyn system\n- Keep all FEM/FFRF logic separate from the main GUI\n\nUsage:\n    from functions.flexibleBody import create_flexible_body_from_ngsolve\n    fem_result = create_flexible_body_from_ngsolve(params)\n    # fem_result contains fem, objFFRF, markers, sensors, etc.\n\nAuthor: GitHub Copilot\nDate: 2025-06-06\n\"\"\"\n\nimport exudyn as exu\nimport numpy as np\n\n# Optional: Only import these if available\ntry:\n    import ngsolve as ngs\n    from netgen.csg import CSGeometry, OrthoBrick, Pnt\nexcept ImportError:\n    ngs = None\n    CSGeometry = OrthoBrick = Pnt = None\n\nfrom exudyn.FEM import FEMinterface, HCBstaticModeSelection, KirchhoffMaterial\n\n\ndef create_flexible_body_from_ngsolve(\n    mbs,\n    a=0.025,\n    L=1.0,\n    h=0.5*0.025,\n    nModes=8,\n    rho=1000,\n    Emodulus=1e8,\n    nu=0.3,\n    meshOrder=1,\n    useGraphics=True,\n    computeStressModes=True,\n    boundaryPlane='left',\n    verbose=True\n):\n    \"\"\"\n    Create a flexible body (CMS/FFRF) from a simple brick mesh using Netgen/NGsolve.\n    Returns a dict with fem, objFFRF, markers, sensors, etc.\n    \"\"\"\n    if ngs is None:\n        raise ImportError(\"ngsolve and netgen must be installed for flexible body support.\")\n\n    # --- Mesh generation ---\n    geo = CSGeometry()\n    block = OrthoBrick(Pnt(0, -a, -a), Pnt(L, a, a))\n    geo.Add(block)\n    mesh = ngs.Mesh(geo.GenerateMesh(maxh=h))\n    mesh.Curve(1)\n\n    # --- FEM import ---\n    fem = FEMinterface()\n    fem.ImportMeshFromNGsolve(mesh, density=rho, youngsModulus=Emodulus, poissonsRatio=nu, meshOrder=meshOrder)\n\n    # --- Boundary nodes for HCB ---\n    pLeft = [0, -a, -a]\n    nodesLeftPlane = fem.GetNodesInPlane(pLeft, [-1, 0, 0])\n    weightsLeftPlane = fem.GetNodeWeightsFromSurfaceAreas(nodesLeftPlane)\n    boundaryList = [nodesLeftPlane]\n\n    if verbose:\n        debugLog(\"nNodes=\", fem.NumberOfNodes())\n        debugLog(\"compute HCB modes... \")\n    fem.ComputeHurtyCraigBamptonModes(\n        boundaryNodesList=boundaryList,\n        nEigenModes=nModes,\n        useSparseSolver=True,\n        computationMode=HCBstaticModeSelection.RBE2\n    )\n\n    # --- Optional: Compute stress modes ---\n    # Disabled due to NGSolve mesh 'ndof' attribute error in some versions\n    # if computeStressModes:\n    #     mat = KirchhoffMaterial(Emodulus, nu, rho)\n    #     varType = exu.OutputVariableType.StressLocal\n    #     if verbose:\n    #         print(\"ComputePostProcessingModes ... (may take a while)\")\n    #     fem.ComputePostProcessingModesNGsolve(mesh, material=mat, outputVariableType=varType)\n\n    # --- Create CMS element ---\n    cms = exu.FEM.ObjectFFRFreducedOrderInterface(fem)\n    objFFRF = cms.AddObjectFFRFreducedOrder(\n        mbs,\n        positionRef=[0, 0, 0],\n        initialVelocity=[0, 0, 0],\n        initialAngularVelocity=[0, 0, 0],\n        gravity=[0, -9.81, 0],\n        color=[0.1, 0.9, 0.1, 1.]\n    )\n\n    # --- Add markers and joints ---\n    mRB = mbs.AddMarker({'markerType': 'NodeRigid', 'nodeNumber': objFFRF['nRigidBody']})\n    oGround = mbs.AddObject({'objectType': 'Ground', 'referencePosition': [0, 0, 0]})\n    leftMidPoint = [0, 0, 0]\n    mGround = mbs.AddMarker({'markerType': 'BodyRigid', 'bodyNumber': oGround, 'localPosition': leftMidPoint})\n    mLeft = mbs.AddMarker({'markerType': 'SuperElementRigid',\n        'bodyNumber': objFFRF['oFFRFreducedOrder'],\n        'meshNodeNumbers': list(nodesLeftPlane),\n        'weightingFactors': weightsLeftPlane,\n        'offset': [0, 0, 0]\n    })\n    mbs.AddObject({'objectType': 'GenericJoint',\n        'markerNumbers': [mGround, mLeft],\n        'constrainedAxes': [1, 1, 1, 1, 1, 0],\n        'visualization': {'axesRadius': 0.1*a, 'axesLength': 0.1*a}\n    })\n\n    # --- Add sensor ---\n    nTip = fem.GetNodeAtPoint([L, -a, -a])\n    fileDir = 'solution/'\n    sensTipDispl = mbs.AddSensor({'sensorType': 'SuperElement',\n        'bodyNumber': objFFRF['oFFRFreducedOrder'],\n        'meshNodeNumber': nTip,\n        'fileName': fileDir + f'nMidDisplacementCMS{nModes}Test.txt',\n        'outputVariableType': exu.OutputVariableType.Displacement\n    })\n\n    # --- Return all relevant objects ---\n    return {\n        'fem': fem,\n        'objFFRF': objFFRF,\n        'markers': {\n            'mRB': mRB,\n            'mGround': mGround,\n            'mLeft': mLeft\n        },\n        'oGround': oGround,\n        'sensor': sensTipDispl\n    }\n"
  },
  "metadata": {
    "created": "2025-06-17T23:49:42.417802",
    "description": "Exudyn GUI Complete Project"
  }
}