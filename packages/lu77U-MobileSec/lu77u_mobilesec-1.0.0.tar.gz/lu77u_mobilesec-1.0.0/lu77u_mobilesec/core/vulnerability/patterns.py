#!/usr/bin/env python3
"""
Vulnerability Patterns

Provides pattern-based vulnerability scanning for different frameworks.
"""

import re
import os
from typing import Dict, List, Optional, Any
from ...constants.vulnerabilities import VULNERABILITY_KEYWORDS
from ...constants.severity_levels import SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_LOW


def scan_flutter_vulnerabilities(flutter_assets: Dict[str, Any]) -> List[Dict]:
    """Scan Flutter assets for known vulnerability patterns"""
    try:
        vulnerabilities = []
        
        # Flutter-specific vulnerability patterns
        flutter_patterns = {
            # Network Security Issues
            'http_usage': {
                'pattern': r'http://[^\s\'"]+',
                'severity': SEVERITY_MEDIUM,
                'title': 'HTTP Usage Detected',
                'description': 'Application uses HTTP instead of HTTPS for network communication',
                'recommendation': 'Use HTTPS for all network communications to ensure data encryption'
            },
            'hardcoded_urls': {
                'pattern': r'(?:http|https)://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}[^\s\'"]*',
                'severity': SEVERITY_LOW,
                'title': 'Hardcoded URL',
                'description': 'Hardcoded URLs found in the application',
                'recommendation': 'Consider using configuration files or environment variables for URLs'
            },
            
            # Authentication Issues
            'hardcoded_passwords': {
                'pattern': r'(?:password|passwd|pwd)\s*[:=]\s*["\'][^"\']{4,}["\']',
                'severity': SEVERITY_HIGH,
                'title': 'Hardcoded Password',
                'description': 'Hardcoded password found in the application',
                'recommendation': 'Never hardcode passwords. Use secure storage mechanisms'
            },
            'hardcoded_api_keys': {
                'pattern': r'(?:api[_-]?key|apikey|access[_-]?token)\s*[:=]\s*["\'][^"\']{10,}["\']',
                'severity': SEVERITY_HIGH,
                'title': 'Hardcoded API Key',
                'description': 'Hardcoded API key or access token found',
                'recommendation': 'Store API keys securely and never hardcode them in source code'
            },
            
            # Data Storage Issues
            'shared_preferences': {
                'pattern': r'SharedPreferences\.[gs]et(?:String|Int|Bool|Float|Long)\s*\([^)]*(?:password|token|key|secret)[^)]*\)',
                'severity': SEVERITY_MEDIUM,
                'title': 'Sensitive Data in SharedPreferences',
                'description': 'Sensitive data stored in SharedPreferences without encryption',
                'recommendation': 'Encrypt sensitive data before storing in SharedPreferences'
            },
            'sqlite_injection': {
                'pattern': r'(?:rawQuery|execSQL)\s*\([^)]*\+[^)]*\)',
                'severity': SEVERITY_HIGH,
                'title': 'Potential SQL Injection',
                'description': 'SQL query with string concatenation detected',
                'recommendation': 'Use parameterized queries to prevent SQL injection'
            },
            
            # Cryptography Issues
            'weak_encryption': {
                'pattern': r'(?:DES|MD5|SHA1)(?:CryptoJS|\.digest)',
                'severity': SEVERITY_HIGH,
                'title': 'Weak Cryptographic Algorithm',
                'description': 'Weak cryptographic algorithm detected',
                'recommendation': 'Use strong cryptographic algorithms like AES-256, SHA-256 or higher'
            },
            'hardcoded_encryption_keys': {
                'pattern': r'(?:encryption[_-]?key|secret[_-]?key)\s*[:=]\s*["\'][^"\']{8,}["\']',
                'severity': SEVERITY_HIGH,
                'title': 'Hardcoded Encryption Key',
                'description': 'Hardcoded encryption key found',
                'recommendation': 'Generate and store encryption keys securely, never hardcode them'
            },
            
            # Input Validation Issues
            'webview_security': {
                'pattern': r'WebView.*setJavaScriptEnabled\(true\)',
                'severity': SEVERITY_MEDIUM,
                'title': 'WebView JavaScript Enabled',
                'description': 'WebView has JavaScript enabled which may lead to XSS attacks',
                'recommendation': 'Disable JavaScript in WebView unless necessary, validate all content'
            },
            'file_access': {
                'pattern': r'setAllowFileAccess\(true\)',
                'severity': SEVERITY_MEDIUM,
                'title': 'WebView File Access Enabled',
                'description': 'WebView allows file access which may lead to local file inclusion',
                'recommendation': 'Disable file access in WebView unless absolutely necessary'
            },
            
            # Debug/Development Issues
            'debug_logs': {
                'pattern': r'(?:print|debugPrint|log)\s*\([^)]*(?:password|token|key|secret|credit)[^)]*\)',
                'severity': SEVERITY_MEDIUM,
                'title': 'Sensitive Data in Debug Logs',
                'description': 'Sensitive information may be logged in debug output',
                'recommendation': 'Remove or sanitize debug logs containing sensitive data'
            },
            'assert_statements': {
                'pattern': r'assert\s*\([^)]*(?:password|token|key|secret)[^)]*\)',
                'severity': SEVERITY_LOW,
                'title': 'Sensitive Data in Assert',
                'description': 'Assert statements may expose sensitive data in debug builds',
                'recommendation': 'Avoid using sensitive data in assert statements'
            },
            
            # Platform Channel Security
            'platform_channel': {
                'pattern': r'MethodChannel\s*\([^)]*\)\.invokeMethod\s*\([^)]*\)',
                'severity': SEVERITY_LOW,
                'title': 'Platform Channel Usage',
                'description': 'Platform channel communication detected',
                'recommendation': 'Ensure platform channel methods validate input and handle errors securely'
            },
        }
        
        # Scan Dart code files
        dart_files = flutter_assets.get('dart_files', {})
        for file_path, content in dart_files.items():
            vulnerabilities.extend(_scan_content_for_patterns(
                content, flutter_patterns, file_path, 'Dart'
            ))
        
        # Scan pubspec.yaml for dependency vulnerabilities
        pubspec_content = flutter_assets.get('pubspec_content', '')
        if pubspec_content:
            dep_vulns = _scan_flutter_dependencies(pubspec_content)
            vulnerabilities.extend(dep_vulns)
        
        # Scan configuration files
        config_files = flutter_assets.get('config_files', {})
        for file_path, content in config_files.items():
            vulnerabilities.extend(_scan_content_for_patterns(
                content, flutter_patterns, file_path, 'Config'
            ))
        
        # Scan asset files for sensitive data
        asset_files = flutter_assets.get('asset_files', {})
        # Support both dict and list for asset_files
        if isinstance(asset_files, dict):
            for file_path, content in asset_files.items():
                if isinstance(content, str):  # Only scan text files
                    vulnerabilities.extend(_scan_content_for_patterns(
                        content, flutter_patterns, file_path, 'Asset'
                    ))
        elif isinstance(asset_files, list):
            for asset in asset_files:
                # asset is a dict with 'path' and 'size', no content to scan
                continue
        
        return vulnerabilities
        
    except Exception as e:
        print(f"❌ Error scanning Flutter vulnerabilities: {e}")
        return []


def _scan_content_for_patterns(
    content: str, 
    patterns: Dict[str, Dict], 
    file_path: str, 
    file_type: str
) -> List[Dict]:
    """Scan content for vulnerability patterns"""
    try:
        vulnerabilities = []
        
        for pattern_name, pattern_info in patterns.items():
            pattern = pattern_info['pattern']
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                # Find line number
                line_num = content[:match.start()].count('\n') + 1
                
                # Get context (line with match)
                lines = content.split('\n')
                context_line = lines[line_num - 1] if line_num <= len(lines) else ""
                
                vulnerability = {
                    'title': pattern_info['title'],
                    'severity': pattern_info['severity'],
                    'description': pattern_info['description'],
                    'location': f"{file_path}:{line_num}",
                    'file_type': file_type,
                    'pattern': pattern_name,
                    'matched_text': match.group(0),
                    'context': context_line.strip(),
                    'impact': f"Potential security vulnerability in {file_type.lower()} file",
                    'recommendation': pattern_info['recommendation'],
                    'code': f"Line {line_num}: {context_line.strip()}"
                }
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
        
    except Exception as e:
        print(f"❌ Error scanning content patterns: {e}")
        return []


def _scan_flutter_dependencies(pubspec_content: str) -> List[Dict]:
    """Scan Flutter dependencies for known vulnerabilities"""
    try:
        vulnerabilities = []
        
        # Known vulnerable Flutter packages (example list)
        vulnerable_packages = {
            'http': {
                'vulnerable_versions': ['<0.13.0'],
                'severity': SEVERITY_MEDIUM,
                'description': 'Older versions of http package may have security issues',
                'recommendation': 'Update to latest version of http package'
            },
            'shared_preferences': {
                'vulnerable_versions': ['<2.0.0'],
                'severity': SEVERITY_LOW,
                'description': 'Older versions may not have proper encryption support',
                'recommendation': 'Update to latest version and ensure data encryption'
            },
            'webview_flutter': {
                'vulnerable_versions': ['<3.0.0'],
                'severity': SEVERITY_MEDIUM,
                'description': 'Older versions may have WebView security issues',
                'recommendation': 'Update to latest version with security fixes'
            }
        }
        
        # Parse dependencies
        lines = pubspec_content.split('\n')
        in_dependencies = False
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            
            if line.startswith('dependencies:'):
                in_dependencies = True
                continue
            elif line.startswith(('dev_dependencies:', 'flutter:')):
                in_dependencies = False
                continue
            
            if in_dependencies and ':' in line and not line.startswith('#'):
                # Parse dependency line
                parts = line.split(':')
                if len(parts) >= 2:
                    package_name = parts[0].strip()
                    version_info = ':'.join(parts[1:]).strip()
                    
                    # Check if package is in vulnerable list
                    if package_name in vulnerable_packages:
                        vuln_info = vulnerable_packages[package_name]
                        
                        vulnerability = {
                            'title': f'Potentially Vulnerable Dependency: {package_name}',
                            'severity': vuln_info['severity'],
                            'description': f"Dependency '{package_name}' may have known vulnerabilities. {vuln_info['description']}",
                            'location': f"pubspec.yaml:{line_num}",
                            'file_type': 'Dependencies',
                            'package': package_name,
                            'version': version_info,
                            'impact': 'May introduce security vulnerabilities through dependencies',
                            'recommendation': vuln_info['recommendation'],
                            'code': f"Line {line_num}: {line}"
                        }
                        
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities
        
    except Exception as e:
        print(f"❌ Error scanning Flutter dependencies: {e}")
        return []


def scan_react_native_vulnerabilities(assets: Dict[str, Any]) -> List[Dict]:
    """Scan React Native assets for vulnerabilities (placeholder)"""
    # This would implement React Native specific patterns
    return []


def scan_java_kotlin_vulnerabilities(assets: Dict[str, Any]) -> List[Dict]:
    """Scan Java/Kotlin assets for vulnerabilities (placeholder)"""
    # This would implement Java/Kotlin specific patterns
    return []


def get_pattern_info(pattern_name: str, framework: str = 'flutter') -> Optional[Dict]:
    """Get information about a specific vulnerability pattern"""
    try:
        # This would return detailed information about vulnerability patterns
        # for documentation or analysis purposes
        return None
    except Exception as e:
        print(f"❌ Error getting pattern info: {e}")
        return None


def scan_blutter_decompiled_vulnerabilities(blutter_files: Dict[str, Any]) -> List[Dict]:
    """Scan Blutter decompiled files (main.dart, objs.txt, pp.txt) for explicit vulnerabilities"""
    vulnerabilities = []
    # 1. AndroidManifest.xml: check for debuggable, allowBackup, exported, cleartext, etc.
    manifest_content = blutter_files.get('manifest_content') or blutter_files.get('AndroidManifest.xml')
    if manifest_content:
        # Debuggable
        if 'android:debuggable="true"' in manifest_content:
            vulnerabilities.append({
                'title': 'App is Debuggable',
                'severity': SEVERITY_HIGH,
                'description': 'android:debuggable="true" found in AndroidManifest.xml',
                'location': 'AndroidManifest.xml',
                'file_type': 'Manifest',
                'pattern': 'debuggable',
                'matched_text': 'android:debuggable="true"',
                'impact': 'App can be debugged in production, increasing risk of reverse engineering.',
                'recommendation': 'Remove android:debuggable="true" for production builds.',
                'code': 'android:debuggable="true"'
            })
        # AllowBackup
        if 'android:allowBackup="true"' in manifest_content:
            vulnerabilities.append({
                'title': 'App Data Backup Enabled',
                'severity': SEVERITY_MEDIUM,
                'description': 'android:allowBackup="true" found in AndroidManifest.xml',
                'location': 'AndroidManifest.xml',
                'file_type': 'Manifest',
                'pattern': 'allowBackup',
                'matched_text': 'android:allowBackup="true"',
                'impact': 'App data can be backed up and restored, which may leak sensitive data.',
                'recommendation': 'Set android:allowBackup="false" unless backup is required.',
                'code': 'android:allowBackup="true"'
            })
        # usesCleartextTraffic
        if 'android:usesCleartextTraffic="true"' in manifest_content:
            vulnerabilities.append({
                'title': 'Cleartext Traffic Allowed',
                'severity': SEVERITY_HIGH,
                'description': 'android:usesCleartextTraffic="true" found in AndroidManifest.xml',
                'location': 'AndroidManifest.xml',
                'file_type': 'Manifest',
                'pattern': 'usesCleartextTraffic',
                'matched_text': 'android:usesCleartextTraffic="true"',
                'impact': 'App allows unencrypted network traffic.',
                'recommendation': 'Set android:usesCleartextTraffic="false" for production.',
                'code': 'android:usesCleartextTraffic="true"'
            })
    # 2. main.dart, objs.txt, pp.txt: base64, hex, suspicious strings
    for fname in ['main_dart', 'objs_content', 'pp_content']:
        content = blutter_files.get(fname)
        if not content:
            continue
        # Base64
        vulnerabilities.extend(detect_base64text(content, fname))
        # Hex
        vulnerabilities.extend(detect_hex(content, fname))
        # Suspicious string: _getNativeField, native peer, etc.
        for match in re.finditer(r'_getNativeField|native peer', content, re.IGNORECASE):
            vulnerabilities.append({
                'title': 'Suspicious Native Access',
                'severity': SEVERITY_LOW,
                'description': 'Suspicious native access string found.',
                'location': fname,
                'file_type': 'Blutter',
                'pattern': 'native_access',
                'matched_text': match.group(0),
                'impact': 'May indicate unsafe native code interaction.',
                'recommendation': 'Review native code usage for safety.',
                'code': match.group(0)
            })
    return vulnerabilities


def detect_base64text(content: str, location: str) -> List[Dict]:
    """Detect base64-encoded secrets in a given text content."""
    results = []
    for match in re.finditer(r'"([A-Za-z0-9+/]{32,}={0,2})"', content):
        results.append({
            'title': 'Potential Base64-encoded Secret',
            'severity': 'MEDIUM',
            'description': 'Base64-encoded string found, may be a secret or credential.',
            'location': location,
            'file_type': 'Blutter',
            'pattern': 'base64',
            'matched_text': match.group(1),
            'impact': 'May indicate hardcoded secrets or credentials.',
            'recommendation': 'Review and remove hardcoded secrets.',
            'code': match.group(0)
        })
    return results


def detect_hex(content: str, location: str) -> List[Dict]:
    """Detect hex-encoded secrets in a given text content."""
    results = []
    for match in re.finditer(r'"([0-9a-fA-F]{32,})"', content):
        results.append({
            'title': 'Potential Hex-encoded Secret',
            'severity': 'MEDIUM',
            'description': 'Hex-encoded string found, may be a secret or credential.',
            'location': location,
            'file_type': 'Blutter',
            'pattern': 'hex',
            'matched_text': match.group(1),
            'impact': 'May indicate hardcoded secrets or credentials.',
            'recommendation': 'Review and remove hardcoded secrets.',
            'code': match.group(0)
        })
    return results
