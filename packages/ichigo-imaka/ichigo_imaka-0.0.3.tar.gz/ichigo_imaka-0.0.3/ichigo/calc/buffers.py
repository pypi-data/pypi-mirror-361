"""Helper functions for generating playback and slope offset buffers.
"""

import numpy as np
from astropy.io import fits
from numpy.typing import NDArray

from ichigo.config import SETTINGS

def trapezoid_wave(t: float, freq: float, amp: float, shift: float, phase: float, ramp_size: float) -> float:
    """Returns a trapezoid wave. This function can be used to generate a square and triangle wave.

    Parameters
    ----------
    t: float
        Time to evaluate at.
    freq: float
        Frequency of the wave in units of 1 / t.
    amp: float
        Amplitude.
    shift: float
        Vertical offset.
    phase: float
        Phase in radians.
    ramp_size: float
        Length of the ramp in seconds.

    Returns
    -------
    out: float
        Trapezoid wave evaluated at t.
    """
    
    assert ramp_size >= 0, "ramp_size must be greater than or equal to zero"
    assert ramp_size <= 1 / (2*freq), "ramp_size must be less than or equal to half the period"

    # apply phase shift
    dt = phase / (2 * np.pi * freq)
    t += dt
    t = t % (1 / freq)

    t_qt = 1 / (4*freq)  # quarter frequency location
    t_bounds = np.array([
        t_qt   - ramp_size / 2,
        t_qt   + ramp_size / 2,
        3*t_qt - ramp_size / 2,
        3*t_qt + ramp_size / 2
    ])
    
    # Ramp going down
    if t_bounds[0] < t < t_bounds[1]:
        slope = -amp / (t_bounds[1] - t_qt)
        y0 = -slope * t_qt
        return slope * t + y0 + shift
        
    # Ramp going up
    if t_bounds[2] < t < t_bounds[3]:
        slope = amp / (t_bounds[3] - 3*t_qt)
        y0 = -slope * 3*t_qt
        return slope * t + y0 + shift
        
    # - Amp
    if t_bounds[1] <= t <= t_bounds[2]:
        return -amp + shift
        
    # + Amp
    return amp + shift

def square_wave(t: float, freq: float, amp: float, shift: float, phase: float) -> float:
    """Returns a square wave. Wrapper for trapezoid_wave with ramp_size = 0.
    
    Parameters
    ----------
    See trapezoid_wave().
    """
    return trapezoid_wave(t, freq, amp, shift, phase, ramp_size=0)

def triangle_wave(t: float, freq: float, amp: float, shift: float, phase: float) -> float:
    """Returns a triangle wave. Wrapper for trapezoid_wave with
    ramp_size = 1 / (2*freq).
    
    Parameters
    ----------
    See trapezoid_wave().
    """
    return trapezoid_wave(t, freq, amp, shift, phase, ramp_size=1 / (2*freq))

def cosine_wave(t: float | NDArray, freq: float, amp: float, shift: float, phase: float) -> float | NDArray:
    """Returns a cosine wave.
    
    Parameters
    ----------
    See trapezoid_wave().
    """
    return amp * np.cos(2*np.pi*freq*t + phase) + shift

def make_modal_slope_offsets(waveform: str, basis: str, mode_idx: int,
                        freq: float, amp: float, shift: float, phase: float,
                        length: float | None = None, fn_out: str | None = None,
                        **kwargs) -> NDArray:
    """Creates a slope offset buffer.

    Parameters
    ----------
    waveform: str
        Type of waveform to generate. Options are "trapezoid", "square", "triangle", or "cosine".
    basis: str
        Modal basis to use for the slopes. Options are "zernike" or "mirror".
    mode_idx: int
        Index of the mode to modulate.
    freq: float
        Frequency of the modulation in units of 1 / t.
    amp: float
        Amplitude of the modulation.
    shift: float
        Vertical offset.
    length: float or None, optional
        Length of the buffer. If None, defaults to 1 / freq so that the buffer is
        periodic.
    fn_out: str or None, optional
        File name to save to. If None, the file will not be saved.
    **kwargs: dict
        Additional keyword arguments to pass to the waveform function.
    
    Returns
    -------
    slopes: NDArray of shape (Nsamp, Nslopes)
        Slopes generated by the buffer where Nsamp is the number steps in the loop
        and Nslopes is the number slopes.
    """
    
    # The waveform determines how the coefficients will be modulated.
    match waveform:
        case "trapezoid":
            wave_func = trapezoid_wave
        case "square":
            wave_func = square_wave
        case "triangle":
            wave_func = triangle_wave
        case "cosine":
            wave_func = cosine_wave
        case _:
            raise ValueError(f"Unknown buffer type: {waveform}")
    
    match basis:
        case "zernike":
            m2s = fits.getdata( SETTINGS["RESOURCES"]["z2slopes"] )
        case "mirror":
            m2s = fits.getdata( SETTINGS["RESOURCES"]["mm2s"] )
        case _:
            raise ValueError(f"Modal basis {basis} is not defined.")
    loop_rate = SETTINGS["AO"]["loop_rate"]
    
    t_end = length or 1 / freq
    ts = np.arange(0, t_end, 1/loop_rate)
    Nsamp = len(ts)
    Nmodes = m2s.shape[1]

    coeffs = np.zeros( (Nmodes, Nsamp) )
    coeffs[mode_idx] = wave_func(ts, freq, amp, shift, phase, **kwargs)

    slopes = np.dot(m2s, coeffs).T
    
    if fn_out:
        hdu = fits.PrimaryHDU(slopes)
        hdu.header["SHAPE"] = waveform
        hdu.header["AMP"] = amp
        hdu.header["SHIFT"] = shift
        hdu.header["PHASE"] = phase
        hdu.header["BASIS"] = basis
        hdu.header["MODEIDX"] = mode_idx
        hdu.writeto(fn_out, overwrite=True)

    return slopes