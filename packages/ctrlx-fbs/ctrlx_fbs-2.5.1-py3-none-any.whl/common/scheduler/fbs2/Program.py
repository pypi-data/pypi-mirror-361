# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs2

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Composition of callables executed by the task in given sequence
class Program(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Program()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsProgram(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Program
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Task configuration which executes the program
    # Program
    def Task(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from common.scheduler.fbs.Task import Task
            obj = Task()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Composition of callables, executes jobs defined by regarding apps
    # Program
    def Callables(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from common.scheduler.fbs.Callable import Callable
            obj = Callable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def CallablesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def CallablesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Configuration of task watchdog
    # Program
    def Watchdog(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from common.scheduler.watchdog.fbs.Watchdog import Watchdog
            obj = Watchdog()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Call sequence of callables within the program [0-9]+
    # Program
    def Sequence(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Program
    def SequenceLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def SequenceIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ProgramStart(builder): builder.StartObject(4)
def Start(builder):
    return ProgramStart(builder)
def ProgramAddTask(builder, task): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(task), 0)
def AddTask(builder, task):
    return ProgramAddTask(builder, task)
def ProgramAddCallables(builder, callables): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(callables), 0)
def AddCallables(builder, callables):
    return ProgramAddCallables(builder, callables)
def ProgramStartCallablesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartCallablesVector(builder, numElems):
    return ProgramStartCallablesVector(builder, numElems)
def ProgramAddWatchdog(builder, watchdog): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(watchdog), 0)
def AddWatchdog(builder, watchdog):
    return ProgramAddWatchdog(builder, watchdog)
def ProgramAddSequence(builder, sequence): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(sequence), 0)
def AddSequence(builder, sequence):
    return ProgramAddSequence(builder, sequence)
def ProgramStartSequenceVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartSequenceVector(builder, numElems):
    return ProgramStartSequenceVector(builder, numElems)
def ProgramEnd(builder): return builder.EndObject()
def End(builder):
    return ProgramEnd(builder)
import common.scheduler.fbs.Callable
import common.scheduler.fbs.Task
import common.scheduler.watchdog.fbs.Watchdog
try:
    from typing import List, Optional
except:
    pass

class ProgramT(object):

    # ProgramT
    def __init__(self):
        self.task = None  # type: Optional[common.scheduler.fbs.Task.TaskT]
        self.callables = None  # type: List[common.scheduler.fbs.Callable.CallableT]
        self.watchdog = None  # type: Optional[common.scheduler.watchdog.fbs.Watchdog.WatchdogT]
        self.sequence = None  # type: List[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        program = Program()
        program.Init(buf, pos)
        return cls.InitFromObj(program)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, program):
        x = ProgramT()
        x._UnPack(program)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.task == other.task and \
            self.callables == other.callables and \
            self.watchdog == other.watchdog and \
            self.sequence == other.sequence

    # ProgramT
    def _UnPack(self, program):
        if program is None:
            return
        if program.Task() is not None:
            self.task = common.scheduler.fbs.Task.TaskT.InitFromObj(program.Task())
        if not program.CallablesIsNone():
            self.callables = []
            for i in range(program.CallablesLength()):
                if program.Callables(i) is None:
                    self.callables.append(None)
                else:
                    callable_ = common.scheduler.fbs.Callable.CallableT.InitFromObj(program.Callables(i))
                    self.callables.append(callable_)
        if program.Watchdog() is not None:
            self.watchdog = common.scheduler.watchdog.fbs.Watchdog.WatchdogT.InitFromObj(program.Watchdog())
        if not program.SequenceIsNone():
            self.sequence = []
            for i in range(program.SequenceLength()):
                self.sequence.append(program.Sequence(i))

    # ProgramT
    def Pack(self, builder):
        if self.task is not None:
            task = self.task.Pack(builder)
        if self.callables is not None:
            callableslist = []
            for i in range(len(self.callables)):
                callableslist.append(self.callables[i].Pack(builder))
            ProgramStartCallablesVector(builder, len(self.callables))
            for i in reversed(range(len(self.callables))):
                builder.PrependUOffsetTRelative(callableslist[i])
            callables = builder.EndVector()
        if self.watchdog is not None:
            watchdog = self.watchdog.Pack(builder)
        if self.sequence is not None:
            sequencelist = []
            for i in range(len(self.sequence)):
                sequencelist.append(builder.CreateString(self.sequence[i]))
            ProgramStartSequenceVector(builder, len(self.sequence))
            for i in reversed(range(len(self.sequence))):
                builder.PrependUOffsetTRelative(sequencelist[i])
            sequence = builder.EndVector()
        ProgramStart(builder)
        if self.task is not None:
            ProgramAddTask(builder, task)
        if self.callables is not None:
            ProgramAddCallables(builder, callables)
        if self.watchdog is not None:
            ProgramAddWatchdog(builder, watchdog)
        if self.sequence is not None:
            ProgramAddSequence(builder, sequence)
        program = ProgramEnd(builder)
        return program
