# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class TaskDefaultInfoResponse(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TaskDefaultInfoResponse()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTaskDefaultInfoResponse(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TaskDefaultInfoResponse
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Default task context for the callable
    # TaskDefaultInfoResponse
    def Task(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Default CoreIndex of the task
    # TaskDefaultInfoResponse
    def CoreIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Default priority of the task e.g. high, mid, low
    # TaskDefaultInfoResponse
    def Priority(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # User defined synchronization points, execute callable in order before these points, any alphanumeric character
    # TaskDefaultInfoResponse
    def BeforeSyncPoints(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # TaskDefaultInfoResponse
    def BeforeSyncPointsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TaskDefaultInfoResponse
    def BeforeSyncPointsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # User defined synchronization points, execute callable in order after these points
    # TaskDefaultInfoResponse
    def AfterSyncPoints(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # TaskDefaultInfoResponse
    def AfterSyncPointsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TaskDefaultInfoResponse
    def AfterSyncPointsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def TaskDefaultInfoResponseStart(builder): builder.StartObject(5)
def Start(builder):
    return TaskDefaultInfoResponseStart(builder)
def TaskDefaultInfoResponseAddTask(builder, task): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(task), 0)
def AddTask(builder, task):
    return TaskDefaultInfoResponseAddTask(builder, task)
def TaskDefaultInfoResponseAddCoreIndex(builder, coreIndex): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(coreIndex), 0)
def AddCoreIndex(builder, coreIndex):
    return TaskDefaultInfoResponseAddCoreIndex(builder, coreIndex)
def TaskDefaultInfoResponseAddPriority(builder, priority): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(priority), 0)
def AddPriority(builder, priority):
    return TaskDefaultInfoResponseAddPriority(builder, priority)
def TaskDefaultInfoResponseAddBeforeSyncPoints(builder, beforeSyncPoints): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(beforeSyncPoints), 0)
def AddBeforeSyncPoints(builder, beforeSyncPoints):
    return TaskDefaultInfoResponseAddBeforeSyncPoints(builder, beforeSyncPoints)
def TaskDefaultInfoResponseStartBeforeSyncPointsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartBeforeSyncPointsVector(builder, numElems):
    return TaskDefaultInfoResponseStartBeforeSyncPointsVector(builder, numElems)
def TaskDefaultInfoResponseAddAfterSyncPoints(builder, afterSyncPoints): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(afterSyncPoints), 0)
def AddAfterSyncPoints(builder, afterSyncPoints):
    return TaskDefaultInfoResponseAddAfterSyncPoints(builder, afterSyncPoints)
def TaskDefaultInfoResponseStartAfterSyncPointsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartAfterSyncPointsVector(builder, numElems):
    return TaskDefaultInfoResponseStartAfterSyncPointsVector(builder, numElems)
def TaskDefaultInfoResponseEnd(builder): return builder.EndObject()
def End(builder):
    return TaskDefaultInfoResponseEnd(builder)
try:
    from typing import List
except:
    pass

class TaskDefaultInfoResponseT(object):

    # TaskDefaultInfoResponseT
    def __init__(self):
        self.task = None  # type: str
        self.coreIndex = None  # type: str
        self.priority = None  # type: str
        self.beforeSyncPoints = None  # type: List[str]
        self.afterSyncPoints = None  # type: List[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        taskDefaultInfoResponse = TaskDefaultInfoResponse()
        taskDefaultInfoResponse.Init(buf, pos)
        return cls.InitFromObj(taskDefaultInfoResponse)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, taskDefaultInfoResponse):
        x = TaskDefaultInfoResponseT()
        x._UnPack(taskDefaultInfoResponse)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.task == other.task and \
            self.coreIndex == other.coreIndex and \
            self.priority == other.priority and \
            self.beforeSyncPoints == other.beforeSyncPoints and \
            self.afterSyncPoints == other.afterSyncPoints

    # TaskDefaultInfoResponseT
    def _UnPack(self, taskDefaultInfoResponse):
        if taskDefaultInfoResponse is None:
            return
        self.task = taskDefaultInfoResponse.Task()
        self.coreIndex = taskDefaultInfoResponse.CoreIndex()
        self.priority = taskDefaultInfoResponse.Priority()
        if not taskDefaultInfoResponse.BeforeSyncPointsIsNone():
            self.beforeSyncPoints = []
            for i in range(taskDefaultInfoResponse.BeforeSyncPointsLength()):
                self.beforeSyncPoints.append(taskDefaultInfoResponse.BeforeSyncPoints(i))
        if not taskDefaultInfoResponse.AfterSyncPointsIsNone():
            self.afterSyncPoints = []
            for i in range(taskDefaultInfoResponse.AfterSyncPointsLength()):
                self.afterSyncPoints.append(taskDefaultInfoResponse.AfterSyncPoints(i))

    # TaskDefaultInfoResponseT
    def Pack(self, builder):
        if self.task is not None:
            task = builder.CreateString(self.task)
        if self.coreIndex is not None:
            coreIndex = builder.CreateString(self.coreIndex)
        if self.priority is not None:
            priority = builder.CreateString(self.priority)
        if self.beforeSyncPoints is not None:
            beforeSyncPointslist = []
            for i in range(len(self.beforeSyncPoints)):
                beforeSyncPointslist.append(builder.CreateString(self.beforeSyncPoints[i]))
            TaskDefaultInfoResponseStartBeforeSyncPointsVector(builder, len(self.beforeSyncPoints))
            for i in reversed(range(len(self.beforeSyncPoints))):
                builder.PrependUOffsetTRelative(beforeSyncPointslist[i])
            beforeSyncPoints = builder.EndVector()
        if self.afterSyncPoints is not None:
            afterSyncPointslist = []
            for i in range(len(self.afterSyncPoints)):
                afterSyncPointslist.append(builder.CreateString(self.afterSyncPoints[i]))
            TaskDefaultInfoResponseStartAfterSyncPointsVector(builder, len(self.afterSyncPoints))
            for i in reversed(range(len(self.afterSyncPoints))):
                builder.PrependUOffsetTRelative(afterSyncPointslist[i])
            afterSyncPoints = builder.EndVector()
        TaskDefaultInfoResponseStart(builder)
        if self.task is not None:
            TaskDefaultInfoResponseAddTask(builder, task)
        if self.coreIndex is not None:
            TaskDefaultInfoResponseAddCoreIndex(builder, coreIndex)
        if self.priority is not None:
            TaskDefaultInfoResponseAddPriority(builder, priority)
        if self.beforeSyncPoints is not None:
            TaskDefaultInfoResponseAddBeforeSyncPoints(builder, beforeSyncPoints)
        if self.afterSyncPoints is not None:
            TaskDefaultInfoResponseAddAfterSyncPoints(builder, afterSyncPoints)
        taskDefaultInfoResponse = TaskDefaultInfoResponseEnd(builder)
        return taskDefaultInfoResponse
