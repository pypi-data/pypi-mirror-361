import cli2
import larbin
import prompt2
import os
import cli2
import typing as t


class DoPlugin(larbin.Plugin):
    """
    A high-level orchestrator plugin that coordinates multiple larbin plugins.

    The `do` command attempts to automate a typical workflow:
    1. Ensure project guidelines (`LARBIN.md`) exist (runs `inspect` if needed).
    2. Get a user prompt (via arguments, context, or $EDITOR).
    3. Ensure relevant files mentioned in the prompt are in the context.
    4. Suggest running `autocontext` if context seems incomplete.
    5. Ensure a plan (`LARBINPLAN.md`) exists (runs `plan` if needed).
    6. Execute the plan using the `edit` plugin.
    7. Suggest defining test commands if missing.
    8. Run tests iteratively using the `tdd` plugin if test commands exist.
    """
    @cli2.cmd
    async def do(self, *prompt: str):
        """
        Orchestrate a sequence of plugins for a typical coding task.

        This command acts as a high-level entry point to guide the user and AI
        through understanding the project, defining a task, planning changes,
        executing edits, and testing the results. It may interactively prompt
        the user for confirmations or input (e.g., via $EDITOR).

        Command-line specific usage:
        The arguments passed on the command line form the initial prompt. If
        no arguments are given, it checks the context for a prompt or opens
        $EDITOR.

        Example:
            `larbin do add a new endpoint for user profiles`
            `larbin do` (opens $EDITOR if no prompt is found in context)

        Side Effects:
            - May call other plugins: `inspect`, `autocontext`, `plan`, `edit`, `tdd`.
            - May modify `LARBIN.md`, `LARBINPLAN.md`, context data, and project files.
            - Interacts with the user via `cli2.confirm` and `cli2.editor`.
            - Prints status messages and potentially runs external test commands.

        :param prompt: The initial prompt describing the high-level task.
                       If empty, attempts to retrieve from context or opens $EDITOR.
        :type prompt: t.Tuple[str, ...]

        :raises: Potential exceptions from any of the orchestrated plugins.
                 See :meth:`~larbin.plugins.inspect.InspectPlugin.inspect`,
                 :meth:`~larbin.plugins.autocontext.AutoContextPlugin.autocontext`,
                 :meth:`~larbin.plugins.plan.PlanPlugin.plan`,
                 :meth:`~larbin.plugins.code.CodePlugin.code`,
                 :meth:`~larbin.plugins.tdd.TddPlugin.tdd`.
        """
        # 1. Inspect check
        if (

            'inspect' in self.context.data.get('plugins')
            and not os.path.exists('LARBIN.md')
        ):
            print(cli2.t.o('LARBIN.md NOT FOUND'))
            if cli2.confirm('Do you want to run the inspect plugin?'):
                await self.context.plugins['inspect'].inspect()

        # make sure we have a prompt
        prompt = self.context.context_prompt(prompt)

        # make sure every file mentioned in the prompt are added to context
        paths = [
            word
            for word in prompt.split()
            if os.path.exists(word) and os.path.isfile(word)
        ]
        self.context.paths.add(*paths)

        autogenerated = False
        for path in self.context.paths.list():
            if path not in prompt:
                autogenerated = True

        # make sure we have paths in the context
        if not self.context.paths.list():
            print(cli2.t.o('CONTEXT FILES EMPTY'))

        # make sure we propose autogenerate plugin
        if not autogenerated:
            if cli2.confirm('Do you want the context files to autogenerate?'):
                print(cli2.t.o.b('GENERATING NEW CONTEXT'))
                await self.context.plugins['autocontext'].autocontext(prompt)

        # ensure we have a plan
        if not self.context.plan.exists():
            print(cli2.t.o.b('NO PLAN FOUND'))
            await self.context.plugins['plan'].plan(prompt)

        # apply plan
        await self.context.plugins['code'].code()

        # try to have a test command
        if not self.context.data.get('test_commands', None):
            print(cli2.t.o('NO TEST COMMAND'))
            if cli2.confirm('Do you want to specify a test command?'):
                self.context.update(test_commands=[input('Test command: ')])

        if self.context.data.get('test_commands', None):
            await self.context.plugins['tdd'].tdd()
