"""Class that retrieves and parses data from FELIX.
"""

import socket
import re
import numpy as np

from numpy.typing import NDArray
from ichigo.servers.server import Server
from ichigo.servers.ehu import EhuServer
from ichigo.strmanip import print_color, get_timestamp
from ichigo.config import SETTINGS

class FELIXHelperServer(EhuServer):
    """Recieves data from the FELIX data client.
    """
    def __init__(self, alias: str, host_name: str | None = None, jumps: list[str] = []):
        """Initializes the FELIXHelperServer object.

        """
        super().__init__(alias, host_name, jumps=jumps)

        self.n_spots = SETTINGS["FELIX"]["n_spots"] #144
        self.current_timestamp = 0

        # Calibration points differ from slope offsets in that they are a measured
        # zero point for a "good" wavefront. Slope offsets are used to inject modes
        # and are generated by using an interaction matrix. In practice, both are
        # implemented in the same way.
        self.cal_slopes = np.zeros(self.n_spots * 2)
        self.slope_offsets = np.zeros(self.n_spots * 2)
        
        print_color("Created FELIXHelperServer object. Make sure to run felixports: "
                    + "\"ssh -J felix@stefan.ifa.hawaii.edu -R 10488:localhost:10488 felix@felix\"", "magenta")

    def _process_command(self, command: str) -> tuple[int, list[float], list[float]] | str:
        """Returns a processed command from the FELIX data client. From Charles
        Lockhart.

        Parameters
        ----------
        command: str
            Command from FELIX.

        Returns
        -------
        timestamp: int
            Unix timestamp of the command.
        X_values: list of float
            List of X values.
        Y_values: list of float
            List of Y values.
        """
        # Define regex to match the command format: points [timestamp] [X1,Y1,X2,Y2,...X10,Y10]
        pattern = r"^felixdata\s+([0-9]+)\s+([0-9.,\s\-]+)$"
        match = re.match(pattern, command.strip())

        if not match:
            return "Invalid command format!"

        # Extract the timestamp and the comma-separated values
        timestamp = int( match.group(1) )
        values_str = match.group(2)

        try:
            # Split the values and convert them to float
            values = [float(v) for v in values_str.split(',')]
        except ValueError:
            return "Error: Non-numeric value encountered in coordinates."

        if len(values) != 8:
            return "Error: Expected 4 pairs of X,Y values!"

        # Separate X and Y values
        X_values = values[::2]  # Every second value starting from 0 (X1, X2, ..., X10)
        Y_values = values[1::2]  # Every second value starting from 1 (Y1, Y2, ..., Y10)

        # Print the timestamp and the X,Y pairs neatly
        #print(f"Timestamp: {timestamp}")
        for i in range(4):
            print(f"Pair {i + 1}: X = {X_values[i]}, Y = {Y_values[i]}")

        return timestamp, X_values, Y_values
    
    def _listen_tcp(self) -> tuple[int, list[float], list[float]]:
        """Returns the timestamp, X, and Y values from the FELIX data client.
        Continuously listens for incoming data via TCP until a valid data string
        is recieved.
        """
        host = SETTINGS["FELIX"]["host"]
        port = SETTINGS["FELIX"]["port"]

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind((host, port))
            s.listen()

            print(f"TCP Server listening on {host}:{port}")

            while True:
                # Accept a connection
                conn, addr = s.accept()
                with conn:
                    print(f"Connected by {addr}")
                    data = conn.recv(1024).decode()  # Receive and decode the incoming data

                    if not data:
                        break

                    print_color(f"Received command: {data}", "yellow")

                    # Process the received command
                    result = self._process_command(data)

                    if isinstance(result, tuple):       
                        timestamp, X_values, Y_values = result
                        response = f"X values: {X_values}\nY values: {Y_values}"
                        # Send back the response and return the parsed data
                        conn.sendall(response.encode())
                        return timestamp, X_values, Y_values

                    response = result
                    conn.sendall(response.encode())                    

    def _listen_udp(self) -> tuple[int, list[float], list[float]]:
        """Returns the timestamp, X, and Y values from the FELIX data client.
        Continuously listens for incoming data via UDP until a valid data string
        is recieved.        
        """
        host = SETTINGS["FELIX"]["host"]
        port = SETTINGS["FELIX"]["port"]
        # Create a UDP/IP socket
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind((host, port))

            print(f"UDP server listening on {host}:{port}")

            while True:
                # Receive data from the client
                data, addr = s.recvfrom(1024)  # Buffer size is 1024 bytes
                data = data.decode()

                print(f"Received command from {addr}: {data}")

                # Process the received command
                result = self._process_command(data)

                if isinstance(result, tuple):
                    timestamp, X_values, Y_values = result
                    response = f"X values: {X_values}\nY values: {Y_values}"
                    s.sendto(response.encode(), addr)
                    return timestamp, X_values, Y_values
                
                response = result  # This will be the error message
                # Send back the response to the client
                s.sendto(response.encode(), addr)
    
    def _listen(self) -> tuple[int, list[float], list[float]]:
        """Continuously listens for incoming data until a valid data string is
        recieved.        
        """
        if SETTINGS["FELIX"]["protocol"] == "TCP":
            timestamp, X_values, Y_values = self._listen_tcp()
        elif SETTINGS["FELIX"]["protcol"] == "UDP":
            timestamp, X_values, Y_values = self._listen_udp()
        else:
            raise RuntimeError("Could not resolve protocol for recieving FELIX data. Check settings.ini.")

        return timestamp, X_values, Y_values

    def get_slopes(self, n_ave: int = 1, remove_tilt: bool = True) -> NDArray:
        """Listens for and returns processed FELIX data (slopes). Calibration positions
        and slope offsets are subtracted off. The mean position of the spots can
        be removed to avoid measuring tip/tilt.

        Parameters
        ----------
        None

        Returns
        -------
        slopes: NDArray
            1D array of slopes from FELIX.
        n_ave: int, optional
            Number of frames to average (default is 1).
        remove_tilt: bool, optional
            If True, subtracts out the mean along x and y to remove tip/tilt.
        """
        # Test for imaka RTC
        """measurements = []
        for i in range(n_ave):
            slopes = self.get_imaka_data()[3]
            slopes = slopes.data[0]
            slopes = slopes.flatten() - self.cal_slopes - self.slope_offsets
            measurements.append(slopes)
        slopes = np.mean(measurements, axis=0)"""

        slopes = []
        for i in range(n_ave):
            timestamp, X_values, Y_values = self._listen()
            # Concatenate the lists
            slopes.append(np.array(X_values + Y_values))
        slopes = np.mean(slopes, axis=0)

        slopes -= self.cal_slopes
        slopes -= self.slope_offsets
        self.current_timestamp = timestamp

        if remove_tilt:
            # Mean along x
            slopes[:self.n_spots] -= np.mean(slopes[:self.n_spots])
            # Mean along y
            slopes[self.n_spots:] -= np.mean(slopes[self.n_spots:])
        return slopes
    
    def update_cal_slopes(self, slopes: NDArray) -> None:
        """Updates the calibration slopes for FELIX data.
        """
        # Add in the current calibration
        self.cal_slopes = slopes
        print_color(f"Updated calibration slopes to {self.cal_slopes}", "green")

    def update_slope_offsets(self, offsets: NDArray) -> None:
        """Updates the slope offsets for FELIX data.
        """
        # Add in the current calibration
        self.slope_offsets = offsets
        print_color(f"Updated slope offsets to {self.slope_offsets}", "green")
    
