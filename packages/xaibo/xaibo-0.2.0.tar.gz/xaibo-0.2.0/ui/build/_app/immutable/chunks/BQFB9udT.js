var rt=Object.defineProperty;var qe=r=>{throw TypeError(r)};var at=(r,e,t)=>e in r?rt(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var y=(r,e,t)=>at(r,typeof e!="symbol"?e+"":e,t),De=(r,e,t)=>e.has(r)||qe("Cannot "+t);var b=(r,e,t)=>(De(r,e,"read from private field"),t?t.call(r):e.get(r)),L=(r,e,t)=>e.has(r)?qe("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),I=(r,e,t,s)=>(De(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),R=(r,e,t)=>(De(r,e,"access private method"),t);var Be=(r,e,t,s)=>({set _(i){I(r,e,i,t)},get _(){return b(r,e,s)}});import{g as Me}from"./BYHJcuJc.js";import{aM as lt}from"./CioMtalE.js";import{_ as Ke}from"./D7HrI6pR.js";const ot=!0,ct=ot,Gt=lt,ft={schemaFile:"schema.graphql",runtimeDir:".houdini",defaultCachePolicy:"CacheAndNetwork",defaultFragmentMasking:"disable",plugins:{"houdini-svelte":{static:!0,forceRunesMode:!0}},exclude:["src/lib/paraglide/**/*"],scalars:{JSON:{type:"unknown"}}},ut=[];var ht=ut;function Pe(r){return{defaultKeys:["id"],...r,types:{Node:{keys:["id"],resolve:{queryField:"node",arguments:e=>({id:e.id})}},...r.types}}}function xe(r,e){var s,i;const t=Pe(r);return((i=(s=t.types)==null?void 0:s[e])==null?void 0:i.keys)||t.defaultKeys}function dt(r,e,t){const s=xe(r,e);let i="";for(const n of s)i+=t[n]+"__";return i.slice(0,-2)}let Ie=null;function Yt(r){var e;return((e=r.router)==null?void 0:e.apiEndpoint)??"/_api"}function Se(){if(Ie)return Ie;let r=Pe(ft);for(const e of ht)r=e(r);return Ie=r,r}function ve(r,e,t=new WeakMap){if(Object.is(r,e))return!0;if(r instanceof Date&&e instanceof Date)return r.getTime()===e.getTime();if(r instanceof RegExp&&e instanceof RegExp)return r.toString()===e.toString();if(typeof r!="object"||r===null||typeof e!="object"||e===null)return!1;if(t.get(r)===e)return!0;t.set(r,e);const s=Reflect.ownKeys(r),i=Reflect.ownKeys(e);if(s.length!==i.length)return!1;for(let n=0;n<s.length;n++)if(!Reflect.has(e,s[n])||!ve(r[s[n]],e[s[n]],t))return!1;return!0}function Ge(r){const e=[...r.matchAll(/\$HOUDINI\$(\w*\$)?/g)];if(e.length===0)return[r];let t=r.replaceAll(/\$HOUDINI\$(\w*\$)?/g,"%c"),s=[];for(const i of e){const n=i[1]?`color:${i[1].slice(0,-1)}`:"";s.push(n)}return[t,...s]}function pt(r){console.error(...Ge(r))}function gt(r){console.log(...Ge(r))}function K(r,e,t){if(t)return r.loadingTypes&&r.loadingTypes.length>0?Ye(...r.loadingTypes.map(i=>{var n;return(n=r.abstractFields)==null?void 0:n.fields[i]})):r.fields??{};let s=r.fields||{};if(r.abstractFields&&e){const i=r.abstractFields.typeMap[e];i?s=r.abstractFields.fields[i]:r.abstractFields.fields[e]&&(s=r.abstractFields.fields[e])}return s}function Ye(...r){const e={};for(let t of r)if(t){for(let s in t)if(s in t){const i=t[s];typeof i=="object"&&i!==null&&!Array.isArray(i)?e[s]=Ye(e[s]||{},i):e[s]=i}}return e}const X={CacheOrNetwork:"CacheOrNetwork",CacheOnly:"CacheOnly",NetworkOnly:"NetworkOnly",NoCache:"NoCache"},yt={Variables:"Variables"},oe={Query:"HoudiniQuery",Subscription:"HoudiniSubscription",Mutation:"HoudiniMutation",Fragment:"HoudiniFragment"},bt=oe.Query,Oe={Cache:"cache",Network:"network"},je=" $fragments",mt=Symbol("houdini_loading");function We({selection:r,data:e}){const t=Se();if(e===null||typeof e>"u")return e;if(Array.isArray(e))return e.map(i=>We({selection:r,data:i}));const s=K(r,e.__typename,!1);return Object.fromEntries(Object.entries(e).map(([i,n])=>{var c;if(i===je)return[i,n];const{type:a,selection:l}=s[i];if(!a)return[i,n];if(l)return[i,We({selection:l,data:n})];if((c=t.scalars)!=null&&c[a]){const o=t.scalars[a].marshal;if(!o)throw new Error(`Scalar type ${a} is missing a \`marshal\` function. See https://houdinigraphql.com/api/config#custom-scalars for help on configuring custom scalars.`);return Array.isArray(n)?[i,n.map(o)]:[i,o(n)]}return[i,n]}))}function Ee({artifact:r,input:e,config:t,rootType:s="@root"}){if(e===null||typeof e>"u"||!r.input)return e;const i=s==="@root"?r.input.fields:r.input.types[s];return Array.isArray(e)?e.map(n=>Ee({artifact:r,input:n,rootType:s,config:t})):Object.fromEntries(Object.entries(e).map(([n,a])=>{var o,f;const l=i==null?void 0:i[n];if(!l)return[n,a];const c=(f=(o=t.scalars)==null?void 0:o[l])==null?void 0:f.marshal;return c?Array.isArray(a)?[n,a.map(c)]:[n,c(a)]:_t(t,l)||!r.input.types[l]?[n,a]:[n,Ee({artifact:r,input:a,rootType:l,config:t})]}))}function _t(r,e){return["String","Boolean","Float","ID","Int"].concat(Object.keys(r.scalars||{})).includes(e)}const ae=[],Fe=()=>{};var W,x,ye;class wt{constructor(e,t=Fe){y(this,"state");L(this,W);L(this,x);L(this,ye);this.state=e,I(this,W,new Set),I(this,x,null),I(this,ye,t)}set(e){if(kt(this.state,e)&&(this.state=e,b(this,x))){const t=!ae.length;for(const s of b(this,W))s[1](),ae.push(s,this.state);if(t){for(let s=0;s<ae.length;s+=2)ae[s][0](ae[s+1]);ae.length=0}}}update(e){this.set(e(this.state))}subscribe(e,t=Fe){const s=[e,t];return b(this,W).add(s),b(this,W).size===1&&I(this,x,b(this,ye).call(this,this.set)||Fe),e(this.state),()=>{var i;b(this,W).delete(s),b(this,W).size===0&&((i=b(this,x))==null||i.call(this),I(this,x,null))}}}W=new WeakMap,x=new WeakMap,ye=new WeakMap;function kt(r,e){return r!=r?e==e:r!==e||r&&typeof r=="object"||typeof r=="function"}const Xe=({field:r,args:e})=>{const t=Object.keys(e??{});return t.sort(),e&&t.length>0?`${r}(${t.map(s=>`${s}: ${Ae(e[s])}`).join(", ")})`:r},Ae=r=>Array.isArray(r)?`[${r.map(e=>`${Ae(e)}`).join(", ")}]`:typeof r!="object"||r instanceof Date||r===null?JSON.stringify(r).replace(/"([^"]+)":/g,"$1: "):`{${Object.keys(r).map(e=>`${e}: ${Ae(r[e])}`).join(", ")}}`;function H(r){return r?r.reduce((e,t)=>t?Array.isArray(t)?e.concat(H(t)):e.concat(t):e,[]):[]}class vt{constructor(e){y(this,"cache");y(this,"lifetimes",new Map);this.cache=e}get cacheBufferSize(){return this.cache._internal_unstable.config.cacheBufferSize??10}reset(){this.lifetimes.clear()}resetLifetime(e,t){this.lifetimes.get(e)||this.lifetimes.set(e,new Map),this.lifetimes.get(e).set(t,0)}tick(){const e=Date.now().valueOf(),t=this.cache._internal_unstable.config.defaultLifetime;for(const[s,i]of this.lifetimes.entries())for(const[n,a]of i.entries())if(!(this.cache._internal_unstable.subscriptions.get(s,n).length>0)&&(i.set(n,a+1),i.get(n)>this.cacheBufferSize&&(this.cache._internal_unstable.storage.deleteField(s,n),this.cache._internal_unstable.lists.deleteField(s,n),i.delete(n),[...i.keys()].length===0&&this.lifetimes.delete(s),this.cache._internal_unstable.staleManager.delete(s,n)),t&&t>0)){const l=this.cache.getFieldTime(s,n);l&&e-l>t&&this.cache._internal_unstable.staleManager.markFieldStale(s,n)}}}function le(r,e=null){let t="",s="",i=!1;for(const n of r){if(s){if(St.includes(n)){s+=n;continue}const a=e==null?void 0:e[s.slice(1)];t+=typeof a<"u"?JSON.stringify(a):"undefined",s=""}if(n==="$"&&!i){s="$";continue}n==='"'&&(i=!i),t+=n}return t}const St="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789",z="_ROOT_";class Dt{constructor(e,t){y(this,"rootID");y(this,"cache");y(this,"lists",new Map);y(this,"listsByField",new Map);this.rootID=t,this.cache=e}get(e,t,s,i){const n=this.getLists(e,t,s);return n?i?new ge(n.lists.filter(a=>!i.has(a.fieldRef))):n:null}getLists(e,t,s){var c;const i=this.lists.get(e);if(!i||i.size===0)return null;if(s)return new ge(Array.from(i,([o,f])=>[...f.lists]).flat());const n=[...i.values()][0],{recordType:a}=n.lists[0],l=t?this.cache._internal_unstable.id(a||"",t):this.rootID;return(i==null?void 0:i.size)===1?t?l===Array.from(i.keys())[0]?n:null:n:t?(c=this.lists.get(e))==null?void 0:c.get(l):(console.error(`Found multiple instances of "${e}". Please provide one of @parentID or @allLists directives to help identify which list you want modify. For more information, visit this guide: https://www.houdinigraphql.com/api/graphql#parentidvalue-string `),null)}remove(e,t){var s;(s=this.lists.get(e))==null||s.delete(t||this.rootID)}add(e){var n,a,l;this.lists.has(e.name)||this.lists.set(e.name,new Map);const t=e.name,s=e.recordID||this.rootID;if((a=(n=this.lists.get(t))==null?void 0:n.get(s))!=null&&a.includes(e.key))return;this.lists.has(t)||this.lists.set(t,new Map),this.lists.get(t).has(s)||this.lists.get(t).set(s,new ge([])),this.listsByField.has(s)||this.listsByField.set(s,new Map),this.listsByField.get(s).has(e.key)||(l=this.listsByField.get(s))==null||l.set(e.key,[]);const i=new It({...e,manager:this});this.lists.get(e.name).get(s).lists.push(i),this.listsByField.get(s).get(e.key).push(i)}removeIDFromAllLists(e,t){let s=!1;for(const i of this.lists.values())for(const n of i.values())n.removeID(e,void 0,t)&&(s=!0);return s}deleteField(e,t){var s,i,n,a,l,c;if((s=this.listsByField.get(e))!=null&&s.has(t)){for(const o of this.listsByField.get(e).get(t))(n=(i=this.lists.get(o.name))==null?void 0:i.get(o.recordID))==null||n.deleteListWithKey(t),((l=(a=this.lists.get(o.name))==null?void 0:a.get(o.recordID))==null?void 0:l.lists.length)===0&&((c=this.lists.get(o.name))==null||c.delete(o.recordID));this.listsByField.get(e).delete(t)}}reset(){this.lists.clear(),this.listsByField.clear()}}class It{constructor({name:e,recordID:t,recordType:s,key:i,listType:n,selection:a,when:l,filters:c,connection:o,manager:f,abstract:p}){y(this,"recordID");y(this,"recordType");y(this,"key");y(this,"type");y(this,"cache");y(this,"selection");y(this,"_when");y(this,"filters");y(this,"name");y(this,"connection");y(this,"manager");y(this,"abstract");this.recordID=t||z,this.recordType=s,this.key=i,this.type=n,this.cache=f.cache,this.selection=a,this._when=l,this.filters=c,this.name=e,this.connection=o,this.manager=f,this.abstract=p}get fieldRef(){return`${this.recordID}.${this.key}`}when(e){return this.manager.lists.get(this.name).get(this.recordID).when(e)}append({selection:e,data:t,variables:s={},layer:i}){return this.addToList(e,t,s,"last",i)}prepend({selection:e,data:t,variables:s={},layer:i}){return this.addToList(e,t,s,"first",i)}addToList(e,t,s={},i,n){const a=this.listType(t),l=this.cache._internal_unstable.id(a,t);if(!this.validateWhen()||!l)return;let c=e,o=t;this.connection?(c={fields:{newEntry:{keyRaw:this.key,type:"Connection",selection:{fields:{edges:{keyRaw:"edges",type:"ConnectionEdge",updates:["append","prepend"],selection:{fields:{__typename:{keyRaw:"__typename",type:"String"},node:{type:a,keyRaw:"node",selection:{...e,fields:{...e.fields,__typename:{keyRaw:"__typename",type:"String"}}}}}}}}}}}},o={newEntry:{edges:[{__typename:a+"Edge",node:{...t,__typename:a}}]}}):(c={fields:{newEntries:{keyRaw:this.key,type:a,updates:["append","prepend"],selection:{...e,fields:{...e.fields,__typename:{keyRaw:"__typename",type:"String"}}}}}},o={newEntries:[{...t,__typename:a}]}),this.cache.write({selection:c,data:o,variables:s,parent:this.recordID,applyUpdates:[i==="first"?"prepend":"append"],layer:n==null?void 0:n.id})}removeID(e,t={},s){var o;if(!this.validateWhen())return;let i=this.recordID,n=e,a=this.key;if(this.connection){const{value:f}=this.cache._internal_unstable.storage.get(this.recordID,this.key);if(!f)return;const p=f,{value:u}=this.cache._internal_unstable.storage.get(p,"edges");for(const g of H(u)||[]){if(!g)continue;const _=g,{value:h}=this.cache._internal_unstable.storage.get(_,"node");h&&h===e&&(n=_)}i=p,a="edges"}let l=this.cache._internal_unstable.storage.get(i,a).value;if(!l||!l.includes(n))return;const c=this.cache._internal_unstable.subscriptions.get(this.recordID,this.key);this.cache._internal_unstable.subscriptions.remove(n,this.connection?this.selection.fields.edges.selection:this.selection,c.map(f=>f[0]),t),this.cache._internal_unstable.storage.remove(i,a,n,s);for(const[f]of c)f.set(this.cache._internal_unstable.getSelection({parent:f.parentID||this.manager.rootID,selection:f.selection,variables:((o=f.variables)==null?void 0:o.call(f))||{},ignoreMasking:!1}).data);return!0}remove(e,t={},s){const i=this.cache._internal_unstable.id(this.listType(e),e);if(i)return this.removeID(i,t,s)}listType(e){return e.__typename||this.type}validateWhen(e){let t=e||this._when,s=!0;if(t){const i=this.filters;t.must&&i&&(s=Object.entries(t.must).reduce((n,[a,l])=>!!(n&&i[a]==l),s)),t.must_not&&(s=!i||Object.entries(t.must_not).reduce((n,[a,l])=>!!(n&&i[a]!=l),s))}return s}toggleElement({selection:e,data:t,variables:s={},layer:i,where:n}){this.remove(t,s,i)||this.addToList(e,t,s,n,i)}*[Symbol.iterator](){let e=[],t=this.cache._internal_unstable.storage.get(this.recordID,this.key).value;this.connection?e=this.cache._internal_unstable.storage.get(t,"edges").value:e=H(t);for(let s of e)yield s}}class ge{constructor(e){y(this,"lists",[]);this.lists=e}get selection(){return this.lists[0].selection}append(...e){this.lists.forEach(t=>t.append(...e))}prepend(...e){this.lists.forEach(t=>t.prepend(...e))}addToList(...e){this.lists.forEach(t=>t.addToList(...e))}removeID(...e){let t=!1;return this.lists.forEach(s=>{s.removeID(...e)&&(t=!0)}),t}remove(...e){this.lists.forEach(t=>t.remove(...e))}toggleElement(...e){this.lists.forEach(t=>t.toggleElement(...e))}when(e){return new ge(this.lists.filter(t=>t.validateWhen(e)))}includes(e){return!!this.lists.find(t=>t.key===e)}deleteListWithKey(e){return this.lists=this.lists.filter(t=>t.key!==e)}*[Symbol.iterator](){for(let e of this.lists)for(const t of e)yield t}}var be;class Ot{constructor(e){y(this,"cache");y(this,"fieldsTime",new Map);L(this,be,e=>{this.fieldsTime.get(e)||this.fieldsTime.set(e,new Map)});this.cache=e}getFieldTime(e,t){var s;return(s=this.fieldsTime.get(e))==null?void 0:s.get(t)}setFieldTimeToNow(e,t){var s;b(this,be).call(this,e),(s=this.fieldsTime.get(e))==null||s.set(t,new Date().valueOf())}markFieldStale(e,t){var s;b(this,be).call(this,e),(s=this.fieldsTime.get(e))==null||s.set(t,null)}markAllStale(){for(const[e,t]of this.fieldsTime.entries())for(const[s]of t.entries())this.markFieldStale(e,s)}markRecordStale(e){const t=this.fieldsTime.get(e);if(t)for(const[s]of t.entries())this.markFieldStale(e,s)}markTypeStale(e){for(const[t,s]of this.fieldsTime.entries())if(t.startsWith(`${e}:`))for(const[i]of s.entries())this.markFieldStale(t,i)}markTypeFieldStale(e,t,s){const i=Xe({field:t,args:s});for(const[n,a]of this.fieldsTime.entries())if(n.startsWith(`${e}:`))for(const l of a.keys())l===i&&this.markFieldStale(n,t)}delete(e,t){var s,i;this.fieldsTime.has(e)&&((s=this.fieldsTime.get(e))==null||s.delete(t),((i=this.fieldsTime.get(e))==null?void 0:i.size)===0&&this.fieldsTime.delete(e))}reset(){this.fieldsTime.clear()}}be=new WeakMap;class Ft{constructor(){y(this,"data");y(this,"idCount",1);y(this,"rank",0);y(this,"idMaps",{});this.data=[]}get layerCount(){return this.data.length}get nextRank(){return this.rank++}registerIDMapping(e,t){this.idMaps[e]=t,this.idMaps[t]=e}createLayer(e=!1){const t=new Lt(this.idCount++);return t.optimistic=e,this.data.push(t),t}insert(e,t,s,i){return this.topLayer.insert(e,t,s,i)}remove(e,t,s,i=this.topLayer){return i.remove(e,t,s)}delete(e,t=this.topLayer){return t.delete(e)}deleteField(e,t){return this.topLayer.deleteField(e,t)}getLayer(e){for(const t of this.data)if(t.id===e)return t;throw new Error("Could not find layer with id: "+e)}replaceID(e){for(const t of this.data)t.replaceID(e)}get(e,t,s){const i={[Z.insert]:{[Le.start]:[],[Le.end]:[]},[Z.remove]:new Set},n=[],a=[this.idMaps[e],e].filter(Boolean);for(let l=this.data.length-1;l>=0;l--)for(const c of a){const o=this.data[l];let[f,p]=o.get(c,t);const u=o.getOperations(c,t)||[];if(o.deletedIDs.forEach(g=>{var _,h;(h=(_=o.operations[g])==null?void 0:_.undoDeletesInList)!=null&&h.includes(t)||(i.remove.add(g),this.idMaps[g]&&i.remove.add(this.idMaps[g]))}),typeof f>"u"&&s&&(this.topLayer.writeField(c,t,s),f=s),typeof f>"u"&&u.length===0){o.deletedIDs.size>0&&n.push(o.id);continue}if(typeof f<"u"&&!Array.isArray(f))return{value:f,kind:p,displayLayers:[o.id]};if(n.push(o.id),u.length>0){for(const g of u)if(Mt(g)&&i.remove.add(g.id),Ct(g)&&(g.location===Le.end?i.insert[g.location].unshift(g.id):i.insert[g.location].push(g.id)),Tt(g))return{value:void 0,kind:"unknown",displayLayers:[]}}if(!(typeof f>"u"))return!i.remove.size&&!i.insert.start.length&&!i.insert.end.length?{value:f,displayLayers:n,kind:"link"}:{value:[...i.insert.start,...f,...i.insert.end].filter(g=>!i.remove.has(g)),displayLayers:n,kind:p}}return{value:void 0,kind:"unknown",displayLayers:[]}}writeLink(e,t,s){return this.topLayer.writeLink(e,t,s)}writeField(e,t,s){return this.topLayer.writeField(e,t,s)}resolveLayer(e){let t=null;for(const[n,a]of this.data.entries())if(a.id===e){t=n-1,this.data[n].optimistic=!1;break}if(t===null)throw new Error("could not find layer with id: "+e);t===-1&&(t=0),this.data[t].optimistic&&t++;const s=this.data[t];let i=t;for(;i<this.data.length;){const n=this.data[i++];if(n.optimistic){i--;break}s.writeLayer(n)}this.data.splice(t+1,i-t-1),this.data.length===1&&(this.idMaps={})}get topLayer(){var e;return this.data.length===0&&this.createLayer(),(e=this.data[this.data.length-1])!=null&&e.optimistic&&this.createLayer(),this.data[this.data.length-1]}serialize(){return JSON.stringify({rank:this.rank,fields:Object.fromEntries(Object.entries(this.topLayer.fields).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).filter(([s,i])=>typeof i!="function"))])),links:this.topLayer.links})}hydrate(e,t){if(!e)return;const{rank:s,fields:i,links:n}=e;this.rank=s,t??(t=this.createLayer(!0)),t.fields=i,t.links=n}reset(){this.data=[]}}class Lt{constructor(e){y(this,"id");y(this,"optimistic",!1);y(this,"fields",{});y(this,"links",{});y(this,"operations",{});y(this,"deletedIDs",new Set);this.id=e}get(e,t){var s,i;return typeof((s=this.links[e])==null?void 0:s[t])<"u"?[this.links[e][t],"link"]:[(i=this.fields[e])==null?void 0:i[t],"scalar"]}getOperations(e,t){var s,i,n;if((s=this.operations[e])!=null&&s.deleted)return[{kind:Z.delete,target:e}];if((n=(i=this.operations[e])==null?void 0:i.fields)!=null&&n[t])return this.operations[e].fields[t]}writeField(e,t,s){return this.fields[e]={...this.fields[e],[t]:s},this.id}writeLink(e,t,s){var n,a,l;const i=Array.isArray(s)?s:[s];for(const c of H(i)){if(!c)continue;const o=(n=this.operations[e])==null?void 0:n.fields[t];(a=this.operations[c])!=null&&a.deleted||this.deletedIDs.has(c)?this.operations[c]={...this.operations[c],undoDeletesInList:[...((l=this.operations[e])==null?void 0:l.undoDeletesInList)||[],t]}:c&&(o==null?void 0:o.length)>0&&(this.operations[e].fields[t]=o.filter(f=>f.kind!=="remove"||f.id!==c))}return this.links[e]={...this.links[e],[t]:s},this.id}isDisplayLayer(e){return e.length===0||e.includes(this.id)||Math.max(...e)<this.id}clear(){this.links={},this.fields={},this.operations={},this.deletedIDs=new Set}replaceID({from:e,to:t}){this.fields[t]=this.fields[e],this.links[t]=this.links[e],this.operations[t]=this.operations[e]||{fields:{}},this.deletedIDs.has(e)&&this.deletedIDs.add(t)}removeUndefinedFields(){for(const[e,t]of Object.entries(this.fields)){for(const[s,i]of Object.entries(t))if(typeof i>"u"){try{delete this.fields[e][s]}catch{}try{delete this.links[e][s]}catch{}}Object.keys(t||{}).length===0&&delete this.fields[e],Object.keys(this.links[e]||{}).length===0&&delete this.links[e]}}delete(e){this.operations={...this.operations,[e]:{...this.operations[e],deleted:!0,undoDeletesInList:[]}},this.deletedIDs.add(e)}deleteField(e,t){this.fields[e]={...this.fields[e],[t]:void 0}}insert(e,t,s,i){this.addFieldOperation(e,t,{kind:Z.insert,id:i,location:s})}remove(e,t,s){this.addFieldOperation(e,t,{kind:Z.remove,id:s})}writeLayer(e){if(e.id!==this.id){for(const[t,s]of Object.entries(e.operations)){const i={};for(const n of[e.operations[t],this.operations[t]].filter(Boolean))for(const[a,l]of Object.entries(n.fields||{}))i[a]=[...i[a]||[],...l];Object.keys(i).length>0&&(this.operations[t]={...this.operations[t],fields:i}),s!=null&&s.deleted&&(delete this.fields[t],delete this.links[t])}for(const[t,s]of Object.entries(e.fields))if(s)for(const[i,n]of Object.entries(s))this.writeField(t,i,n);for(const[t,s]of Object.entries(e.links))if(s)for(const[i,n]of Object.entries(s))this.writeLink(t,i,n);e.deletedIDs.forEach(t=>this.deletedIDs.add(t))}}addFieldOperation(e,t,s){var i,n;this.operations={...this.operations,[e]:{...this.operations[e],fields:{...(i=this.operations[e])==null?void 0:i.fields,[t]:[...((n=this.operations[e])==null?void 0:n.fields[t])||[],s]}}}}}function Tt(r){return!!r&&r.kind===Z.delete}function Ct(r){return!!r&&r.kind===Z.insert}function Mt(r){return!!r&&r.kind===Z.remove}const Le={start:"start",end:"end"},Z={delete:"delete",insert:"insert",remove:"remove"};class Et{constructor(e){y(this,"cache");y(this,"subscribers",new Map);y(this,"keyVersions",{});this.cache=e}activeFields(e){return Object.keys(this.subscribers.get(e)||{})}copySubscribers(e,t){this.subscribers.set(t,this.subscribers.get(e)||new Map)}add({parent:e,spec:t,selection:s,variables:i,parentType:n}){const a=this.cache._internal_unstable.storage.get(e,"__typename").value;let l=K(s,a,!1);for(const c of Object.values(l||{})){const{keyRaw:o,selection:f,type:p,list:u,filters:g,visible:_}=c;if(!_)continue;const h=le(o,i);let m;if(f){const v=this.cache._internal_unstable.storage.get(e,"__typename").value;m=K(f,v,!1)}if(this.addFieldSubscription({id:e,key:h,selection:[t,m],type:p}),u&&this.registerList({list:u,filters:g,id:e,key:h,variables:i,selection:f,parentType:n||t.rootType}),f){const{value:v}=this.cache._internal_unstable.storage.get(e,h);let w=Array.isArray(v)?H(v)||[]:[v];for(const k of w)k&&this.add({parent:k,spec:t,selection:f,variables:i,parentType:p})}}}addFieldSubscription({id:e,key:t,selection:s,type:i}){const n=s[0];this.subscribers.has(e)||this.subscribers.set(e,new Map);const a=this.subscribers.get(e);a.has(t)||a.set(t,{selections:[],referenceCounts:new Map});const l=a.get(t);this.keyVersions[t]||(this.keyVersions[t]=new Set),this.keyVersions[t].add(t),l.selections.some(([{set:c}])=>c===n.set)||l.selections.push([n,s[1]]),l.referenceCounts.set(n.set,(l.referenceCounts.get(n.set)||0)+1),this.cache._internal_unstable.lifetimes.resetLifetime(e,t)}registerList({list:e,id:t,key:s,parentType:i,selection:n,filters:a,variables:l}){var c;this.cache._internal_unstable.lists.add({name:e.name,connection:e.connection,recordID:t,recordType:((c=this.cache._internal_unstable.storage.get(t,"__typename"))==null?void 0:c.value)||i,listType:e.type,key:s,selection:n,filters:Object.entries(a||{}).reduce((o,[f,{kind:p,value:u}])=>({...o,[f]:p!=="Variable"?u:l[u]}),{})})}addMany({parent:e,variables:t,subscribers:s,parentType:i}){for(const[n,a]of s)for(const l of Object.values(a??{})){const{type:c,keyRaw:o,selection:f,list:p,filters:u}=l,g=le(o,t),_=f?K(f,i,!1):void 0;this.addFieldSubscription({id:e,key:g,selection:[n,_],type:c}),p&&this.registerList({list:p,filters:u,id:e,key:g,variables:t,selection:f,parentType:i||n.rootType});const h=l.selection;if(h){const{value:m}=this.cache._internal_unstable.storage.get(e,g),v=Array.isArray(m)?H(m):[m];for(const w of v){if(!w)continue;const k=this.cache._internal_unstable.storage.get(w,"__typename").value;let C=K(h,k,!1);this.addMany({parent:w,variables:t,subscribers:s.map(([q])=>[q,C]),parentType:c})}}}}get(e,t){var s,i;return((i=(s=this.subscribers.get(e))==null?void 0:s.get(t))==null?void 0:i.selections)||[]}getAll(e){var t;return[...((t=this.subscribers.get(e))==null?void 0:t.values())||[]].flatMap(s=>s.selections)}remove(e,t,s,i,n=[]){n.push(e);const a=[],l=this.cache._internal_unstable.storage.get(e,"__typename").value;let c=K(t,l,!1);for(const o of Object.values(c||{})){const f=le(o.keyRaw,i);if(this.removeSubscribers(e,f,s),!o.selection)continue;const{value:p}=this.cache._internal_unstable.storage.get(e,f),u=Array.isArray(p)?H(p):[p];for(const g of u)g!==null&&a.push([g,o.selection||{}])}for(const[o,f]of a)this.remove(o,f,s,n)}reset(){const e=[...this.subscribers.entries()].filter(([s])=>!s.startsWith(z));for(const[s,i]of e)this.subscribers.delete(s);return e.flatMap(([s,i])=>[...i.values()].flatMap(n=>n.selections.map(([a])=>a)))}removeSubscribers(e,t,s){let i=[];const n=this.subscribers.get(e);if(!n)return;const a=n.get(t);for(const l of s){const c=a==null?void 0:a.referenceCounts;if(!(c!=null&&c.has(l.set)))continue;const o=(c.get(l.set)||0)-1;c.set(l.set,o),o<=0&&(i.push(l.set),c.delete(l.set)),c.size===0&&n.delete(t)}a&&(a.selections=this.get(e,t).filter(([{set:l}])=>!i.includes(l))),n.size===0&&this.subscribers.delete(e)}removeAllSubscribers(e,t){var s;t||(t=[...((s=this.subscribers.get(e))==null?void 0:s.values())||[]].flatMap(i=>i.selections.flatMap(n=>n[0])));for(const i of t)for(const n of this.findSubSelections(i.parentID||z,i.selection,i.variables||{},e))this.remove(e,n,t,i.variables||{})}get size(){let e=0;for(const[,t]of this.subscribers)for(const[,{referenceCounts:s}]of t)e+=[...s.values()].reduce((i,n)=>i+n,0);return e}findSubSelections(e,t,s,i,n=[]){const a=this.cache._internal_unstable.storage.get(e,"__typename").value;let l=K(t,a,!1);for(const c of Object.values(l||{})){if(!c.selection)continue;const o=le(c.keyRaw,s||{}),f=this.cache._internal_unstable.storage.get(e,o),p=Array.isArray(f.value)?H(f.value):[f.value];if(p.includes(i))n.push(c.selection);else for(const u of p)this.findSubSelections(u,c.selection,s,i,n)}return n}}var At={},ce,_e;class Ze{constructor({disabled:e,componentCache:t,createComponent:s,...i}={}){L(this,ce);y(this,"_internal_unstable");this._internal_unstable=new Rt({cache:this,storage:new Ft,subscriptions:new Et(this),lists:new Dt(this,z),lifetimes:new vt(this),staleManager:new Ot(this),disabled:e??typeof globalThis.window>"u",componentCache:t,createComponent:s}),Object.keys(i).length>0&&this.setConfig(Pe(i))}write({layer:e,notifySubscribers:t=[],...s}){const i=e?this._internal_unstable.storage.getLayer(e):this._internal_unstable.storage.topLayer,n=this._internal_unstable.writeSelection({...s,layer:i}).map(a=>a[0]);return R(this,ce,_e).call(this,n.concat(t)),n}read(...e){const{data:t,partial:s,stale:i,hasData:n}=this._internal_unstable.getSelection(...e);return n?{data:t,partial:s,stale:i}:{data:null,partial:!1,stale:!1}}subscribe(e,t={}){if(!this._internal_unstable.disabled)return this._internal_unstable.subscriptions.add({parent:e.parentID||z,spec:e,selection:e.selection,variables:t})}unsubscribe(e,t={}){return this._internal_unstable.subscriptions.remove(e.parentID||z,e.selection,[e],t)}list(e,t,s,i){const n=this._internal_unstable.lists.get(e,t,s,i);if(!n)throw new Error(`Cannot find list with name: ${e}${t?" under parent "+t:""}. Is it possible that the query is not mounted?`);return n}registerKeyMap(e,t){this._internal_unstable.storage.registerIDMapping(e,t),this._internal_unstable.subscriptions.copySubscribers(e,t)}delete(e,t){const s=[this._internal_unstable.storage.idMaps[e],e].filter(Boolean);for(const i of s)this._internal_unstable.subscriptions.removeAllSubscribers(i),this._internal_unstable.lists.removeIDFromAllLists(i,t),this._internal_unstable.storage.delete(i,t)}setConfig(e){this._internal_unstable.setConfig(e)}markTypeStale(e){e?e.field?this._internal_unstable.staleManager.markTypeFieldStale(e.type,e.field,e.when):this._internal_unstable.staleManager.markTypeStale(e.type):this._internal_unstable.staleManager.markAllStale()}markRecordStale(e,t){if(t.field){const s=Xe({field:t.field,args:t.when??{}});this._internal_unstable.staleManager.markFieldStale(e,s)}else this._internal_unstable.staleManager.markRecordStale(e)}getFieldTime(e,t){return this._internal_unstable.staleManager.getFieldTime(e,t)}config(){return this._internal_unstable.config}serialize(){return this._internal_unstable.storage.serialize()}hydrate(...e){return this._internal_unstable.storage.hydrate(...e)}clearLayer(e){const t=this._internal_unstable.storage.getLayer(e);if(!t)throw new Error("Cannot find layer with id: "+e);const s=[],i=[];for(const a of[t.fields,t.links])for(const[l,c]of Object.entries(a))i.push(...Object.entries(c).map(([o,f])=>({id:l,field:o,value:f})));const n=[];for(const a of i){const{displayLayers:l}=this._internal_unstable.storage.get(a.id,a.field);l.includes(e)&&n.push(a)}for(const[a,l]of Object.entries(t.operations)){l.deleted&&n.push(...this._internal_unstable.subscriptions.activeFields(a).map(o=>({id:a,field:o})));const c=Object.keys(l.fields??{});c.length>0&&n.push(...c.map(o=>({id:a,field:o})))}t.clear();for(const a of n){const{field:l,id:c}=a;(!("value"in a)||this._internal_unstable.storage.get(c,l).value!==a.value)&&s.push(...this._internal_unstable.subscriptions.get(c,l).map(f=>f[0]))}R(this,ce,_e).call(this,s)}reset(){const e=this._internal_unstable.subscriptions.reset();this._internal_unstable.staleManager.reset(),this._internal_unstable.lifetimes.reset(),this._internal_unstable.lists.reset(),this._internal_unstable.storage.reset(),R(this,ce,_e).call(this,e)}}ce=new WeakSet,_e=function(e){var s;if(e.length===0)return;const t=[];for(const i of e)t.includes(i.set)||(t.push(i.set),i.set(this._internal_unstable.getSelection({parent:i.parentID||z,selection:i.selection,variables:((s=i.variables)==null?void 0:s.call(i))||{},ignoreMasking:!1}).data))};class Rt{constructor({storage:e,subscriptions:t,lists:s,cache:i,lifetimes:n,staleManager:a,disabled:l,config:c,componentCache:o,createComponent:f}){y(this,"disabled",!1);y(this,"_config");y(this,"storage");y(this,"subscriptions");y(this,"lists");y(this,"cache");y(this,"lifetimes");y(this,"staleManager");y(this,"componentCache");y(this,"createComponent");this.storage=e,this.subscriptions=t,this.lists=s,this.cache=i,this.lifetimes=n,this.staleManager=a,this._config=c,this.componentCache=o??{},this.createComponent=f??(()=>({})),this.disabled=l;try{At.HOUDINI_TEST==="true"&&(this.disabled=!1)}catch{}}get config(){return this._config??Se()}setConfig(e){this._config=e}writeSelection({data:e,selection:t,variables:s={},parent:i=z,applyUpdates:n,layer:a,toNotify:l=[],forceNotify:c,forceStale:o}){if(this.disabled)return[];let f=K(t,e.__typename,!1);for(const[p,u]of Object.entries(e)){if(!t||!f[p])continue;let{type:g,keyRaw:_,selection:h,operations:m,abstract:v,updates:w}=f[p];const k=le(_,s);u&&typeof u=="object"&&"__typename"in u&&u.__typename&&(g=u.__typename);const C=this.subscriptions.get(i,k),q=C.map(d=>d[0]),{value:F,displayLayers:de}=this.storage.get(i,k),ne=a.isDisplayLayer(de);if(ne&&(this.lifetimes.resetLifetime(i,k),o?this.staleManager.markFieldStale(i,k):this.staleManager.setFieldTimeToNow(i,k)),h){if(u===null){if(F===null)continue;const d=H([F]);for(const M of d)this.subscriptions.remove(M,h,q,s);a.writeLink(i,k,null),l.push(...C)}else if(u instanceof Object&&!Array.isArray(u)){if(v&&!u.__typename)throw new Error("Encountered interface type without __typename in the payload");let d=null;u!==null&&(d=this.isEmbedded(g,u)?`${i}.${k}`:this.id(g,u));let M=d!==F;a.writeLink(i,k,d),d&&ne&&(M||c)&&(F&&typeof F=="string"&&this.subscriptions.remove(F,h,q,s),this.subscriptions.addMany({parent:d,subscribers:C,variables:s,parentType:g}),l.push(...C)),d&&this.writeSelection({selection:h,parent:d,data:u,variables:s,toNotify:l,applyUpdates:n,layer:a,forceNotify:c})}else if(Array.isArray(u)&&(typeof F>"u"||F===null||Array.isArray(F))){let d=[...F||[]];const M=w?d.map(O=>{if(!O)return"";const{value:S}=this.storage.get(O,"cursor");if(S)return"";const{value:j}=this.storage.get(O,"node");return j||""}):[];let E=[];const{newIDs:D,nestedIDs:$}=this.extractNestedListIDs({value:u,abstract:!!v,specs:l,applyUpdates:n,recordID:i,key:k,linkedType:g,variables:s,fields:h,layer:a,forceNotify:c});let A=()=>{a.writeLink(i,k,E)};if(n&&w){if(k==="edges"){const O=[];for(const S of D){if(!S)continue;const{value:j}=this.storage.get(S,"node");typeof j=="string"&&(!j||!this.storage.get(j,"__typename")||O.push(j))}d=d.filter(S=>{if(!S)return!0;const{value:j}=this.storage.get(S,"node"),N=j;return!(O.includes(N)&&M.includes(N))})}for(const O of n)O!=="replace"&&!w.includes(O)||(O==="prepend"?(E=D.concat(d),a!=null&&a.optimistic&&(A=()=>{for(const S of D)S&&a.insert(i,k,"start",S)})):O==="append"?(E=d.concat(D),a!=null&&a.optimistic&&(A=()=>{for(const S of D)S&&a.insert(i,k,"end",S)})):O==="replace"&&(E=D))}else E=$;const re=!ve(E,d)||F===null;(re||c)&&l.push(...C);for(const O of d)E.includes(O)||!O||this.subscriptions.remove(O,h,q,s);(re||d.length===0&&D.length===0)&&A();for(const O of D.filter(S=>!d.includes(S)))O!=null&&this.subscriptions.addMany({parent:O,subscribers:C,variables:s,parentType:g})}}else{let d=u;if(w&&n&&Array.isArray(u))for(const E of n)w.includes(E)&&(E==="append"?d=(F||[]).concat(u):E==="prepend"&&(d=u.concat(F||[])));(w&&(n!=null&&n.includes("prepend"))&&["endCursor","hasNextPage"].includes(k)||w&&(n!=null&&n.includes("append"))&&["startCursor","hasPreviousPage"].includes(k))&&(d=F);const M=!ve(d,F);ne&&(M||c)&&l.push(...C),a.writeField(i,k,d)}const V=new Set;for(const d of m||[]){let M;if(d.parentID)if(d.parentID.kind!=="Variable")M=d.parentID.value;else{const D=s[d.parentID.value];if(typeof D!="string")throw new Error("parentID value must be a string");M=D}if(d.list&&!this.lists.get(d.list,M,d.target==="all"))continue;const E=Array.isArray(u)?u:[u];for(const D of E)if(d.action==="insert"&&D instanceof Object&&h&&d.list)this.cache.list(d.list,M,d.target==="all",V).when(d.when).addToList(h,D,s,d.position||"last",a);else if(d.action==="toggle"&&D instanceof Object&&h&&d.list)this.cache.list(d.list,M,d.target==="all",V).when(d.when).toggleElement({selection:h,data:D,variables:s,where:d.position||"last",layer:a});else if(d.action==="remove"&&D instanceof Object&&h&&d.list)this.cache.list(d.list,M,d.target==="all",V).when(d.when).remove(D,s,a);else if(d.action==="delete"&&d.type&&D){const $=this.id(d.type,D);if(!$)continue;l.push(...this.subscriptions.getAll($).filter(A=>A[0].parentID!==$)),this.cache.delete($,a)}if(d.list){const D=this.cache.list(d.list,M,d.target==="all");for(const $ of D.lists)V.add($.fieldRef)}}}return l}getSelection({selection:e,parent:t=z,variables:s,stepsFromConnection:i=null,ignoreMasking:n,fullCheck:a=!1,loading:l}){var h,m,v;if(t===null)return{data:null,partial:!1,stale:!1,hasData:!0};const c={};e.fragments&&(c[je]={loading:!!l,values:Object.fromEntries(Object.entries(e.fragments).filter(([,w])=>!l||w.loading).map(([w,k])=>[w,{parent:t,variables:we(k.arguments,s??{})}]))});let o=!!e.fragments,f=!1,p=!1,u=!1;const g=this.storage.get(t,"__typename").value;let _=K(e,g,!!l);for(const[w,{type:k,keyRaw:C,selection:q,nullable:F,list:de,visible:ne,directives:V,loading:d,abstractHasRequired:M,component:E}]of Object.entries(_)){if(!ne&&!n&&!a)continue;const D=V==null?void 0:V.find(T=>T.name==="include");if(D&&!we(D.arguments,s??{}).if)continue;const $=V==null?void 0:V.find(T=>T.name==="skip");if($&&we($.arguments,s??{}).if)continue;const A=ne||n?c:{},re=le(C,s);if(l&&!d)continue;const O=E?Vt({cache:this.cache,component:E,variables:s,parent:t}):void 0;let{value:S}=this.storage.get(t,re,O);this.staleManager.getFieldTime(t,re)===null&&(u=!0),l&&(S=void 0);let N=i;N!==null&&(N>=2?N=null:N+=1),de!=null&&de.connection&&(N=0);const ze=re==="cursor"&&i===1;if(typeof S>"u"&&!ze&&(f=!0),l&&(d==null?void 0:d.kind)==="value")A[w]=mt,o=!0;else if(!l&&typeof S>"u"||S===null)A[w]=null,typeof S<"u"&&(o=!0);else if(q)if(Array.isArray(S)){const T=this.hydrateNestedList({fields:q,variables:s,linkedList:S,stepsFromConnection:N,ignoreMasking:!!n,fullCheck:a,loading:l,nullable:!!F});A[w]=T.data,T.partial&&(f=!0),T.cascadeNull&&(p=!0),T.stale&&(u=!0),(T.hasData||S.length===0)&&(o=!0)}else{const T=this.getSelection({parent:S,selection:q,variables:s,stepsFromConnection:N,ignoreMasking:n,fullCheck:a,loading:l});A[w]=T.data,T.partial&&(f=!0),T.stale&&(u=!0),T.hasData&&(o=!0)}else{const T=(v=(m=(h=this.config)==null?void 0:h.scalars)==null?void 0:m[k])==null?void 0:v.unmarshal;T?Array.isArray(S)?A[w]=S.map(nt=>T(nt)):A[w]=T(S):A[w]=S,o=!0}l&&(d!=null&&d.list)&&(A[w]=Ue(Array.from({length:d.list.count}).fill(A[w]),d.list.depth-1)),A[w]===null&&!F&&!ze&&(M?c[w]={__typename:"@required field missing; don't match this"}:p=!0)}return{data:p?null:c,partial:!l&&o&&f,stale:o&&u,hasData:o}}id(e,t){const s=typeof t=="object"?this.computeID(e,t):t;return s?e?e+":"+s:s:null}idFields(e){return xe(this.config,e)}computeID(e,t){return dt(this.config,e,t)}isEmbedded(e,t){const s=this.idFields(e);return s.length===0||s.filter(i=>typeof t[i]>"u").length>0}hydrateNestedList({fields:e,variables:t,linkedList:s,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l,nullable:c}){const o=[];let f=!1,p=!1,u=!1,g=!1;for(const _ of s){if(Array.isArray(_)){const k=this.hydrateNestedList({fields:e,nullable:c,variables:t,linkedList:_,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l});o.push(k.data),k.partial&&(f=!0),k.cascadeNull&&(g=!0);continue}if(_===null){o.push(_);continue}const{data:h,partial:m,stale:v,hasData:w}=this.getSelection({parent:_,selection:e,variables:t,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l});h===null&&!c&&(g=!0),o.push(h),m&&(f=!0),v&&(p=!0),w&&(u=!0)}return{data:o,partial:f,stale:p,hasData:u,cascadeNull:g}}extractNestedListIDs({value:e,abstract:t,recordID:s,key:i,linkedType:n,fields:a,variables:l,applyUpdates:c,specs:o,layer:f,forceNotify:p}){const u=[],g=[];for(const[_,h]of e.entries()){if(Array.isArray(h)){const C=this.extractNestedListIDs({value:h,abstract:t,recordID:s,key:i,linkedType:n,fields:a,variables:l,applyUpdates:c,specs:o,layer:f,forceNotify:p});g.push(...C.newIDs),u[_]=C.nestedIDs;continue}if(h===null||typeof h>"u"){g.push(null),u[_]=null;continue}const m=h;let v=`${s}.${i}[${this.storage.nextRank}]`,w=n;const k=m.__typename;if(k)w=k;else if(t)throw new Error("Encountered interface type without __typename in the payload");if(!this.isEmbedded(n,h)){const C=this.id(w,h);if(C)v=C;else continue}this.writeSelection({root:z,selection:a,parent:v,data:m,variables:l,toNotify:o,applyUpdates:c,layer:f,forceNotify:p}),g.push(v),u[_]=v}return{newIDs:g,nestedIDs:u}}collectGarbage(){this.lifetimes.tick(),this.storage.layerCount===1&&this.storage.topLayer.removeUndefinedFields()}}function we(r,e){return Object.fromEntries(Object.entries(r).map(([t,s])=>[t,Re(s,e)]))}function Ue(r,e=0){return e===0?r:Ue([r],e-1)}function Re(r,e){if(r.kind==="StringValue"||r.kind==="BooleanValue"||r.kind==="EnumValue")return r.value;if(r.kind==="FloatValue")return parseFloat(r.value);if(r.kind==="IntValue")return parseInt(r.value,10);if(r.kind==="NullValue")return null;if(r.kind==="Variable")return e[r.name.value];if(r.kind==="ListValue")return r.values.map(t=>Re(t,e));if(r.kind==="ObjectValue")return r.fields.reduce((t,s)=>({...t,[s.name.value]:Re(s.value,e)}),{})}function Vt({cache:r,component:e,loading:t,variables:s,parent:i}){return n=>{const a=r._internal_unstable.componentCache[e.key],l=we(e.variables??{},s??{});return r._internal_unstable.createComponent(a,{...n,[e.prop]:{[je]:{loading:t,values:{[e.fragment]:{variables:l,parent:i}}}}})}}var $t=new Ze;const Te=typeof globalThis.window>"u",Pt=({enabled:r,setFetching:e,cache:t=$t,serverSideFallback:s=!0})=>()=>({beforeNetwork(i,{initialValue:n,next:a,resolve:l,marshalVariables:c}){var u,g;const{policy:o,artifact:f}=i;let p=!1;if(r&&(f.kind===oe.Query||f.kind===oe.Fragment)&&!((u=i.cacheParams)!=null&&u.disableRead)&&o!==X.NetworkOnly&&o!==X.NoCache){const h=t.read({selection:f.selection,variables:c(i),fullCheck:!0}),m=!h.partial||f.kind===oe.Query&&f.partial;if(o===X.CacheOnly)return l(i,{fetching:!1,variables:i.variables??null,data:m?h.data:n.data,errors:null,source:Oe.Cache,partial:m?h.partial:!1,stale:h.stale});if(p=!!(h.data!==null&&m),p&&l(i,{fetching:!1,variables:i.variables??null,data:h.data,errors:null,source:Oe.Cache,partial:h.partial,stale:h.stale}),p&&!h.partial&&!h.stale&&i.policy!=="CacheAndNetwork")return}if(r&&setTimeout(()=>{t._internal_unstable.collectGarbage()},0),!((g=i.stuff)!=null&&g.silenceLoading)){let _=null;!p&&"enableLoadingState"in f&&f.enableLoadingState&&(_=t.read({selection:f.selection,variables:c(i),loading:!0}).data),e(!p,_)}return a(i)},afterNetwork(i,{resolve:n,value:a,marshalVariables:l}){var c,o,f;if(i.policy!==X.NoCache&&a.source!==Oe.Cache&&r&&a.data&&!((c=i.cacheParams)!=null&&c.disableWrite)){i.cacheParams&&"serverSideFallback"in i.cacheParams&&(s=((o=i.cacheParams)==null?void 0:o.serverSideFallback)??s);const p=Te&&s?new Ze({disabled:!1}):t;let u;!Te&&((f=i.cacheParams)!=null&&f.layer)&&(u=i.cacheParams.layer.id),p.write({...i.cacheParams,layer:u,selection:i.artifact.selection,data:a.data,variables:l(i)}),a={...a,data:p.read({selection:i.artifact.selection,variables:l(i),ignoreMasking:Te}).data}}n(i,a)}}),Qe={forward:["start","beforeNetwork","network"],backwards:["end","afterNetwork"]};let pe={};var U,me,Q,ee,fe,P,B;class jt extends wt{constructor({artifact:t,plugins:s,pipeline:i,client:n,cache:a,enableCache:l=!0,initialValue:c,initialVariables:o,fetching:f}){f??(f=t.kind===oe.Query);super({data:c??null,errors:null,partial:!1,stale:!1,source:null,fetching:f,variables:o??null},()=>()=>{I(this,ee,null),this.cleanup()});L(this,P);y(this,"artifact");L(this,U);L(this,me);L(this,Q);L(this,ee);L(this,fe,null);y(this,"pendingPromise",null);y(this,"serverSideFallback");this.artifact=t,I(this,U,n),I(this,ee,null),I(this,me,Se()),I(this,Q,i??[Pt({cache:a,enabled:l,setFetching:(u,g)=>{this.update(_=>{const h={..._,fetching:u};return u&&g&&(h.data=g),h})}})(),...s??[]])}controllerKey(t){var i;const s="dedupe"in this.artifact&&((i=this.artifact.dedupe)==null?void 0:i.match)!==yt.Variables?{}:t;return`${this.artifact.name}@${qt(s)}`}async send({metadata:t,session:s,fetch:i,variables:n,policy:a,stuff:l,cacheParams:c,setup:o=!1,silenceEcho:f=!1,abortController:p=new AbortController}={}){if("dedupe"in this.artifact&&this.artifact.dedupe&&this.artifact.dedupe.match!=="None"){const m=this.controllerKey(n);pe[m]?this.artifact.dedupe.cancel==="first"?(pe[m].controller.abort(),pe[m].controller=p):p.abort():pe[m]={variables:n,controller:p}}let u=new Ve({abortController:p,config:b(this,me),name:this.artifact.name,text:this.artifact.raw,hash:this.artifact.hash,policy:a??this.artifact.policy,variables:null,metadata:t,session:s,fetch:i??this.getFetch(()=>s),stuff:{inputs:{changed:!1,init:!1,marshaled:{}},...l},artifact:this.artifact,lastVariables:b(this,ee),cacheParams:c});const g=u.draft();g.variables=n??null,u=u.apply(g,!1);const _=new Promise((m,v)=>{const w={setup:o,currentStep:0,index:0,silenceEcho:f,promise:{resolved:!1,resolve:m,reject:v,then:(...k)=>_.then(...k)},context:u};this.pendingPromise===null&&(this.pendingPromise=w.promise),R(this,P,B).call(this,"forward",w)}),h=await _;return delete pe[this.controllerKey(n)],h}async cleanup(){var t;for(const s of b(this,Q))(t=s.cleanup)==null||t.call(s,b(this,fe))}getFetch(t){return async(s,i)=>{var l;let n="",a=[];if(typeof s=="string"&&(n=s.startsWith("http")?new URL(s).pathname:s),s instanceof URL?n=s.pathname:s instanceof Request&&(n=new URL(s.url).pathname),s instanceof Request){const c=await s.json();Array.isArray(c)||(a=[c])}else{const c=JSON.parse(i==null?void 0:i.body);Array.isArray(c)||(a=[c])}if(!n||a.length===0)return await globalThis.fetch(s,i);if((l=b(this,U))!=null&&l.proxies[n]){const c=await Promise.all(a.map(o=>{var f;return(f=b(this,U))==null?void 0:f.proxies[n]({...o,session:t()})}));return new Response(JSON.stringify(c.length===1?c[0]:c))}return await globalThis.fetch(s,i)}}}U=new WeakMap,me=new WeakMap,Q=new WeakMap,ee=new WeakMap,fe=new WeakMap,P=new WeakSet,B=function(t,s,i){var c;const n=t==="error"?"catch":Qe[t][s.currentStep];let a=o=>o<=b(this,Q).length,l=o=>o+1;["backwards","error"].includes(t)&&(a=o=>o>=0,l=o=>o-1);for(let o=s.index;a(o);o=l(o)){let f=(c=b(this,Q)[o])==null?void 0:c[n];if(!f)continue;const p=s.context.draft();let u=h=>h.variables!==p.variables;const g={initialValue:this.state,client:b(this,U),variablesChanged:zt,marshalVariables:Nt,updateState:this.update.bind(this),next:h=>{const m=["forward","error"].includes(t)?o+1:o,v=["backwards","error"].includes(t)?0:s.currentStep;R(this,P,B).call(this,"forward",{...s,index:m,currentStep:v,context:s.context.apply(h,u(h))})},resolve:(h,m)=>{const v=t==="backwards"?o-1:o;R(this,P,B).call(this,"backwards",{...s,index:v,context:s.context.apply(h,u(h))},m)}};let _;t==="forward"?_=g:t==="backwards"?_={...g,value:i,resolve:(h,m)=>g.resolve(h,m??i)}:t==="error"&&(_={...g,error:i});try{if(p.abortController.signal.aborted){const m=new Error("aborted");throw m.name="AbortError",m}const h=f(p,_);h==null||h.catch(m=>{R(this,P,B).call(this,"error",{...s,index:o-1},m)})}catch(h){R(this,P,B).call(this,"error",{...s,index:o-1},h)}return}if(t==="forward"){if(s.setup)return R(this,P,B).call(this,"backwards",{...s,currentStep:0,index:b(this,Q).length},this.state);if(s.currentStep<=Qe.forward.length-2)return R(this,P,B).call(this,"forward",{...s,currentStep:s.currentStep+1,index:0});throw new Error("Called next() on last possible plugin. Your chain is missing a plugin that calls resolve().")}if(t==="error"){s.promise.resolved||(s.promise.reject(i),s.promise.resolved=!0);return}if(s.currentStep>0)return R(this,P,B).call(this,"backwards",{...s,currentStep:s.currentStep-1,index:b(this,Q).length-1},i);(!s.silenceEcho||i.data!==this.state.data)&&this.set(i),s.promise.resolved||(s.promise.resolve(i),s.promise.resolved=!0),I(this,fe,s.context.draft()),I(this,ee,b(this,fe).stuff.inputs.marshaled)};var te,ue;const Ne=class Ne{constructor({lastVariables:e,...t}){L(this,te);L(this,ue);I(this,te,t),I(this,ue,e)}get variables(){return b(this,te).variables}draft(){const e={...b(this,te)},t=this.applyVariables.bind(this);return{...e,get stuff(){return e.stuff},set stuff(s){e.stuff=s},get variables(){return e.variables??null},set variables(s){Object.assign(e,t(e,{variables:s}))}}}applyVariables(e,t){var o,f;const s=e.artifact,i={...e,...t},n=t.variables;let a={};for(const[p,u]of Object.entries(n??{}))u!==((o=e.variables)==null?void 0:o[p])&&(a[p]=u);i.stuff={...i.stuff,inputs:{...i.stuff.inputs}};const l=!i.stuff.inputs||!i.stuff.inputs.init;if(Object.keys(a).length>0||l){const p={...(f=i.stuff.inputs)==null?void 0:f.marshaled,...Ee({artifact:s,input:a,config:e.config})};i.stuff.inputs={init:!0,marshaled:p,changed:!0},i.variables=n}return i.stuff={...i.stuff,inputs:{...i.stuff.inputs,changed:!ve(i.stuff.inputs.marshaled,b(this,ue))}},i}apply(e,t){return t&&(e=this.applyVariables(b(this,te),e)),new Ne({...e,lastVariables:b(this,ue)})}};te=new WeakMap,ue=new WeakMap;let Ve=Ne;function Nt(r){var e;return((e=r.stuff.inputs)==null?void 0:e.marshaled)??{}}function zt(r){var e;return(e=r.stuff.inputs)==null?void 0:e.changed}function qt(r){return JSON.stringify($e(r))}function $e(r){return r===null||typeof r!="object"?r:Array.isArray(r)?r.map($e):Object.keys(r).sort().reduce((e,t)=>(e[t]=$e(r[t]),e),{})}new TextEncoder;const Bt=ct;let et=!1;function Xt(){et=!0}let J=null;async function tt(){if(J)return J;J=(await Ke(async()=>{const{default:e}=await import("./BMg0R-1a.js");return{default:e}},[])).default;const r=e=>new Promise(t=>setTimeout(t,e));for(let e=0;e<10&&!J;e++)await r(100),J=(await Ke(async()=>{const{default:t}=await import("./BMg0R-1a.js");return{default:t}},[])).default;return J}function He(){if(!J)throw new Error("client hasn't been initialized");return J}const st="__houdini__session__",ke={};let it=ke;function Ce(r){return r[st]}function Zt(r){it=r}async function Je(r){return r?"locals"in r?Ce(r.locals)||ke:"data"in r&&r.data&&st in r.data?Ce(r.data)||ke:Ce(await r.parent())||ke:it}var se,he,G,ie,Y;class Kt{constructor(e){L(this,se);L(this,he);L(this,G,null);L(this,ie,null);L(this,Y,0);typeof e.initialize>"u"&&(e.initialize=!0),I(this,he,new jt({artifact:e.artifact,client:null,fetching:e.fetching,initialValue:e.initialValue})),I(this,se,e)}get artifact(){return b(this,se).artifact}get name(){return this.artifact.name}get observer(){return b(this,ie)?b(this,ie):(I(this,ie,He().observe(b(this,se))),b(this,ie))}subscribe(...e){const t=b(this,he).subscribe(...e);return(b(this,Y)===0||!b(this,G))&&this.setup(),I(this,Y,(b(this,Y)??0)+1),()=>{var s;Be(this,Y)._--,b(this,Y)<=0&&((s=b(this,G))==null||s.call(this),I(this,G,null),t())}}setup(e=!0){let t=Promise.resolve();try{He()}catch{t=tt()}t.then(()=>{if(!b(this,G)&&(I(this,G,this.observer.subscribe(s=>{b(this,he).set(s)})),e&&b(this,se).initialize))return this.observer.send({setup:!0,variables:Me(this.observer).variables})})}}se=new WeakMap,he=new WeakMap,G=new WeakMap,ie=new WeakMap,Y=new WeakMap;class Ut extends Kt{constructor({artifact:t,storeName:s,variables:i}){var a;const n=((a=t.pluginData["houdini-svelte"])==null?void 0:a.isManualLoad)!==!0;super({artifact:t,fetching:n,initialize:!t.pluginData["houdini-svelte"].isManualLoad});y(this,"variables");y(this,"kind",bt);y(this,"loadPending",!1);y(this,"storeName");this.storeName=s,this.variables=i}async fetch(t){var v;const s=await tt();this.setup(!1);const{policy:i,params:n,context:a}=await Wt(this.artifact,this.storeName,t),l=!!("event"in n&&n.event),c=!l;if(this.loadPending&&c)return pt(`⚠️ Encountered fetch from your component while ${this.storeName}.load was running.
This will result in duplicate queries. If you are trying to ensure there is always a good value, please a CachePolicy instead.`),Me(this.observer);c&&(n.blocking=!0);const f=Se().plugins["houdini-svelte"],p=this.artifact.pluginData["houdini-svelte"];let u=!1;(s.throwOnError_operations.includes("all")||s.throwOnError_operations.includes("query"))&&f.defaultRouteBlocking===!1&&gt('[Houdini] ⚠️ throwOnError with operation "all" or "query", is not compatible with defaultRouteBlocking set to "false"'),f.defaultRouteBlocking===!0&&(u=!0),(s.throwOnError_operations.includes("all")||s.throwOnError_operations.includes("query"))&&(u=!0),(p==null?void 0:p.set_blocking)===!0?u=!0:(p==null?void 0:p.set_blocking)===!1&&(u=!1),(n==null?void 0:n.blocking)===!0?u=!0:(n==null?void 0:n.blocking)===!1&&(u=!1),l&&(this.loadPending=!0),this.artifact.enableLoadingState&&(u=!1);const g=et&&Bt&&!u,_={...(v=this.artifact.input)==null?void 0:v.defaults,...n.variables};i!==X.NetworkOnly&&i!==X.NoCache&&g&&await this.observer.send({fetch:a.fetch,variables:_,metadata:n.metadata,session:a.session,policy:X.CacheOnly,silenceEcho:!0,abortController:n.abortController});const m=this.observer.send({fetch:a.fetch,variables:_,metadata:n.metadata,session:a.session,policy:i,stuff:{}});return m.then(w=>{var k;this.loadPending=!1,(k=n.then)==null||k.call(n,w.data)}).catch(()=>{}),g||await m,Me(this.observer)}}async function Wt(r,e,t){let s=t==null?void 0:t.policy;!s&&r.kind===oe.Query&&(s=r.policy??X.CacheOrNetwork);let i=null;t&&("fetch"in t&&t.fetch?i=t.fetch:"event"in t&&t.event&&"fetch"in t.event&&(i=t.event.fetch)),i||(i=globalThis.fetch.bind(globalThis));let n;return t&&"event"in t&&t.event?n=await Je(t.event):n=await Je(),{context:{fetch:i,metadata:(t==null?void 0:t.metadata)??{},session:n},policy:s,params:t??{}}}export{oe as A,Kt as B,Oe as D,Ut as Q,ft as a,Se as b,dt as c,ve as d,H as e,Wt as f,K as g,$t as h,tt as i,jt as j,xe as k,Yt as l,We as m,Gt as n,Ce as o,Xt as p,Zt as s};
