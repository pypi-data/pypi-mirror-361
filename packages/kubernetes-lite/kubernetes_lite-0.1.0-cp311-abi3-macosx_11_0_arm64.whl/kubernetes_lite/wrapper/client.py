
# python wrapper for package github.ibm.com/Michael-Honaker/kubernetes-lite/kubernetes_lite/go_wrapper/pkg/client within overall package wrapper
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -no-make -author=Michael Honaker -email=michael.honaker@ibm.com -name=wrapper github.ibm.com/Michael-Honaker/kubernetes-lite/kubernetes_lite/go_wrapper/pkg/client github.ibm.com/Michael-Honaker/kubernetes-lite/kubernetes_lite/go_wrapper/pkg/envtest/setup github.ibm.com/Michael-Honaker/kubernetes-lite/kubernetes_lite/go_wrapper/pkg/envtest/server

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _wrapper
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from wrapper import client
# and then refer to everything using client. prefix
# packages imported by this package listed below:




# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---
def EmptyEvent():
	"""
	EmptyEvent Gets Go Variable: client.EmptyEvent
	
	"""
	return go.watch_Event(handle=_wrapper.client_EmptyEvent())

def Set_EmptyEvent(value):
	"""
	Set_EmptyEvent Sets Go Variable: client.EmptyEvent
	
	"""
	if isinstance(value, go.GoClass):
		_wrapper.client_Set_EmptyEvent(value.handle)
	else:
		_wrapper.client_Set_EmptyEvent(value)



# ---- Interfaces ---

# Python type for interface client.WrappedDynamicClient
class WrappedDynamicClient(go.GoClass):
	"""Simple dynamic client interface that allows users to create a Resource Interface\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_wrapper.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_wrapper.IncRef(self.handle)
		else:
			self.handle = 0
	def Resource(self, apiVersion, kind):
		"""Resource(str apiVersion, str kind) object, str"""
		return WrappedNamespaceableResourceInterface(handle=_wrapper.client_WrappedDynamicClient_Resource(self.handle, apiVersion, kind))

# Python type for interface client.WrappedNamespaceableResourceInterface
class WrappedNamespaceableResourceInterface(go.GoClass):
	"""WrappedNamespaceableResourceInterface is a wrapper around the ResourceInterface for interacting with\ncluster wide resources. This interface can also be namespace scoped with the Namespace method.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_wrapper.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_wrapper.IncRef(self.handle)
		else:
			self.handle = 0
	def Apply(self, name, obj, opts, *args):
		"""Apply(str name, []int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Apply(self.handle, name, obj.handle, opts.handle, subresources.handle))
	def ApplyStatus(self, name, obj, opts):
		"""ApplyStatus(str name, []int obj, []int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_ApplyStatus(self.handle, name, obj.handle, opts.handle))
	def Create(self, obj, opts, *args):
		"""Create([]int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Create(self.handle, obj.handle, opts.handle, subresources.handle))
	def Delete(self, name, opts, *args):
		"""Delete(str name, []int opts, []str subresources) str"""
		subresources = go.Slice_string(args)
		return _wrapper.client_WrappedNamespaceableResourceInterface_Delete(self.handle, name, opts.handle, subresources.handle)
	def DeleteCollection(self, opts, listOptions):
		"""DeleteCollection([]int opts, []int listOptions) str"""
		return _wrapper.client_WrappedNamespaceableResourceInterface_DeleteCollection(self.handle, opts.handle, listOptions.handle)
	def Get(self, name, opts, *args):
		"""Get(str name, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Get(self.handle, name, opts.handle, subresources.handle))
	def List(self, opts):
		"""List([]int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_List(self.handle, opts.handle))
	def Namespace(self, arg_0):
		"""Namespace(str) object"""
		return WrappedResourceInterface(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Namespace(self.handle, arg_0))
	def Patch(self, name, pt, data, opts, *args):
		"""Patch(str name, str pt, []int data, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Patch(self.handle, name, pt, data.handle, opts.handle, subresources.handle))
	def Update(self, obj, opts, *args):
		"""Update([]int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Update(self.handle, obj.handle, opts.handle, subresources.handle))
	def UpdateStatus(self, obj, opts):
		"""UpdateStatus([]int obj, []int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedNamespaceableResourceInterface_UpdateStatus(self.handle, obj.handle, opts.handle))
	def Watch(self, opts):
		"""Watch([]int opts) object, str"""
		return WrappedWatchInterface(handle=_wrapper.client_WrappedNamespaceableResourceInterface_Watch(self.handle, opts.handle))

# Python type for interface client.WrappedResourceInterface
class WrappedResourceInterface(go.GoClass):
	"""The WrappedResourceInterface is designed to mirror client-go's ResourceInterface with one major\ndifference. Instead of accepting and returning pointers to the various apimachinery types/objects\nit handles everything though binary buffers (*uint16) pointers which greatly simplifies the CGO\nfunction call\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_wrapper.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_wrapper.IncRef(self.handle)
		else:
			self.handle = 0
	def Apply(self, name, obj, opts, *args):
		"""Apply(str name, []int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_Apply(self.handle, name, obj.handle, opts.handle, subresources.handle))
	def ApplyStatus(self, name, obj, opts):
		"""ApplyStatus(str name, []int obj, []int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_ApplyStatus(self.handle, name, obj.handle, opts.handle))
	def Create(self, obj, opts, *args):
		"""Create([]int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_Create(self.handle, obj.handle, opts.handle, subresources.handle))
	def Delete(self, name, opts, *args):
		"""Delete(str name, []int opts, []str subresources) str"""
		subresources = go.Slice_string(args)
		return _wrapper.client_WrappedResourceInterface_Delete(self.handle, name, opts.handle, subresources.handle)
	def DeleteCollection(self, opts, listOptions):
		"""DeleteCollection([]int opts, []int listOptions) str"""
		return _wrapper.client_WrappedResourceInterface_DeleteCollection(self.handle, opts.handle, listOptions.handle)
	def Get(self, name, opts, *args):
		"""Get(str name, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_Get(self.handle, name, opts.handle, subresources.handle))
	def List(self, opts):
		"""List([]int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_List(self.handle, opts.handle))
	def Patch(self, name, pt, data, opts, *args):
		"""Patch(str name, str pt, []int data, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_Patch(self.handle, name, pt, data.handle, opts.handle, subresources.handle))
	def Update(self, obj, opts, *args):
		"""Update([]int obj, []int opts, []str subresources) []int, str"""
		subresources = go.Slice_string(args)
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_Update(self.handle, obj.handle, opts.handle, subresources.handle))
	def UpdateStatus(self, obj, opts):
		"""UpdateStatus([]int obj, []int opts) []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedResourceInterface_UpdateStatus(self.handle, obj.handle, opts.handle))
	def Watch(self, opts):
		"""Watch([]int opts) object, str"""
		return WrappedWatchInterface(handle=_wrapper.client_WrappedResourceInterface_Watch(self.handle, opts.handle))

# Python type for interface client.WrappedWatchInterface
class WrappedWatchInterface(go.GoClass):
	"""WrappedWatchInterface allows CGO applications to iterate over a channel\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_wrapper.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_wrapper.IncRef(self.handle)
		else:
			self.handle = 0
	def Next(self):
		"""Next() []int, str"""
		return go.Slice_byte(handle=_wrapper.client_WrappedWatchInterface_Next(self.handle))
	def Stop(self, goRun=False):
		"""Stop() """
		_wrapper.client_WrappedWatchInterface_Stop(self.handle, goRun)


# ---- Structs ---


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def NewWrappedDynamicClient(qps, burst, timeout):
	"""NewWrappedDynamicClient(float qps, int burst, str timeout) object, str"""
	return WrappedDynamicClient(handle=_wrapper.client_NewWrappedDynamicClient(qps, burst, timeout))
def NewWrappedDynamicClientWithConfig(config, qps, burst, timeout):
	"""NewWrappedDynamicClientWithConfig([]int config, float qps, int burst, str timeout) object, str"""
	return WrappedDynamicClient(handle=_wrapper.client_NewWrappedDynamicClientWithConfig(config.handle, qps, burst, timeout))
def NewWrappedWatchInterface(watcher):
	"""NewWrappedWatchInterface(object watcher) object
	
	Construct a new WrappedWatchInterface from a client-go watch interface
	"""
	return WrappedWatchInterface(handle=_wrapper.client_NewWrappedWatchInterface(watcher.handle))


