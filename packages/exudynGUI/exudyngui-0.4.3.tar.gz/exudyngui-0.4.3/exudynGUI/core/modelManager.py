# -*- coding: utf-8 -*-
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# This file is part of the Exudyn GUI project
#
# Filename: core/modelManager.py
#
# Description:
#     Core model management logic for the Exudyn GUI.
#     Handles creation, editing, and rebuilding of simulation components
#     based on user interactions with the GUI.
#
#     Responsibilities include:
#       - Adding and editing model items via dynamic PyQt forms
#       - Managing unique names and tracking created system components
#       - Handling special fields (graphicsDataList, user functions, inertia, etc.)
#       - Rebuilding the multibody system (`mbs`) from the modelSequence
#       - Maintaining component-to-creation mappings for structure tree rendering
#       - Supporting legacy items and PythonSnippet entries
#
#     Integrates with:
#       - modelData.py: Stores `modelSequence`, `existingNames`, etc.
#       - objectRegistry.py: Maps object types to builder and form logic
#       - fieldMetadata.py: Provides metadata for dynamic form and builder support
#       - autoGeneratedForm.py: Used for interactive form generation
#       - generateCode.py: Generates reproducible Exudyn code from the model
#
# Authors:  Michael Pieber, [Your Name Here if modified]
# Date:     2025-07-03
# License:  BSD-3-Clause License
#
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import exudyn as exu
import exudyn.utilities as exuutils

from exudynGUI.guiForms.addItemDialog import AddItemDialog
from exudynGUI.model.objectRegistry import registry
from exudynGUI.model.modelData import modelSequence
from exudynGUI.core.debug import debugLog
from exudynGUI.core.fieldMetadata import getDefaultsFor, getDependencyHints, hasDependencies
from exudynGUI.guiForms.autoGeneratedForm import AutoGeneratedForm
from exudynGUI.core.extractModelStructure import extractModelStructure
from exudynGUI.functions import userFunctions
from exudynGUI.core.generateCode import generateExudynCodeFromItems
from exudynGUI.core.qtImports import QTreeWidgetItem, QListWidgetItem, Qt
from exudynGUI.core.specialFields import resolveUserFunction
import exudynGUI.functions.userFunctions as userFunctions
from exudynGUI.model.modelData import existingNames
from exudynGUI.model.modelData import getNextCreationIndex
from exudynGUI.model.objectRegistry import returnKeyToGroup, findRegistryCategoryByShortType
import sys
# Use relative import for main.py functions
from core.rendererState import saveRendererStateFor, restoreRendererStateFor


import ast
import types
import importlib
from pprint import pformat
from copy import deepcopy
import re
import uuid
from PyQt5.QtWidgets import QMessageBox, QWidget

componentToCreate = {}
usedUIDs = set()

def initSystem():
    SC2 = exu.SystemContainer()
    mbs2 = SC2.AddSystem()
    return SC2, mbs2

def generateUniqueName(baseName, existingNames):
    """Generate a unique name by checking if the provided name is unique, 
    or finding the lowest available numbered suffix.
    
    Args:
        baseName: The desired name (e.g., 'MassPoint1' or 'MassPoint')
        existingNames: List/set of existing names to avoid
        
    Returns:
        A unique name - the original if unique, or a numbered variant if not
    """
    if not isinstance(existingNames, set):
        existingNames = set(existingNames)
    
    # First check if the provided name is already unique
    if baseName not in existingNames:
        return baseName
    
    # If not unique, extract the base name and find a numbered suffix
    import re
    
    # Try to extract base name and existing number
    match = re.match(r'^(.+?)(\d+)$', baseName)
    if match:
        # Input has a number, use the part before the number as base
        actual_base = match.group(1)
        existing_number = int(match.group(2))
    else:
        # Input has no number, treat whole thing as base
        actual_base = baseName
        existing_number = 0
    
    pattern = re.compile(rf"^{re.escape(actual_base)}(\d+)$")
    
    # Collect all existing numbers for this base name
    existing_numbers = set()
    for name in existingNames:
        if name == actual_base:
            existing_numbers.add(0)  # Base name without number counts as 0
        else:
            match = pattern.match(name)
            if match:
                num = int(match.group(1))
                existing_numbers.add(num)
    
    # Find the lowest available number starting from existing_number + 1
    index = max(1, existing_number + 1)
    while index in existing_numbers:
        index += 1
    
    return f"{actual_base}{index}"

def rebindUserFunctions(data):
    """Replace string references to UF* functions with actual callables from globals()."""
    for k, v in data.items():
        if k.endswith("UserFunction"):
            if isinstance(v, str) and v.startswith("UF") and v in globals():
                data[k] = globals()[v]

def convertGraphicsDataListToCompactFormat(data):
    """Convert graphicsDataList from dict format to compact string format for model storage.
    
    This function ensures that graphics data is always stored in the modelSequence
    in the compact string format (e.g., 'exu.graphics.Sphere(...)'), which is the
    only source of truth for persistent graphics data.
    
    This should be called whenever data from a GUI form is saved to the modelSequence,
    including in addItemToModel() and editModelItem() functions.
    
    The GUI widgets provide the actual values to be stored - this function never
    injects defaults from any registry or static template.
    """
    if 'graphicsDataList' in data:
        gdl = data['graphicsDataList']
        new_gdl = []
        for g in gdl:
            if isinstance(g, dict) and 'name' in g and 'args' in g:
                clean_name = g['name'].replace('GraphicsData', '')  # optional cleanup
                new_gdl.append(f"exu.graphics.{clean_name}({g['args']})")
            else:
                new_gdl.append(str(g))  # fallback
        data['graphicsDataList'] = new_gdl
        debugLog(f"[convertGraphicsDataListToCompactFormat] Converted to compact format: {new_gdl}", origin="modelManager.py")

def convertCompactStringToDict(compact_string):
    """Convert compact string format back to dict format for form editing.
    
    Converts 'exu.graphics.Sphere(radius=0.1, color=[1,0,0,1])' 
    back to {'name': 'Sphere', 'args': 'radius=0.1, color=[1,0,0,1]'}
    
    This is needed when loading existing data into forms for editing.
    """
    if not isinstance(compact_string, str):
        return compact_string
    
    if not compact_string.startswith('exu.graphics.'):
        return compact_string
    
    try:
        # Extract the function name and arguments
        # Example: 'exu.graphics.Sphere(radius=0.1, color=[1,0,0,1])'
        prefix_removed = compact_string[len('exu.graphics.'):]  # 'Sphere(radius=0.1, color=[1,0,0,1])'
        
        if '(' not in prefix_removed or not prefix_removed.endswith(')'):
            return compact_string
        
        name = prefix_removed[:prefix_removed.index('(')]  # 'Sphere'
        args = prefix_removed[prefix_removed.index('(')+1:-1]  # 'radius=0.1, color=[1,0,0,1]'
        
        return {'name': name, 'args': args}
        
    except Exception as e:
        debugLog(f"[convertCompactStringToDict] ‚ö†Ô∏è Failed to parse compact string '{compact_string}': {e}", origin="modelManager.py")
        return compact_string

def convertGraphicsDataListForEditing(data):
    """Convert graphicsDataList from compact string format to dict format for form editing.
    
    This function ensures that when editing existing items, the graphics data is converted
    back to the dictionary format that the GUI forms expect.
    """
    if 'graphicsDataList' in data and isinstance(data['graphicsDataList'], list):
        converted_gdl = []
        for g in data['graphicsDataList']:
            if isinstance(g, str) and g.startswith('exu.graphics.'):
                # Convert compact string back to dict format
                converted = convertCompactStringToDict(g)
                converted_gdl.append(converted)
            else:
                # Keep dict format as-is
                converted_gdl.append(g)
        data['graphicsDataList'] = converted_gdl
        debugLog(f"[convertGraphicsDataListForEditing] Converted for editing: {converted_gdl}", origin="modelManager.py")

# ‚îÄ‚îÄ‚îÄ Extract short type from full Exudyn name ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def extractShortType(fullType):
    for prefix in ['Object', 'Node', 'Marker', 'Sensor', 'Load']:
        if fullType.startswith(prefix):
            return fullType[len(prefix):]
    return fullType




# ‚îÄ‚îÄ‚îÄ Utility for clean labels ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def formatComponentLabel(compType, index, data=None, objTypeHint=None, **kwargs):
    # Build base label
    baseType = compType[:-1] if compType.endswith('s') else compType
    label = f"[{baseType.capitalize()} {index}]"

    # Try to get type name from data or hint
    typeName = None
    if isinstance(data, dict):
        typeName = data.get(f'{baseType}Type', objTypeHint)
    if not typeName:
        typeName = objTypeHint or '?'
    label += f" ({typeName})"

    # Try to append category if possible
    try:
        from model.objectRegistry import findRegistryCategoryByShortType
        shortType = extractShortType(typeName)
        if shortType and shortType.lower() not in ["unknown", "unknownunknown"]:
            category, _ = findRegistryCategoryByShortType(shortType)
            if category:
                label += f" ({category})"
    except Exception as e:
        debugLog(f"[formatComponentLabel] ‚ö†Ô∏è Category error: {e}", origin="modelManager.py")

    return label









def getComponentTypeFromIndex(mbs, idx):
    try:
        mbs.GetObject(idx)
        return "objects"
    except:
        pass
    try:
        mbs.GetNode(idx)
        return "nodes"
    except:
        pass
    try:
        mbs.GetMarker(idx)
        return "markers"
    except:
        pass
    try:
        mbs.GetLoad(idx)
        return "loads"
    except:
        pass
    try:
        mbs.GetSensor(idx)
        return "sensors"
    except:
        pass
    return "unknown"








def addItemToModel(typeName, parentWindow, previewData=None):
    import sys
    # Use the modelSequence from parentWindow instead of importing it
    modelSequence = parentWindow.modelSequence
    debugLog("[DEBUG] addItemToModel called, modelSequence id:", id(modelSequence), "module:", sys.modules[modelSequence.__class__.__module__])
    
    formClass = registry[typeName]['form']
    # Fix: Only include non-empty names from existing items
    existingNames = []
    for item in parentWindow.modelSequence:
        name = item.get('data', {}).get('name', '')
        if name.strip():  # Only include non-empty names
            existingNames.append(name)
    debugLog(f"üö® [addItemToModel] URGENT DEBUG: Extracted existingNames = {existingNames}")
    debugLog(f"üö® [addItemToModel] URGENT DEBUG: parentWindow.modelSequence length = {len(parentWindow.modelSequence)}")
    debugLog(f"üö® [addItemToModel] URGENT DEBUG: Raw item names = {[item.get('data', {}).get('name', '<NO_NAME>') for item in parentWindow.modelSequence]}")
    debugLog(f"[addItemToModel] üìã Existing names extracted: {existingNames}", origin="modelManager.py")    # Instantiate and show the dialog with error protection
    if previewData is not None:
        data = previewData
    else:
        try:
            # Pass SC from parent window to enable highlighting functionality
            SC = getattr(parentWindow, 'SC', None)
            # NEW: Extract structure for dropdowns (objects, nodes, etc.)
            structure = getattr(parentWindow, 'structure', None)
            if structure is None or not structure:
                # Fallback: extract from mbs if not present
                structure, _ = extractModelStructure(parentWindow.mbs)
            form = formClass(typeName, parent=parentWindow, SC=SC, structure=structure)
            form.existingNames = existingNames
            debugLog(f"üö® [addItemToModel] URGENT DEBUG: Set form.existingNames = {form.existingNames}")
            debugLog(f"[addItemToModel] üìã Set form.existingNames to: {form.existingNames}", origin="modelManager.py")
            if SC:
                debugLog(f"‚úÖ [addItemToModel] Passed SC to form: {type(SC)}", origin="modelManager.py")
            else:
                debugLog(f"‚ö†Ô∏è [addItemToModel] No SC available in parentWindow", origin="modelManager.py")
        except Exception as e:
            debugLog(f"‚ùå [addItemToModel] Failed to create form for {typeName}: {e}", origin="modelManager.py")
            # Show error dialog to user instead of crashing GUI
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.critical(
                parentWindow,
                "Form Creation Error",
                f"Failed to create form for {typeName}:\n\n{str(e)}\n\nThe GUI will continue running normally."        )
            return None    # === PRESERVE OPENGL WINDOW STATE DURING FORM DISPLAY ===
        # This prevents the OpenGL window from closing when modal forms are shown
        captured_view_state = None  # Initialize outside try block to avoid NameError
    
        try:
            from guiForms.exudynNativeRenderer import keepOpenGLActive, deactivateOpenGL, restoreRendererAfterPreview
            from PyQt5.QtCore import QTimer
            
            # Activate OpenGL preservation before showing form
            keepOpenGLActive()
            debugLog("[addItemToModel] üîß Activated OpenGL preservation for form display", origin="modelManager.py")
            
            result = form.exec_()
            debugLog(f"[addItemToModel] üîÑ form.exec_() returned: {result}", origin="modelManager.py")

        except ImportError:
            # Fallback if OpenGL preservation is not available
            debugLog("[addItemToModel] ‚ö†Ô∏è OpenGL preservation not available, using standard form display", origin="modelManager.py")
            
            result = form.exec_()
            debugLog(f"[addItemToModel] üîÑ form.exec_() returned: {result}", origin="modelManager.py")

        if not result:
            debugLog(f"[addItemToModel] ‚ùå Form cancelled ‚Äî skipping creation", origin="modelManager.py")
            return None

        data = form.get_data()
        debugLog(f"[addItemToModel] form.get_data() returned: {data}", origin="modelManager.py")

    # --- Ensure all *UserFunction fields are stored as string names ---
    for k, v in data.items():
        if k.endswith('UserFunction'):
            if callable(v):
                data[k] = v.__name__
            elif v in (None, 0, '0', ''):
                data[k] = 0

    # --- General patch: convert EXUmath::unitMatrix3D/zeroMatrix3D to correct matrix for all Matrix3D fields ---
    from core.fieldMetadata import getFieldMetadataFor
    fieldMetadata = getFieldMetadataFor(typeName) if 'getFieldMetadataFor' in globals() else None
    for k in list(data.keys()):
        val = data[k]
        meta = fieldMetadata.get(k, {}) if fieldMetadata else {}
        is_matrix3d = (meta.get('type', '').lower() == 'matrix3d') or (k.lower().endswith('rotation') or k.lower().startswith('rotationmarker'))
        if is_matrix3d and isinstance(val, str):
            if 'EXUmath::unitMatrix3D' in val:
                data[k] = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
            elif 'EXUmath::zeroMatrix3D' in val:
                data[k] = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]

    def tryFixAndParseList(s):
        if isinstance(s, str):
            try:
                s = s.replace('\n', ' ')
                s = s.strip()
    
                # Add commas between numbers (floats or ints)
                s = re.sub(r'(?<=[\d\.])\s+(?=[\d\.\-])', ', ', s)
    
                # Fix list of lists (e.g., ][ ‚Üí ], [)
                s = re.sub(r'\]\s*\[', '], [', s)
    
                # Ensure outer brackets
                if not (s.startswith('[') and s.endswith(']')):
                    s = f"[{s}]"
    
                # Evaluate into real Python list
                return ast.literal_eval(s)
    
            except Exception as e:
                debugLog(f"[tryFixAndParseList] ‚ö†Ô∏è Could not parse '{s}': {e}")
        return s

    # üîß Get correct metadata for this item
    # fieldMetadata = getFieldMetadataFor(typeName)
    for k, v in data.items():
        if isinstance(v, str) and ('[' in v and ']' in v):
            fixed = tryFixAndParseList(v)
            if fixed != v:
                debugLog(f"üõ†Ô∏è {k}: {v} ‚Üí {fixed}")
                data[k] = fixed

    if data is None:
        debugLog(f"[addItemToModel] ‚ùå get_data() returned None for {typeName}", origin="modelManager.py")
        return None



    # Assign unique UID
    data['creationUID'] = str(uuid.uuid4())
    if data['creationUID'] in usedUIDs:
        debugLog(f"‚ö†Ô∏è Skipping duplicate creationUID: {data['creationUID']}")
        return
    usedUIDs.add(data['creationUID'])
    data['objectType'] = typeName

    debugLog(f"[addItemToModel] ‚úÖ UID accepted: {data['creationUID']}", origin="modelManager.py")

    # Save snapshot before build for diff computation
    def getAllComponents(mbs):
        return {
            'nodes': set(range(mbs.systemData.NumberOfNodes())),
            'markers': set(range(mbs.systemData.NumberOfMarkers())),
            'objects': set(range(mbs.systemData.NumberOfObjects())),
            'loads': set(range(mbs.systemData.NumberOfLoads())),            'sensors': set(range(mbs.systemData.NumberOfSensors())),
        }
    
    parentWindow.componentSnapshotBeforeBuild = getAllComponents(parentWindow.mbs)
    builder = registry[typeName]['builder']
    
    # üîß CRITICAL FIX: Resolve user functions BEFORE calling the builder
    # This ensures Exudyn gets function objects, not strings
    for key in data:
        if key.endswith('UserFunction'):
            orig = data[key]
            try:
                from exudynGUI.core.specialFields import resolveUserFunction
                resolved_func = resolveUserFunction(orig)
                if callable(resolved_func) and hasattr(resolved_func, '__code__'):
                    data[key] = resolved_func
                    debugLog(f"[addItemToModel] ‚úÖ Resolved user function {key} = '{orig}' ‚Üí {resolved_func}", origin="modelManager.py")
                else:
                    debugLog(f"[addItemToModel] ‚ö†Ô∏è User function {key} = '{orig}' not resolved to valid function, using 0", origin="modelManager.py")
                    data[key] = 0
            except Exception as e:
                debugLog(f"[addItemToModel] ‚ùå Failed to resolve user function {key} = '{orig}': {e}", origin="modelManager.py")
                data[key] = 0

    debugLog(f"[addItemToModel] üöÄ Calling builder {builder.__name__} with:\n{pformat(data)}", origin="modelManager.py")

    # === REMOVE VIEW STATE PRESERVATION FROM HERE ===
    # view_state = saveRendererStateFor(parentWindow)

    # === CALL BUILDER AND RESTORE VIEW STATE ===
    try:
        debugLog(f"[addItemToModel] üöÄ Building {typeName}", origin="modelManager.py")
        # Pass snippet variables to builder for variable resolution
        snippet_vars = getattr(parentWindow, 'snippetVariables', {})
        result = builder(parentWindow.mbs, data, snippet_vars)
        debugLog(f"[addItemToModel] ‚úÖ Builder completed successfully", origin="modelManager.py")
    except Exception as e:
        debugLog(f"[addItemToModel] ‚ùå Builder failed: {e}", origin="modelManager.py")
        raise


    if isinstance(result, dict):
        # ‚úÖ PRESERVE ACTUAL RETURN VALUES: Don't "correct" them, use what Exudyn actually returns
        # The result contains the real return values from the Exudyn API
        # üîß PROTECTION: Prevent circular reference if result is the same object as data
        if id(result) == id(data):
            # The builder returned the same data object - extract only return value fields
            return_fields = {}
            for key in ['objectNumber', 'bodyNumber', 'nodeNumber', 'markerNumber', 'loadNumber', 'sensorNumber']:
                if key in result:
                    return_fields[key] = result[key]
            data['returnValues'] = return_fields
            debugLog(f"[addItemToModel] üîß Prevented circular reference, extracted return fields: {return_fields}", origin="modelManager.py")
        else:
            data['returnValues'] = result
        
        # üîß Apply correct return values based on object type (fix CreateForce objectNumber -> loadNumber)
        corrected_return_values = correctReturnValues(typeName, data['returnValues'])
        data['returnValues'] = corrected_return_values
        
        # Also update GUI.returnValues to be consistent
        if 'GUI' not in data:
            data['GUI'] = {}
        data['GUI']['returnValues'] = corrected_return_values.copy()  # Use copy to avoid reference issues
        
        # üîß NOTE: creationUID is GUI metadata, NOT an Exudyn return value - don't add it to result
        debugLog(f"[addItemToModel] üìù Preserved actual returnValues from Exudyn: {data['returnValues']}", origin="modelManager.py")
        
        # Extract primary index - for forces/torques, prioritize loadNumber over objectNumber
        if typeName.lower().startswith('createforce') or typeName.lower().startswith('createtorque'):
            # For forces/torques, use loadNumber as primary identifier
            for key in ['loadNumber', 'bodyNumber', 'nodeNumber', 'markerNumber', 'objectNumber', 'sensorNumber']:
                if key in result:
                    data['objIndex'] = result[key]
                    break
            else:
                data['objIndex'] = None
        else:
            # For other types, use the original order
            for key in ['objectNumber', 'bodyNumber', 'nodeNumber', 'markerNumber', 'loadNumber', 'sensorNumber']:
                if key in result:
                    data['objIndex'] = result[key]
                    break
            else:
                data['objIndex'] = None
            
        data['returnInfo'] = " / ".join(f"{k}={v}" for k, v in data['returnValues'].items() if isinstance(v, int))
        
    else:
        # Fallback if builder returns int directly
        data['objIndex'] = int(result) if hasattr(result, '__index__') else None
        data['returnInfo'] = f"Created ID {data['objIndex']}"
        
        # üîß FIX: Store return value with appropriate key name based on object type
        if isinstance(result, dict):
            data['returnValues'] = result
        else:            # Determine appropriate key name based on object type
            if typeName.lower().startswith('createforce') or typeName.lower().startswith('createtorque'):
                key_name = 'loadNumber'
            elif typeName.lower().startswith('createground') or typeName.lower().startswith('createmasspoint') or typeName.lower().startswith('createrigidbody'):
                key_name = 'bodyNumber'
            elif typeName.lower().startswith('createdistancesensor'):
                key_name = 'sensorNumber'
            elif typeName.lower().startswith('createcartesian') or typeName.lower().startswith('createspring') or typeName.lower().startswith('createjoint'):
                key_name = 'objectNumber'
            else:
                key_name = 'objectNumber'  # Default fallback
            
            data['returnValues'] = {key_name: data['objIndex']}

        debugLog(f"[addItemToModel] ‚úÖ Builder returned:\n{pformat(result)}", origin="modelManager.py")
        debugLog(f"[addItemToModel] üîß Corrected returnValues:\n{pformat(data['returnValues'])}", origin="modelManager.py")



    # Track created components if this is a Create* function
    if typeName.startswith("Create"):
        mbs = parentWindow.mbs
        current = getAllComponents(mbs)
        previous = getattr(parentWindow, 'componentSnapshotBeforeBuild', None)

        if previous:
            diff = {k: current[k] - previous[k] for k in current}
            idx = len(modelSequence)  # about to be appended
            parentWindow.createToComponents[idx] = diff

            # Remove self-import - componentToCreate is already defined in this module
            for group, indices in diff.items():
                for ID in indices:
                    componentToCreate[f"{group[:-1]}_{ID}"] = idx
        else:
            debugLog("‚ö†Ô∏è No component snapshot before build ‚Äî cannot compute diff.")    # Store in model sequence
    # Convert graphicsDataList to compact string format for persistent storage
    convertGraphicsDataListToCompactFormat(data)
    
    # üîß CRITICAL FIX: Ensure user functions are stored as strings, not function objects
    # This prevents issues with deepcopy and serialization
    data_for_storage = deepcopy(data)
    for k, v in data_for_storage.items():
        if k.endswith('UserFunction') and callable(v):
            data_for_storage[k] = v.__name__
            debugLog(f"[addItemToModel] üîß Converted user function {k} to string: {v.__name__}", origin="modelManager.py")

    modelSequence.append({'type': typeName, 'data': data_for_storage})
    debugLog(f"[addItemToModel] ‚úÖ Stored objIndex={data.get('objIndex')}", origin="modelManager.py")
    
    # Return the index of the newly added item
    return len(modelSequence) - 1

def editModelItem(index, parentWindow):
    modelSequence = parentWindow.modelSequence  # Always use the instance from parentWindow
    if index < 0 or index >= len(modelSequence):
        debugLog(f"[editModelItem] Invalid index: {index}", origin="modelManager.py")
        return False, None
    # ‚úÖ Rebuild system first so structure is fresh

    state = saveRendererStateFor(parentWindow)
    parentWindow.buildSystemAndShow()


    restoreRendererStateFor(parentWindow, state, 1000)

    entry = modelSequence[index]
    typeName = entry['type']
    oldData = entry['data']
    import types
    oldData = oldData.copy()
    for k, v in oldData.items():
        if isinstance(v, types.FunctionType):
            oldData[k] = v.__name__
      # Convert graphics data from compact string format back to dict format for editing
    convertGraphicsDataListForEditing(oldData)
    
    debugLog(f"[editModelItem] Opening form for type: {typeName}", origin="modelManager.py")
      # Get existing names for name collision detection (exclude current item and empty names)
    existingNames = []
    for i, item in enumerate(parentWindow.modelSequence):
        if i != index:  # Exclude the current item being edited
            name = item.get('data', {}).get('name', '')
            if name.strip():  # Only include non-empty names
                existingNames.append(name)
    
    debugLog(f"üö® [editModelItem] URGENT DEBUG: Extracted existingNames = {existingNames}")
    debugLog(f"üö® [editModelItem] URGENT DEBUG: Editing index {index}, modelSequence length = {len(parentWindow.modelSequence)}")
    debugLog(f"üö® [editModelItem] URGENT DEBUG: Raw item names = {[item.get('data', {}).get('name', '<NO_NAME>') for item in parentWindow.modelSequence]}")

    try:
        # Pass SC from parent window to enable highlighting functionality
        SC = getattr(parentWindow, 'SC', None)
        form = registry[typeName]['form'](typeName, existingData=oldData, parent=parentWindow, structure=parentWindow.structure, SC=SC)
        form.existingNames = existingNames  # Set existingNames for name collision detection
        if SC:
            debugLog(f"‚úÖ [editModelItem] Passed SC to form: {type(SC)}", origin="modelManager.py")
        else:
            debugLog(f"‚ö†Ô∏è [editModelItem] No SC available in parentWindow", origin="modelManager.py")
    except Exception as e:
        debugLog(f"[editModelItem] ‚ùå Failed to create form: {e}", origin="modelManager.py")
        import traceback
        traceback.print_exc()
        return False, None    # === PRESERVE OPENGL WINDOW STATE DURING FORM DISPLAY ===
    # This prevents the OpenGL window from closing when modal forms are shown
    
    form_accepted = form.exec_()


    
    if form_accepted:
        newData = form.get_data()
        debugLog(f"[EditSelected] Received data from form: {newData}", origin="modelManager.py:editModelItem")
        newData['objectType'] = typeName
        
        # Handle user functions
        for k, v in newData.items():
            if k.endswith('UserFunction'):
                if callable(v):
                    newData[k] = v.__name__
                elif v in (None, 0, '0', ''):
                    newData[k] = 0
        
        # Convert graphicsDataList to compact string format for persistent storage
        convertGraphicsDataListToCompactFormat(newData)
        
        import importlib
        importlib.reload(userFunctions)
        globals().update({k: v for k, v in userFunctions.__dict__.items() if k.startswith("UF")})
        debugLog(f"[EditSelected] ‚≠Æ Reloaded userFunctions after form edit", origin="modelManager.py:editModelItem")
        
        for key in ['objIndex', 'returnInfo', 'nodeNumber', 'markerNumber', 'objectNumber', 'sensorNumber', 'returnValues', 'returnDict']:
            if key in oldData and key not in newData:
                newData[key] = oldData[key]        
        modelSequence[index]['data'] = newData
        debugLog(f"[editModelItem] Form submitted with data: {newData}", origin="modelManager.py")
        debugLog(f"[editModelItem] Updated modelSequence entry at index {index}", origin="modelManager.py")
        
        # === REBUILD SYSTEM TO REFLECT CHANGES ===
        parentWindow.buildSystemAndShow()
        debugLog("[editModelItem] System rebuilt after edit", origin="modelManager.py")
        
        return True, oldData
    return False, None

def copyModelItem(index, parentWindow):
    """
    Copy an existing model item and open AutoGeneratedForm for duplication.
    Similar to editModelItem but creates a new item instead of replacing the existing one.
    """
    modelSequence = parentWindow.modelSequence
    if index < 0 or index >= len(modelSequence):
        debugLog(f"[copyModelItem] ‚ùå Invalid index {index}", origin="modelManager.py")
        return False, None

    # Save renderer state
    state = saveRendererStateFor(parentWindow)
    parentWindow.buildSystemAndShow()
    restoreRendererStateFor(parentWindow, state, 1000)

    entry = modelSequence[index]
    typeName = entry['type']
    originalData = entry['data']
    
    # Deep copy the original data to avoid modifying it
    copiedData = deepcopy(originalData)
    
    # Handle function types (convert to string representation)
    for k, v in copiedData.items():
        if isinstance(v, types.FunctionType):
            copiedData[k] = v.__name__

    # Convert graphics data from compact string format back to dict format for editing
    convertGraphicsDataListForEditing(copiedData)
    
    # Generate a unique name for the copy
    originalName = copiedData.get('name', typeName)
    baseName = f"{originalName}_copy"
    
    # Get existing names for collision detection
    existingNames = []
    for i, item in enumerate(parentWindow.modelSequence):
        name = item.get('data', {}).get('name', '')
        if name.strip():
            existingNames.append(name)
    
    # Generate unique name
    uniqueName = generateUniqueName(baseName, existingNames)
    copiedData['name'] = uniqueName
    
    # Remove any fields that should be regenerated for the copy
    fieldsToRemove = ['objIndex', 'returnValues', 'returnInfo', 'creationIndex', 'creationUID']
    for field in fieldsToRemove:
        copiedData.pop(field, None)
    
    debugLog(f"[copyModelItem] Opening form for copy of type: {typeName}", origin="modelManager.py")
    debugLog(f"[copyModelItem] Original name: '{originalName}' ‚Üí Copy name: '{uniqueName}'", origin="modelManager.py")

    try:
        # Pass SC from parent window to enable highlighting functionality
        SC = getattr(parentWindow, 'SC', None)
        form = registry[typeName]['form'](typeName, existingData=copiedData, parent=parentWindow, structure=parentWindow.structure, SC=SC)
        form.existingNames = existingNames
        if SC:
            debugLog(f"‚úÖ [copyModelItem] Passed SC to form: {type(SC)}", origin="modelManager.py")
        else:
            debugLog(f"‚ö†Ô∏è [copyModelItem] No SC available in parentWindow", origin="modelManager.py")
    except Exception as e:
        debugLog(f"[copyModelItem] ‚ùå Failed to create form: {e}", origin="modelManager.py")
        import traceback
        traceback.print_exc()
        return False, None

    # Execute the form
    form_accepted = form.exec_()

    if form_accepted:
        newData = form.get_data()
        debugLog(f"[copyModelItem] Received data from form: {newData}", origin="modelManager.py")
        newData['objectType'] = typeName
        
        # Handle user functions
        for k, v in newData.items():
            if k.endswith('UserFunction'):
                if callable(v):
                    newData[k] = v.__name__
                elif v in (None, 0, '0', ''):
                    newData[k] = 0
        
        # Convert graphicsDataList to compact string format for persistent storage
        convertGraphicsDataListToCompactFormat(newData)
        
        # Reload user functions
        import importlib
        importlib.reload(userFunctions)
        globals().update({k: v for k, v in userFunctions.__dict__.items() if k.startswith("UF")})
        
        # Add the new item to the model sequence
        newEntry = {
            'type': typeName,
            'data': newData
        }
        parentWindow.modelSequence.append(newEntry)
        
        debugLog(f"[copyModelItem] ‚úÖ Successfully copied item as '{newData.get('name', 'Unknown')}'", origin="modelManager.py")
        debugLog(f"[copyModelItem] Added new entry at index {len(parentWindow.modelSequence) - 1}", origin="modelManager.py")
        
        # Rebuild system to reflect changes
        parentWindow.buildSystemAndShow()
        
        return True, newData
    
    return False, None

def removeModelItem(index, parentWindow):
    modelSequence = parentWindow.modelSequence
    if index < 0 or index >= len(modelSequence):
        return None
    return modelSequence.pop(index)

def undoLastAction(undoStack, parentWindow):
    modelSequence = parentWindow.modelSequence
    if not undoStack:
        return False
    last = undoStack.pop()
    action = last['action']
    index = last['index']

    if action == 'add':
        if 0 <= index < len(modelSequence):
            modelSequence.pop(index)
    elif action == 'remove':
        modelSequence.insert(index, last['oldData'])
    elif action == 'edit':
        modelSequence[index]['data'] = last['oldData']
    return True

def labelToKey(label):
    import re
    match = re.match(r'([a-z]+)(\d+)', label)
    if match:
        field, index = match.groups()
        fieldMap = {
            'object': 'objectNumber',
            'node': 'nodeNumber',
            'marker': 'markerNumbers',
            'load': 'loadNumber',
            'sensor': 'sensorNumber'
        }
        return f"{fieldMap.get(field, field)}:{index}"
    return None



def extractStructureInfo(parentWindow):
    structureBefore, _  = extractModelStructure(parentWindow.mbs)
    parentWindow.structureTree.clear()

    categoryMap = {
        'Create': 'Create (Helpers)',
        'Object': 'Objects (Body)',
        'Node': 'Nodes',
        'Marker': 'Markers',
        'Load': 'Loads',
        'Sensor': 'Sensors'
    }

    categorized = {cat: [] for cat in categoryMap.values()}


    for i, item in enumerate(modelSequence):
        objType = item['type']
        data = item['data']
        label = f"{objType} [Index {i}] [Created ID {data.get('objIndex', '?')}]"
        retVals = data.get('returnValues', {})
        # Use the original constructor if this is a Create* object
        if objType.startswith("Create") or data.get("objectType", "").startswith("Create"):
            pass  # proceed
        else:
            continue
        
            label = f"{objType} [Index {i}] [Created ID {data.get('objIndex', '?')}]"
            entry = QTreeWidgetItem(parentWindow.structureTree, [label])
    
            # Optional: add Return Variables if any
            retVals = data.get('returnValues', {})
            if isinstance(retVals, dict) and retVals:
                retVarsItem = QTreeWidgetItem(entry, ["Return Variables"])
                # Strong map for return key ‚Üí component group
                keyToGroup = {
                    'nodeNumber': 'nodes',
                    'markerNumber': 'markers',
                    'objectNumber': 'objects',
                    'bodyNumber': 'objects',
                    'loadNumber': 'loads',
                    'sensorNumber': 'sensors',
                }
                
                # Only include in "Created items" if returnValue[key] is NEW
                for key, val in retVals.items():
                    if key in PRIMARY_RETURN_KEYS:
                        continue  # Already shown
                
                    group = keyToGroup.get(key)
                    if not group:
                        continue  # Unknown type
                
                    createdIDs = components.get(group, set())
                    if isinstance(val, int) and val in createdIDs:
                        objTypeHint = parentWindow.componentIndexToType.get(group, {}).get(val)
                        label = formatComponentLabel(group, val, inferred=key, sourceMapping=retVals, objTypeHint=objTypeHint)
                        QTreeWidgetItem(createdItem, [label])
                    elif isinstance(val, list):
                        for v in val:
                            if v in createdIDs:
                                objTypeHint = parentWindow.componentIndexToType.get(group, {}).get(v)
                                label = formatComponentLabel(group, v, inferred=key, sourceMapping=retVals, objTypeHint=objTypeHint)
                                QTreeWidgetItem(createdItem, [label])
    
        if objType.startswith("Create"):
            createItem = QTreeWidgetItem(parentWindow.structureTree, [label])
    
            # Add Return Variables only here (Create items)
            retVarsItem = QTreeWidgetItem(createItem, ["Return Variables"])
            for key, val in retVals.items():
                valStr = ', '.join(str(x) for x in val) if isinstance(val, list) else str(val)
                QTreeWidgetItem(retVarsItem, [f"{key}: {valStr}"])
            retVarsItem.setExpanded(True)

            debugLog(f"[DEBUG] üîé parentWindow.createToComponents keys: {list(parentWindow.createToComponents.keys())}")
            debugLog(f"[DEBUG] üîé createToComponents[{i}] = {parentWindow.createToComponents.get(i)}")
    
            # Add Created Components here
            components = deepcopy(parentWindow.createToComponents.get(i, {}))
            if components:
                createdCompItem = QTreeWidgetItem(createItem, ["Created Components"])
                debugLog(f"üîß createToComponents for index {i} = {components}")
                for compType, compList in components.items():
                    for idx in compList:
                        inferred = parentWindow.inferredComponentTypes.get(compType, {}).get(idx)
                        name = parentWindow.mbs.GetName(compType[:-1].capitalize(), idx) if hasattr(parentWindow.mbs, 'GetName') else None
                        objTypeHint = parentWindow.componentIndexToType.get(compType, {}).get(idx, None)
                        label = formatComponentLabel(
                            compType, idx,
                            inferred=inferred,
                            objTypeHint=objTypeHint,
                            sourceMapping=retVals,
                            mbs=parentWindow.mbs
                        )
                        QTreeWidgetItem(createdCompItem, [label])
                createdCompItem.setExpanded(True)
    
            createItem.setExpanded(True)
    
        else:
            # No Return Variables for non-create items
            catItem = QTreeWidgetItem(parentWindow.structureTree, [label])
            catItem.setToolTip(0, pformat(data))
        
        debugLog(f"DEBUG Return values for {data.get('name')}: {retVals}")
        debugLog(f"[DEBUG] üßæ Final component index mapping: {pformat(parentWindow.createToComponents)}")

        
        
    # Expand to a reasonable depth instead of expanding all nodes
    parentWindow.structureTree.expandToDepth(1)
    
    # Collapse any "Full Model Data" nodes specifically
    def collapseFullModelDataNodes(item):
        for i in range(item.childCount()):
            child = item.child(i)
            if child.text(0) == "Full Model Data":
                child.setExpanded(False)
            collapseFullModelDataNodes(child)
    
    root = parentWindow.structureTree.invisibleRootItem()
    collapseFullModelDataNodes(root)
    




def getComponentLabel(mbs, compType, idx, sourceMapping=None):
    parent = getattr(mbs, 'parentWindow', None)
    inferred = parent.inferredComponentTypes.get(compType, {}).get(idx) if parent else None
    return formatComponentLabel(compType, idx, inferred, sourceMapping=sourceMapping)


    


PRIMARY_RETURN_KEYS = {
    'objectNumber', 'bodyNumber', 'sensorNumber', 'loadNumber',
    'nodeNumber', 'markerNumber',
    # NEW PLURAL KEYS:
    'objectNumbers', 'bodyNumbers', 'sensorNumbers',
    'loadNumbers', 'nodeNumbers', 'markerNumbers'
}
keyToGroupMap = {
    'nodeNumber': 'nodes', 'nodeNumbers': 'nodes',
    'markerNumber': 'markers', 'markerNumbers': 'markers',
    'bodyNumber': 'objects', 'bodyNumbers': 'objects',
    'objectNumber': 'objects', 'objectNumbers': 'objects',
    'loadNumber': 'loads', 'loadNumbers': 'loads',
    'sensorNumber': 'sensors', 'sensorNumbers': 'sensors',
}
def buildModelTree(parentWindow, modelSequence):
    debugLog("[DEBUG] createToComponents =", getattr(parentWindow, 'createToComponents', {}))
    debugLog(f"[DEBUG] buildModelTree: using createToComponents = {getattr(parentWindow, 'createToComponents', 'MISSING')}")
    debugLog("[DEBUG] Entered buildModelTree")
    parentWindow.structureTree.clear()
    # Initialize or clear the mapping dict
    parentWindow.guiModelMapping = {}
    structure = parentWindow.structure

    for i, item in enumerate(modelSequence):
        objType = item['type']
        data = item['data']

        name = data.get('name', objType)
        objIndex = data.get('objIndex', '?')
        if objType.startswith("Create"):
            label = f"üõ†Ô∏è {objType}_{name} [Index {i}] [Created ID {objIndex}]"
        else:
            label = f"{objType}_{name} [Index {i}] [Created ID {objIndex}]"
        debugLog(f"[DEBUG] Adding top-level tree item: label={label}, modelIndex={i}")
        treeItem = QTreeWidgetItem(parentWindow.structureTree, [label])
        treeItem.setData(0, Qt.UserRole, i)  # Always set for top-level
        parentWindow.guiModelMapping[i] = item

        retVals = data.get('returnValues', {})
        from copy import deepcopy

        components = parentWindow.createToComponents.get(i, {})



        # Show primary return values
        if isinstance(retVals, dict):
            primary = {k: v for k, v in retVals.items() if k in PRIMARY_RETURN_KEYS}
            if primary:
                retItem = QTreeWidgetItem(treeItem, ["Return values"])
                for key, val in primary.items():
                    valStr = ', '.join(str(x) for x in val) if isinstance(val, list) else str(val)
                    QTreeWidgetItem(retItem, [f"{key} = {valStr}"])
                retItem.setExpanded(True)

        createdItem = QTreeWidgetItem(treeItem, ["Created items"])

        # --- Created components (from snapshot diffs or fallback) ---
        # For each component type (objects, markers, nodes, loads, sensors), show all created indices
        # --- Created components (from snapshot diffs or fallback) ---
        for compType in sorted(components.keys()):
            for idx in sorted(components[compType]):
                # Only add child nodes for display, but do NOT set Qt.UserRole for them
                try:
                    compList = structure.get(compType, [])
                    compData = next((entry['data'] for entry in compList if entry['index'] == idx), None)
                    label = formatComponentLabel(
                        compType, idx,
                        objTypeHint=structure['categories'].get(compType, {}).get(idx),
                        mbs=parentWindow.mbs,
                        data=compData
                    )
                    QTreeWidgetItem(createdItem, [label])
                except Exception as e:
                    QTreeWidgetItem(createdItem, [f"[Unresolved {compType} #{idx}] (error: {e})"])


        # --- Secondary return values (not in snapshot diff) ---
        shownIDs = {k: set(components.get(k, set())) for k in ['nodes', 'markers', 'objects', 'loads', 'sensors']}
        debugLog(f"[DEBUG] shownIDs = {shownIDs}")
        for k, v in retVals.items():
            if k in PRIMARY_RETURN_KEYS:
                continue

            # Resolve group
            group = keyToGroupMap.get(k)
            if group is None:
                for g in ['nodes', 'markers', 'objects', 'loads', 'sensors']:
                    if k.lower().startswith(g[:-1]):
                        group = g
                        break

            
            if group not in shownIDs:
                continue  # Skip unknown or non-component types
            else:
                debugLog(f"[buildModelTree] üß© Found secondary value for key={k} ‚Üí group={group}", origin="modelManager.py")

            # Flatten values
            flatValues = []
            def flatten(vals):
                for v in vals:
                    if isinstance(v, list):
                        yield from flatten(v)
                    else:
                        yield v

            flatValues = list(flatten(v if isinstance(v, list) else [v]))

            for val in flatValues:
                if not isinstance(val, int):
                    debugLog(f"[buildModelTree] ‚ö†Ô∏è Skipping non-int secondary value: {val}", origin="modelManager.py")
                    continue
                else:
                    debugLog(f"[buildModelTree] ‚ûï Adding secondary return value {val} to group={group}", origin="modelManager.py")

                if val in shownIDs.get(group, set()):
                    continue

                objTypeHint = parentWindow.componentIndexToType.get(group, {}).get(val)
                try:
                    label = formatComponentLabel(group, val, inferred=k, objTypeHint=objTypeHint, sourceMapping=data, mbs=parentWindow.mbs)
                except Exception as e:
                    label = f"[Unresolved {group} #{val}] (error: {e})"
                QTreeWidgetItem(createdItem, [label])

        if createdItem.childCount() > 0:
            createdItem.setExpanded(True)
        treeItem.setExpanded(True)        # Inject full model data for debugging/mapping - with cleaned graphicsDataList for readability
        cleaned_item = deepcopy(item)
        cleaned_data = cleaned_item.get('data', {})
        
        # Replace verbose graphicsDataList with clean format
        gDataList = cleaned_data.get('graphicsDataList', [])
        if gDataList:
            formatted_gdl = []
            for gEntry in gDataList:
                if isinstance(gEntry, dict):
                    name = gEntry.get('name', '?')
                    args = gEntry.get('args', '')
                    # Format with exu.graphics. prefix for readability
                    clean_name = name.replace('GraphicsData', '') if name.startswith('GraphicsData') else name
                    formatted_gdl.append(f"exu.graphics.{clean_name}({args})")
                else:
                    formatted_gdl.append(str(gEntry))
            cleaned_data['graphicsDataList'] = formatted_gdl
        
        fullDataStr = pformat(cleaned_item, compact=True, width=120)
        fullDataNode = QTreeWidgetItem(treeItem, ["Full Model Data"])
        QTreeWidgetItem(fullDataNode, [fullDataStr])
        fullDataNode.setExpanded(False)# --- Add summary of graphicsDataList, UserFunction fields, and inertia as a single dict (Python code style) ---
        summary_dict = {}
        gDataList = data.get('graphicsDataList', [])
        if gDataList:
            formatted_gdl = []
            for gEntry in gDataList:
                if isinstance(gEntry, dict):
                    name = gEntry.get('name', '?')
                    args = gEntry.get('args', '')
                    # Format with exu.graphics. prefix to match summaryPythonCode style
                    clean_name = name.replace('GraphicsData', '') if name.startswith('GraphicsData') else name
                    formatted_gdl.append(f"exu.graphics.{clean_name}({args})")
                else:
                    formatted_gdl.append(str(gEntry))
            summary_dict['graphicsDataList'] = formatted_gdl
        # UserFunction fields
        for k, v in data.items():
            if k.endswith('UserFunction'):
                if callable(v) and hasattr(v, '__name__'):
                    # Store as a string that can be directly used in generated code
                    summary_dict[k] = f"'{v.__name__}'"
                elif isinstance(v, str):
                    summary_dict[k] = f"'{v}'"
                elif v in (None, 0):
                    summary_dict[k] = '0'
                else:
                    summary_dict[k] = str(v)
        # Inertia field
        inertia = data.get('inertia', None)
        if inertia is not None:
            if isinstance(inertia, dict):
                name = inertia.get('name', '?')
                args = inertia.get('args', '')
                summary_dict['inertia'] = f"{name}({args})"
            else:
                summary_dict['inertia'] = str(inertia)
        
        # nodeType field (for code generation)
        nodeType = data.get('nodeType', None)
        if nodeType is not None:
            # If it's an enum, get its name; if string, use as is
            try:
                import exudyn as exu
                if hasattr(nodeType, 'name'):
                    summary_dict['nodeType'] = f"exu.NodeType.{nodeType.name}"
                elif isinstance(nodeType, str):
                    # Check if string already has the exu.NodeType prefix
                    if nodeType.startswith('exu.NodeType.'):
                        summary_dict['nodeType'] = nodeType
                    elif nodeType.startswith('NodeType.'):
                        # Convert "NodeType.RotationEulerParameters" to "exu.NodeType.RotationEulerParameters"
                        summary_dict['nodeType'] = nodeType.replace('NodeType.', 'exu.NodeType.')
                    else:
                        # Just the enum name like "RotationEulerParameters"
                        summary_dict['nodeType'] = f"exu.NodeType.{nodeType}"
                else:
                    summary_dict['nodeType'] = str(nodeType)
            except Exception:
                summary_dict['nodeType'] = str(nodeType)
        
        # outputVariableType field (for sensors)
        outputVarType = data.get('outputVariableType', None)
        if outputVarType is not None:
            try:
                import exudyn as exu
                if hasattr(outputVarType, 'name'):
                    summary_dict['outputVariableType'] = f"exu.OutputVariableType.{outputVarType.name}"
                elif isinstance(outputVarType, str):
                    summary_dict['outputVariableType'] = f"exu.OutputVariableType.{outputVarType}"
                else:
                    summary_dict['outputVariableType'] = str(outputVarType)
            except Exception:
                summary_dict['outputVariableType'] = str(outputVarType)
        
        # Add to the item dict for later use (e.g. code generation)
        if summary_dict:
            item['summaryPythonCode'] = summary_dict

        # Show inertia if present
        inertia = data.get('inertia', None)
        if inertia is not None:
            inertiaItem = QTreeWidgetItem(treeItem, ["Inertia"])
            if isinstance(inertia, dict):
                name = inertia.get('name', '?')
                args = inertia.get('args', '')
                label = f"{name}({args})"
                QTreeWidgetItem(inertiaItem, [label])
            else:
                # Show string or other representation
                QTreeWidgetItem(inertiaItem, [str(inertia)])
            inertiaItem.setExpanded(True)

        # Show graphics visualizations if present
        gDataList = data.get('graphicsDataList', [])
        vDataList = data.get('VgraphicsData', [])  # legacy Exudyn graphics
        
        def format_graphics_entry(entry):
            """Format a graphics entry (dict, stringified dict, or string) as NAME(args) if possible."""
            if isinstance(entry, dict):
                name = entry.get('name')
                args = entry.get('args')
                if name is not None:
                    return f"{name}({args if args is not None else ''})"
            elif isinstance(entry, str):
                # Try to parse stringified dicts: {'name': 'CheckerBoard', 'args': '...'}
                import ast
                try:
                    d = ast.literal_eval(entry)
                    if isinstance(d, dict) and 'name' in d:
                        name = d['name']
                        args = d.get('args', '')
                        return f"{name}({args})"
                except Exception:
                    pass
            return str(entry)

        if gDataList or vDataList:
            graphicsItem = QTreeWidgetItem(treeItem, ["Graphics Data"])
    
            for i, gEntry in enumerate(gDataList):
                if isinstance(gEntry, dict):
                    name = gEntry.get('name', '?')
                    args = gEntry.get('args', '')
                    clean_name = name.replace('GraphicsData', '') if name.startswith('GraphicsData') else name
                    label = f"[{i}] exu.graphics.{clean_name}({args})"
                elif isinstance(gEntry, str):
                    label = f"[{i}] {gEntry}"  # Use string as-is
                else:
                    label = f"[{i}] [Invalid graphics entry: {gEntry}]"
                QTreeWidgetItem(graphicsItem, [label])
    
            for i, vEntry in enumerate(vDataList):
                label = f"[{i + len(gDataList)}] {format_graphics_entry(vEntry)}"
                QTreeWidgetItem(graphicsItem, [label])
    
            graphicsItem.setExpanded(True)

        # Show sensor output variable type if present (for sensors)
        summaryCode = item.get('summaryPythonCode', {})
        if objType.startswith('Sensor') and isinstance(summaryCode, dict) and 'outputVariableType' in summaryCode:
            outputVarTypeItem = QTreeWidgetItem(treeItem, ["Output Variable Type"])
            outputVarTypeFormatted = summaryCode['outputVariableType']
            label = f"[0] {outputVarTypeFormatted}"
            QTreeWidgetItem(outputVarTypeItem, [label])
            outputVarTypeItem.setExpanded(True)        # Check for any *UserFunction fields, support both string and callable
        ufFields = []
        for k, v in data.items():
            if k.endswith('UserFunction'):
                if isinstance(v, str) and v.startswith('UF'):
                    ufFields.append((k, v))
                elif callable(v) and hasattr(v, '__name__') and v.__name__.startswith('UF'):
                    ufFields.append((k, v.__name__))
        
        if ufFields:
            ufNode = QTreeWidgetItem(treeItem, ["User Functions"])
            for i, (fieldName, funcName) in enumerate(ufFields):
                label = f"[{i}] {fieldName} ‚Üí {funcName}"
                QTreeWidgetItem(ufNode, [label])            
                ufNode.setExpanded(True)

    parentWindow.structureTree.expandToDepth(1)
    
    # Ensure "Full Model Data" nodes remain collapsed even after expandToDepth
    def collapseFullModelDataNodes(item):
        for i in range(item.childCount()):
            child = item.child(i)
            if child.text(0) == "Full Model Data":
                child.setExpanded(False)
            collapseFullModelDataNodes(child)
    
    root = parentWindow.structureTree.invisibleRootItem()
    collapseFullModelDataNodes(root)







def getActualComponentType(mbs, group, index):
    try:
        if group == 'objects':
            return mbs.GetObject(index)['objectType']
        elif group == 'nodes':
            return mbs.GetNode(index)['nodeType']
        elif group == 'markers':
            return mbs.GetMarker(index)['markerType']
        elif group == 'loads':
            return mbs.GetLoad(index)['loadType']
        elif group == 'sensors':
            return mbs.GetSensor(index)['sensorType']
    except Exception as e:
        debugLog(f"[getActualComponentType] ‚ùå Failed to get type for {group}[{index}]: {e}", origin="modelManager.py")
    return "unknown"




#     # Refresh UI tree
#     buildModelTree(parentWindow, modelSequence)
def buildSystemFromSequence(parentWindow):
    import sys
    from copy import deepcopy
    # Use the modelSequence from parentWindow instead of importing it
    modelSequence = parentWindow.modelSequence
    from model.modelData import existingNames
    debugLog("[DEBUG] buildSystemFromSequence called, modelSequence id:", id(modelSequence), "module:", sys.modules[modelSequence.__class__.__module__])
    """
    Rebuilds the entire Exudyn system from the stored modelSequence,
    updating the structure tree and component mappings.

    NOTE: The renderer is always stopped before rebuilding the system and restarted after.
    All model-changing actions must go through this function to ensure correct renderer management.
    """
    existingNames.clear()

    # üîÑ Reset tracking state (creates createToComponents, inferredComponentTypes, etc.)
    if hasattr(parentWindow, 'resetModelTrackingState'):        parentWindow.resetModelTrackingState()

    import exudyn as exu
    
    # Simply reset the existing mbs - no need to stop/start renderer
    parentWindow.mbs.Reset()
    mbs = parentWindow.mbs
    SC = parentWindow.SC
    
    debugLog("[buildSystemFromSequence] Reset mbs - renderer stays active", origin="modelManager.py")

    # Track structures
    createToComponents = {}
    standaloneComponents = {k: set() for k in ['nodes', 'markers', 'objects', 'loads', 'sensors']}
    inferredComponentTypes = {k: {} for k in standaloneComponents}
    componentIndexToType = {k: {} for k in standaloneComponents}

    def getAllComponents(mbs):
        return {
            'nodes': set(range(mbs.systemData.NumberOfNodes())),
            'markers': set(range(mbs.systemData.NumberOfMarkers())),
            'objects': set(range(mbs.systemData.NumberOfObjects())),
            'loads': set(range(mbs.systemData.NumberOfLoads())),
            'sensors': set(range(mbs.systemData.NumberOfSensors())),
        }
    

    # --- Rebuild system from modelSequence ---
    for idx, item in enumerate(modelSequence):
        objType = item['type']
        data = item['data']

        if objType == 'PythonSnippet':
            # Execute the snippet if enabled
            if data.get('enabled', True):
                try:
                    exec_ctx = {
                        'mbs': mbs,
                        'SC': SC,
                        'userVariables': getattr(parentWindow, 'userVariables', {}),
                        'userFunctions': userFunctions,
                        'exu': exu,
                    }
                    exec(data.get('code', ''), exec_ctx)

                    # CAPTURE VARIABLES: Extract new variables defined in snippet
                    snippet_vars = {k: v for k, v in exec_ctx.items() 
                                if k not in ['mbs', 'SC', 'userVariables', 'userFunctions', 'exu']
                                and not k.startswith('__')}
                    
                    # Store in global snippet variable store
                    if not hasattr(parentWindow, 'snippetVariables'):
                        parentWindow.snippetVariables = {}
                    parentWindow.snippetVariables.update(snippet_vars)


                    debugLog(f"[buildSystemFromSequence] ‚úÖ Executed PythonSnippet: {data.get('label', '')}", origin="modelManager.py")
                except Exception as e:
                    debugLog(f"[buildSystemFromSequence] ‚ùå Error in PythonSnippet '{data.get('label', '')}': {e}", origin="modelManager.py")
            continue  # Skip builder logic for snippets

        data['objectType'] = objType
        # Resolve user functions for building (convert string names to actual functions)
        for key in data:
            if key.endswith('UserFunction'):
                orig = data[key]
                try:
                    resolved_func = resolveUserFunction(orig)
                    # üîß CRITICAL DEBUG: Check function type before passing to Exudyn
                    debugLog(f"[buildSystemFromSequence] üîç Resolved {key} = '{orig}' ‚Üí {resolved_func}", origin="modelManager.py")
                    debugLog(f"[buildSystemFromSequence] üîç Function type: {type(resolved_func)}", origin="modelManager.py")
                    debugLog(f"[buildSystemFromSequence] üîç Function module: {getattr(resolved_func, '__module__', 'unknown')}", origin="modelManager.py")
                    debugLog(f"[buildSystemFromSequence] üîç Function name: {getattr(resolved_func, '__name__', 'unknown')}", origin="modelManager.py")
                    
                    # Ensure we have a pure Python function
                    if callable(resolved_func) and hasattr(resolved_func, '__code__'):
                        data[key] = resolved_func
                        debugLog(f"[buildSystemFromSequence] ‚úÖ Function looks valid for Exudyn", origin="modelManager.py")
                    else:
                        debugLog(f"[buildSystemFromSequence] ‚ö†Ô∏è Function doesn't look like a pure Python function, using 0", origin="modelManager.py")
                        data[key] = 0
                except Exception as e:
                    debugLog(f"[buildSystemFromSequence] ‚ùå Failed to resolve user function {key} = '{orig}': {e}", origin="modelManager.py")
                    # Fallback to 0 (no user function) to prevent renderer crash
                    data[key] = 0
                
                # üîß TEMPORARY FIX: Disable user functions to prevent renderer crash
                # Uncomment the line below to test if user functions are causing the issue
                # data[key] = 0
        
        # === BUILD USING UNIFIED VIEW STATE PRESERVATION ===
        builder = registry[objType]['builder']
        before = getAllComponents(mbs)


        
        try:
            # Enrich with missing defaults
            from core.fieldMetadata import FieldMetadataBuilder
            builderMetadata = FieldMetadataBuilder().build(objType)
            for key, meta in builderMetadata.items():
                if key not in data and 'default' in meta:
                    data[key] = deepcopy(meta['default'])

            # Handle graphics data - preserve compact string format if already in that format
            if 'graphicsDataList' in data:
                gdl = data['graphicsDataList']
                if isinstance(gdl, list) and gdl and all(isinstance(x, dict) and 'name' in x and 'args' in x for x in gdl):
                    try:
                        from core.fieldMetadata import reconstructGraphicsDataList
                        data['graphicsDataList'] = reconstructGraphicsDataList(gdl)
                        debugLog(f"[buildSystemFromSequence] üõ† Reconstructed graphicsDataList from dict format", origin="modelManager.py")
                    except Exception as e:
                        debugLog(f"[buildSystemFromSequence] ‚ö†Ô∏è graphicsDataList reconstruction failed: {e}", origin="modelManager.py")
                        data['graphicsDataList'] = []
                elif isinstance(gdl, list) and gdl and all(isinstance(x, str) for x in gdl):
                    debugLog(f"[buildSystemFromSequence] ‚úÖ Preserving compact graphicsDataList format: {gdl}", origin="modelManager.py")
                else:
                    debugLog(f"[buildSystemFromSequence] ‚ö†Ô∏è Unknown graphicsDataList format: {type(gdl)}, {gdl}", origin="modelManager.py")
            if 'graphicsDataUserFunction' in data and data['graphicsDataUserFunction'] in ['None', '0', '', None]:
                data['graphicsDataUserFunction'] = 0
            # Check for duplicates and warn (let GUI handle user prompts)
            if data['name'] in existingNames:
                debugLog(f"[buildSystemFromSequence] ‚ö†Ô∏è Duplicate name detected: {data['name']}", origin="modelManager.py")
            # --- Ensure legacy items always have a valid name ---
            if data.get('isLegacy', False):
                if not data.get('name') or not str(data['name']).strip():
                    base = f"Legacy_{data.get('objectType', data.get('type', 'Unknown'))}"
                    fallback_name = generateUniqueName(base, existingNames)
                    data['name'] = fallback_name
                    existingNames.add(fallback_name)
                    debugLog(f"[buildSystemFromSequence] üè∑Ô∏è Assigned fallback name for legacy item: {fallback_name}", origin="modelManager.py")

            # === CALL BUILDER AND RESTORE VIEW STATE ===
            try:
                debugLog(f"[buildSystemFromSequence] üöÄ Calling builder for {objType} with user functions: {[k for k, v in data.items() if k.endswith('UserFunction') and v != 0]}", origin="modelManager.py")
                # Pass snippet variables to builder for variable resolution
                snippet_vars = getattr(parentWindow, 'snippetVariables', {})
                returnValue = builder(mbs, data, snippet_vars)
                mbs.Assemble()
                debugLog(f"[buildSystemFromSequence] ‚úÖ Builder returned: {returnValue}", origin="modelManager.py")
            except Exception as e:
                debugLog(f"‚ùå Error in builder for '{objType}': {e}", origin="modelManager.py")
                import traceback
                debugLog(f"‚ùå Full traceback: {traceback.format_exc()}", origin="modelManager.py")
                item['data']['objIndex'] = None
                item['data']['returnInfo'] = f"‚ö†Ô∏è Build failed: {str(e).splitlines()[0]}"
                continue

            
            # ‚Äî convert any numeric strings to ints ‚Äî
            cleanedReturn = {}
            if isinstance(returnValue, dict):
                for k, v in returnValue.items():
                    if isinstance(v, str) and v.isdigit():
                        cleanedReturn[k] = int(v)
                    else:
                        cleanedReturn[k] = v
                returnValue = cleanedReturn
            # Detect added components
            after = getAllComponents(mbs)
            diff = {k: after[k] - before[k] for k in before}

            # Also infer from return values (for reused components)
            for k, val in returnValue.items() if isinstance(returnValue, dict) else []:
                group = keyToGroupMap.get(k)
                if not group:
                    continue
                valList = val if isinstance(val, list) else [val]
                for v in valList:
                    if isinstance(v, int):
                        compIdx = v
                    elif isinstance(v, str) and v.isdigit():
                        compIdx = int(v)
                    else:
                        continue
                    diff.setdefault(group, set()).add(compIdx)

            # ‚úÖ Apply full diff including inferred secondary values
            createToComponents[idx] = diff
            debugLog(f"[buildSystemFromSequence] Final createToComponents[{idx}] = {createToComponents[idx]}", origin="modelManager.py")

            # ‚Ä¶ later, assign objIndex ‚Ä¶
            objIndex = None
            if isinstance(returnValue, dict):
                for k in ['objectNumber','bodyNumber', 'nodeNumber', 'markerNumber','loadNumber','sensorNumber']:
                    if k in returnValue:
                        val = returnValue[k]
                        objIndex = val
                        break
            else:
                objIndex = int(returnValue) if hasattr(returnValue, '__index__') else None

            item['data']['objIndex'] = objIndex
            item['data']['returnInfo'] = (
                " / ".join(f"{k}={v}" for k, v in returnValue.items() if isinstance(v, int))
                if isinstance(returnValue, dict) else f"Created ID {objIndex}"
            )
            
        except Exception as e:
            item['data']['objIndex'] = None
            item['data']['returnInfo'] = f"‚ö†Ô∏è Build failed: {str(e).splitlines()[0]}"
            debugLog(f"‚ùå Error in builder for '{objType}': {e}", origin="modelManager.py")


    # Save component maps
    from copy import deepcopy
    parentWindow.createToComponents = deepcopy(createToComponents)
    debugLog("[DEBUG] Copied to parentWindow.createToComponents =", parentWindow.createToComponents)
    debugLog(f"üìä createToComponents = {pformat(parentWindow.createToComponents)}")
    parentWindow.componentToCreate = componentToCreate
    parentWindow.inferredComponentTypes = inferredComponentTypes
    parentWindow.componentIndexToType = componentIndexToType

    parentWindow.standaloneNodes = standaloneComponents['nodes']
    parentWindow.standaloneMarkers = standaloneComponents['markers']
    parentWindow.standaloneObjects = standaloneComponents['objects']
    parentWindow.standaloneLoads = standaloneComponents['loads']
    parentWindow.standaloneSensors = standaloneComponents['sensors']

    # No need to stop/start renderer - mbs.Reset() automatically refreshes the view
    debugLog("[buildSystemFromSequence] Model rebuilt - renderer will refresh automatically", origin="modelManager.py")

    debugLog("[buildSystemFromSequence] Starting system rebuild", origin="modelManager.py")
    buildModelTree(parentWindow, modelSequence)
    debugLog(f"[buildSystemFromSequence] modelSequence length: {len(parentWindow.modelSequence)}", origin="modelManager.py")
    debugLog(f"[buildSystemFromSequence] modelSequence: {parentWindow.modelSequence}", origin="modelManager.py")
    debugLog(f"[buildSystemFromSequence] structured_tree: {parentWindow.structure}", origin="modelManager.py")
    debugLog("[buildSystemFromSequence] Finished system rebuild", origin="modelManager.py")

def correctReturnValues(typeName, returnValues):
    """
    Fixes Exudyn return value keys for special cases.
    Ensures all numeric values are ints, and remaps keys for known types.
    """
    if not isinstance(returnValues, dict):
        return returnValues
    fixed = dict(returnValues)
    
    # Convert numeric strings to ints
    for k, v in list(fixed.items()):
        if isinstance(v, str) and v.isdigit():
            fixed[k] = int(v)
    
    # Special case: CreateForce/torque returns objectNumber, but GUI expects loadNumber
    # Only convert if loadNumber is not already present
    if typeName.lower().startswith('createforce') or typeName.lower().startswith('createtorque'):
        if 'objectNumber' in fixed and 'loadNumber' not in fixed:
            fixed['loadNumber'] = fixed.pop('objectNumber')
            debugLog(f"[correctReturnValues] Converted objectNumber to loadNumber for {typeName}", origin="modelManager.py")
    
    return fixed
