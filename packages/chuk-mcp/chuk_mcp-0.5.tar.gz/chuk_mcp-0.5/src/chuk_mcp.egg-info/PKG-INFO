Metadata-Version: 2.4
Name: chuk-mcp
Version: 0.5
Summary: Model Context Protocol Client with Optional Pydantic Support
Author-email: Chris Hay <chrishayuk@somejunkmailbox.com>
License: MIT
Project-URL: Homepage, https://github.com/chrishayuk/chuk-mcp
Project-URL: Repository, https://github.com/chrishayuk/chuk-mcp
Project-URL: Bug Tracker, https://github.com/chrishayuk/chuk-mcp/issues
Keywords: llm,openai,claude,mcp,client,protocol
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Communications
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Requires-Python: >=3.11
Description-Content-Type: text/markdown
License-File: LICENSE.md
Requires-Dist: anyio>=4.9.0
Requires-Dist: typing-extensions<5.0.0,>=4.7.1
Provides-Extra: pydantic
Requires-Dist: pydantic>=2.11.1; extra == "pydantic"
Provides-Extra: http
Requires-Dist: httpx>=0.28.1; extra == "http"
Provides-Extra: full
Requires-Dist: pydantic>=2.11.1; extra == "full"
Requires-Dist: httpx>=0.28.1; extra == "full"
Provides-Extra: dev
Requires-Dist: pydantic>=2.11.1; extra == "dev"
Requires-Dist: httpx>=0.28.1; extra == "dev"
Requires-Dist: pytest>=8.3.5; extra == "dev"
Requires-Dist: pytest-asyncio>=0.26.0; extra == "dev"
Requires-Dist: fastapi>=0.116.0; extra == "dev"
Requires-Dist: uvicorn>=0.35.0; extra == "dev"
Requires-Dist: pytz>=2025.2; extra == "dev"
Dynamic: license-file

# chuk-mcp

A comprehensive Python client implementation for the **Model Context Protocol (MCP)** - the open standard for connecting AI assistants to external data and tools.

[![PyPI version](https://badge.fury.io/py/chuk-mcp.svg)](https://badge.fury.io/py/chuk-mcp)
[![Python Version](https://img.shields.io/pypi/pyversions/chuk-mcp)](https://pypi.org/project/chuk-mcp/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![uv](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/uv/main/assets/badge/v0.json)](https://github.com/astral-sh/uv)

## What is the Model Context Protocol?

The **Model Context Protocol (MCP)** is an open standard that enables AI applications to securely access external data and tools. Instead of every AI app building custom integrations, MCP provides a universal interface for:

- **ğŸ”§ Tools**: Functions AI can call (APIs, file operations, calculations)
- **ğŸ“„ Resources**: Data sources AI can read (files, databases, web content)  
- **ğŸ’¬ Prompts**: Reusable prompt templates with parameters
- **ğŸ¯ Real-time Data**: Live information that changes frequently

**Key Benefits:**
- **Standardized**: One protocol for all integrations
- **Secure**: User-controlled access to sensitive data
- **Extensible**: Easy to add new capabilities
- **Language-Agnostic**: Works across different programming languages

## Why Use This Client?

`chuk-mcp` is a production-ready Python implementation that provides:

âœ… **Complete MCP Protocol Support** - All standard features including tools, resources, prompts, sampling, and completion  
âœ… **Type Safety** - Full type annotations with optional Pydantic integration or graceful fallback  
âœ… **Robust Error Handling** - Automatic retries, connection recovery, and detailed error reporting  
âœ… **Multi-Server Support** - Connect to multiple MCP servers simultaneously  
âœ… **Modern Architecture** - Clean separation of protocol, transport, and client layers  
âœ… **Developer Experience** - Rich CLI tools, comprehensive docs, and intuitive APIs  
âœ… **Production Ready** - Battle-tested with proper logging, monitoring, and performance optimization  
âœ… **UV Optimized** - First-class support for modern Python packaging with UV

## Installation

### Quick Start with UV (Recommended)

[UV](https://github.com/astral-sh/uv) is the fastest Python package manager. Choose your installation based on your needs:

```bash
# ğŸš€ Minimal installation (uses lightweight fallback validation)
uv add chuk-mcp

# ğŸ”§ With Pydantic validation (recommended for production)
uv add chuk-mcp[pydantic]

# ğŸŒŸ Full features (Pydantic + HTTP transport + all extras)
uv add chuk-mcp[full]

# ğŸ› ï¸ Development installation (includes testing and examples)
uv add chuk-mcp[dev]
```

### Traditional Installation

```bash
# Using pip (if UV not available)
pip install chuk-mcp

# With Pydantic support
pip install chuk-mcp[pydantic]

# Full features
pip install chuk-mcp[full]
```

### Installation Options Explained

| Option | Dependencies | Use Case | Performance |
|--------|-------------|----------|-------------|
| `chuk-mcp` | Core only | Minimal deployments, testing | Fast startup, lightweight validation |
| `chuk-mcp[pydantic]` | + Pydantic | Production use, type safety | Enhanced validation, better errors |
| `chuk-mcp[full]` | + All features | Maximum functionality | Full feature set |
| `chuk-mcp[dev]` | + Dev tools | Development, testing | All tools included |

> **ğŸ’¡ Performance Note:** The lightweight fallback validation is ~20x slower than Pydantic (0.010ms vs 0.000ms per operation) but still excellent for most use cases. Use `[pydantic]` for high-throughput applications.

### Verify Installation

```bash
# Quick test with UV
uv run python -c "import chuk_mcp; print('âœ… chuk-mcp installed successfully')"

# Or test full functionality
uv run --with chuk-mcp[pydantic] python -c "
from chuk_mcp.protocol.mcp_pydantic_base import PYDANTIC_AVAILABLE
print(f'âœ… Pydantic available: {PYDANTIC_AVAILABLE}')
"
```

## Protocol Compliance

`chuk-mcp` provides comprehensive compliance with the MCP specification across multiple protocol versions:

### ğŸ“‹ Supported Protocol Versions
- **Latest**: `2025-06-18` (primary support)
- **Stable**: `2025-03-26` (full compatibility)
- **Legacy**: `2024-11-05` (backward compatibility)

### ğŸ¯ Core Protocol Features

#### âœ… **JSON-RPC 2.0 Compliance**
- Complete request/response/notification handling
- Proper error code classification
- Version-aware message routing
- Batching support (version-dependent)

#### âœ… **Transport Layer Support**
- **Stdio Transport**: Primary subprocess-based communication
- **HTTP Transport**: Modern streamable HTTP transport (spec 2025-03-26)
- **SSE Transport**: Deprecated Server-Sent Events (backward compatibility)
- **Pluggable Architecture**: Easy to add new transport types

#### âœ… **MCP Operations**
- **ğŸ”§ Tools**: List and call server tools with full argument validation
- **ğŸ“„ Resources**: Discover and read server resources with URI support
- **ğŸ’¬ Prompts**: Get parameterized prompt templates with argument substitution
- **ğŸ¯ Sampling**: Client-side LLM sampling (advanced feature)
- **ğŸ“ Completion**: Argument autocompletion for enhanced UX
- **ğŸŒ³ Roots**: File system access control and security
- **â“ Elicitation**: User input requests (new in 2025-06-18)

### ğŸš€ Advanced Protocol Features

#### âœ… **Session Management**
- Automatic initialization and capability exchange
- Version negotiation with fallback support
- Multi-client session handling (server-side)
- Connection lifecycle management

#### âœ… **Real-time Operations**
- **Progress Tracking**: Long-running operation progress reporting
- **Cancellation**: Request cancellation support with proper cleanup
- **Notifications**: Real-time event notifications (resource changes, logs)
- **Subscriptions**: Resource change monitoring

#### âœ… **Error Handling & Resilience**
- Comprehensive error classification (retryable vs non-retryable)
- Automatic retry logic with exponential backoff
- Connection recovery and reconnection
- Structured error reporting with context

#### âœ… **Version-Aware Features**
- **Feature Detection**: Automatic capability discovery
- **Batching**: JSON-RPC batch support where available
- **Protocol Upgrades**: Seamless version transitions
- **Backward Compatibility**: Graceful degradation for older servers

### ğŸ“Š Protocol Compliance Matrix

| Feature Category | 2024-11-05 | 2025-03-26 | 2025-06-18 | Implementation Status |
|-----------------|------------|------------|------------|---------------------|
| **Core Operations** | | | | |
| Tools (list/call) | âœ… | âœ… | âœ… | âœ… Complete |
| Resources (list/read/subscribe) | âœ… | âœ… | âœ… | âœ… Complete |
| Prompts (list/get) | âœ… | âœ… | âœ… | âœ… Complete |
| **Transport** | | | | |
| Stdio | âœ… | âœ… | âœ… | âœ… Complete |
| SSE | âœ… | âš ï¸ Deprecated | âŒ Removed | âœ… Legacy Support |
| HTTP Streaming | âŒ | âœ… | âœ… | âœ… Complete |
| **Advanced Features** | | | | |
| Sampling | âŒ | âœ… | âœ… | âœ… Complete |
| Completion | âŒ | âœ… | âœ… | âœ… Complete |
| Roots | âŒ | âœ… | âœ… | âœ… Complete |
| Elicitation | âŒ | âŒ | âœ… | âœ… Complete |
| **Quality Features** | | | | |
| Progress Tracking | âœ… | âœ… | âœ… | âœ… Complete |
| Cancellation | âœ… | âœ… | âœ… | âœ… Complete |
| Notifications | âœ… | âœ… | âœ… | âœ… Complete |
| Batching | âŒ | âœ… | âœ… | âœ… Complete |

## Quick Start

### 5-Minute Demo

```bash
# Get started instantly with UV
uv run --with chuk-mcp[pydantic] python - << 'EOF'
import anyio
from chuk_mcp import stdio_client, StdioServerParameters
from chuk_mcp.protocol.messages import send_initialize

async def main():
    # Demo with echo server (no external dependencies)
    server_params = StdioServerParameters(
        command="python",
        args=["-c", """
import json, sys
init = json.loads(input())
print(json.dumps({"id": init["id"], "result": {"serverInfo": {"name": "Demo", "version": "1.0"}, "protocolVersion": "2025-06-18", "capabilities": {}}}))
        """]
    )
    
    async with stdio_client(server_params) as (read, write):
        result = await send_initialize(read, write)
        print(f"âœ… Connected to {result.serverInfo.name}")

anyio.run(main)
EOF
```

### Basic Usage with Real Server

```python
import anyio
from chuk_mcp import stdio_client, StdioServerParameters
from chuk_mcp.protocol.messages import send_initialize

async def main():
    # Configure connection to an MCP server
    server_params = StdioServerParameters(
        command="uvx",  # Use uvx to run Python tools
        args=["mcp-server-sqlite", "--db-path", "example.db"]
    )
    
    # Connect and initialize
    async with stdio_client(server_params) as (read_stream, write_stream):
        # Initialize the MCP session
        init_result = await send_initialize(read_stream, write_stream)
        
        if init_result:
            print(f"âœ… Connected to {init_result.serverInfo.name}")
            print(f"ğŸ“‹ Protocol version: {init_result.protocolVersion}")
        else:
            print("âŒ Failed to initialize connection")

anyio.run(main)
```

### Using the CLI

Test server connectivity instantly:

```bash
# Test with quickstart demo
uv run examples/quickstart.py

# Run comprehensive demos
uv run examples/e2e_smoke_test_example.py --demo all

# Test specific server configurations
uv run examples/e2e_smoke_test_example.py --smoke
```

## Core Concepts

### ğŸ”§ Tools - Functions AI Can Call

Tools are functions that AI can execute on your behalf. Examples include file operations, API calls, calculations, or any custom logic.

```python
from chuk_mcp.protocol.messages import send_tools_list, send_tools_call

async def explore_tools(read_stream, write_stream):
    # List available tools
    tools_response = await send_tools_list(read_stream, write_stream)
    
    for tool in tools_response.get("tools", []):
        print(f"ğŸ”§ {tool['name']}: {tool['description']}")
    
    # Call a specific tool
    result = await send_tools_call(
        read_stream, write_stream,
        name="execute_sql",
        arguments={"query": "SELECT COUNT(*) FROM users"}
    )
    
    print(f"ğŸ“Š Query result: {result}")
```

### ğŸ“„ Resources - Data AI Can Access

Resources are data sources like files, database records, API responses, or any URI-addressable content.

```python
from chuk_mcp.protocol.messages import send_resources_list, send_resources_read

async def explore_resources(read_stream, write_stream):
    # Discover available resources
    resources_response = await send_resources_list(read_stream, write_stream)
    
    for resource in resources_response.get("resources", []):
        print(f"ğŸ“„ {resource['name']} ({resource.get('mimeType', 'unknown')})")
        print(f"   URI: {resource['uri']}")
    
    # Read specific resource content
    if resources_response.get("resources"):
        first_resource = resources_response["resources"][0]
        content = await send_resources_read(read_stream, write_stream, first_resource["uri"])
        
        for item in content.get("contents", []):
            if "text" in item:
                print(f"ğŸ“– Content preview: {item['text'][:200]}...")
```

### ğŸ’¬ Prompts - Reusable Templates

Prompts are parameterized templates that help generate consistent, high-quality AI interactions.

```python
from chuk_mcp.protocol.messages import send_prompts_list, send_prompts_get

async def use_prompts(read_stream, write_stream):
    # List available prompt templates
    prompts_response = await send_prompts_list(read_stream, write_stream)
    
    for prompt in prompts_response.get("prompts", []):
        print(f"ğŸ’¬ {prompt['name']}: {prompt['description']}")
    
    # Get a prompt with custom arguments
    prompt_result = await send_prompts_get(
        read_stream, write_stream,
        name="analyze_data",
        arguments={"dataset": "sales_2024", "metric": "revenue"}
    )
    
    # The result contains formatted messages ready for AI
    for message in prompt_result.get("messages", []):
        print(f"ğŸ¤– {message['role']}: {message['content']}")
```

## Architecture

`chuk-mcp` features a clean, layered architecture that separates concerns and enables extensibility:

```
chuk_mcp/
â”œâ”€â”€ protocol/           # ğŸ—ï¸ Shared protocol layer
â”‚   â”œâ”€â”€ types/         #    Type definitions and validation
â”‚   â”œâ”€â”€ messages/      #    Feature-organized messaging
â”‚   â””â”€â”€ mcp_pydantic_base.py  # Type system foundation with fallback
â””â”€â”€ mcp_client/        # ğŸš€ Client implementation  
    â”œâ”€â”€ transport/     #    Communication layer (stdio, future: HTTP/WS)
    â”œâ”€â”€ host/          #    High-level management
    â””â”€â”€ __init__.py    #    Convenient unified API
```

**Benefits of This Architecture:**
- **ğŸ”Œ Pluggable Transports**: Easy to add HTTP, WebSocket, or other transports
- **â™»ï¸ Reusable Protocol Layer**: Can be used by servers, proxies, or other tools
- **ğŸ§ª Testable Components**: Each layer can be tested independently
- **ğŸ“¦ Clean Dependencies**: Minimal coupling between layers
- **âš¡ Smart Validation**: Optional Pydantic with intelligent fallback

## Configuration

### Server Configuration

Create a `server_config.json` file to define your MCP servers:

```json
{
  "mcpServers": {
    "sqlite": {
      "command": "uvx",
      "args": ["mcp-server-sqlite", "--db-path", "database.db"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/files"]
    },
    "github": {
      "command": "uvx",
      "args": ["mcp-server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "python": {
      "command": "uv",
      "args": ["run", "--with", "mcp-server-python", "mcp-server-python"],
      "env": {
        "PYTHONPATH": "/custom/python/path"
      }
    }
  }
}
```

### Configuration Loading

```python
from chuk_mcp.mcp_client.host import load_config
from chuk_mcp import stdio_client
from chuk_mcp.protocol.messages import send_initialize

async def connect_configured_server():
    # Load server configuration
    server_params = await load_config("server_config.json", "sqlite")
    
    async with stdio_client(server_params) as (read_stream, write_stream):
        init_result = await send_initialize(read_stream, write_stream)
        print(f"Connected to configured server: {init_result.serverInfo.name}")
```

## Advanced Features

### ğŸ¯ Intelligent Sampling

Let servers request AI to generate content on their behalf (with user approval):

```python
from chuk_mcp.protocol.messages.sampling import (
    send_sampling_create_message, 
    create_sampling_message
)

async def ai_content_generation(read_stream, write_stream):
    # Server can request AI to generate content
    messages = [
        create_sampling_message("user", "Explain quantum computing in simple terms")
    ]
    
    result = await send_sampling_create_message(
        read_stream, write_stream,
        messages=messages,
        max_tokens=1000,
        temperature=0.7
    )
    
    print(f"ğŸ¤– AI Generated: {result['content']['text']}")
```

### ğŸ¯ Argument Completion

Provide intelligent autocompletion for tool arguments:

```python
from chuk_mcp.protocol.messages.completion import (
    send_completion_complete, 
    create_resource_reference, 
    create_argument_info
)

async def smart_completion(read_stream, write_stream):
    # Get completion suggestions for a resource argument
    response = await send_completion_complete(
        read_stream, write_stream,
        ref=create_resource_reference("file:///project/data/"),
        argument=create_argument_info("filename", "sales_202")
    )
    
    completions = response.get("completion", {}).get("values", [])
    print(f"ğŸ’¡ Suggestions: {completions}")
```

### ğŸ”„ Multi-Server Orchestration

Connect to multiple servers simultaneously:

```python
from chuk_mcp.mcp_client.host import run_command
from chuk_mcp.protocol.messages import send_tools_list

async def multi_server_task(server_streams):
    """Process data using multiple MCP servers."""
    
    # server_streams contains connections to all configured servers
    for i, (read_stream, write_stream) in enumerate(server_streams):
        print(f"Processing with server {i+1}")
        
        # Each server can have different capabilities
        tools = await send_tools_list(read_stream, write_stream)
        print(f"  Available tools: {len(tools.get('tools', []))}")

# Run across multiple servers defined in config
run_command(multi_server_task, "server_config.json", ["sqlite", "filesystem", "github"])
```

### ğŸ“¡ Real-time Subscriptions

Subscribe to resource changes for live updates:

```python
from chuk_mcp.protocol.messages.resources import send_resources_subscribe

async def live_monitoring(read_stream, write_stream):
    # Subscribe to file changes
    success = await send_resources_subscribe(
        read_stream, write_stream,
        uri="file:///project/logs/app.log"
    )
    
    if success:
        print("ğŸ“¡ Subscribed to log file changes")
        
        # Handle notifications in your message loop
        # (implementation depends on your notification handling)
```

## Error Handling & Resilience

`chuk-mcp` provides robust error handling with automatic retries:

```python
from chuk_mcp.protocol.messages import RetryableError, NonRetryableError
from chuk_mcp.protocol.messages import send_tools_call

async def resilient_operations(read_stream, write_stream):
    try:
        # Operations automatically retry on transient failures
        result = await send_tools_call(
            read_stream, write_stream,
            name="network_operation",
            arguments={"url": "https://api.example.com/data"},
            timeout=30.0,  # Extended timeout for slow operations
            retries=5      # More retries for critical operations
        )
        
    except RetryableError as e:
        print(f"âš ï¸ Transient error after retries: {e}")
        # Handle gracefully - maybe try alternative approach
        
    except NonRetryableError as e:
        print(f"âŒ Permanent error: {e}")
        # Handle definitively - operation cannot succeed
        
    except Exception as e:
        print(f"ğŸš¨ Unexpected error: {e}")
        # Handle unknown errors
```

## Available MCP Servers

The MCP ecosystem includes servers for popular services:

### ğŸš€ Install with UV (Recommended)

```bash
# Popular Python servers
uv tool install mcp-server-sqlite
uv tool install mcp-server-github
uv tool install mcp-server-postgres

# Or run directly without installation
uv run --with mcp-server-sqlite mcp-server-sqlite --db-path data.db
```

### ğŸŸ¢ Node.js Servers

```bash
# Use npx for Node.js servers
npx -y @modelcontextprotocol/server-filesystem /path/to/files
npx -y @modelcontextprotocol/server-brave-search
```

### ğŸ“ Available Servers

- **ğŸ“ Filesystem**: `@modelcontextprotocol/server-filesystem` 
- **ğŸ—„ï¸ SQLite**: `mcp-server-sqlite` 
- **ğŸ™ GitHub**: `mcp-server-github`
- **â˜ï¸ Google Drive**: `mcp-server-gdrive`
- **ğŸ” Web Search**: `mcp-server-brave-search`
- **ğŸ“Š PostgreSQL**: `mcp-server-postgres`
- **ğŸ“ˆ Analytics**: Various data analytics servers
- **ğŸ”§ Custom**: Build your own with the MCP SDK

Find more at: [MCP Servers Directory](https://github.com/modelcontextprotocol/servers)

## Building MCP Servers

Want to create your own MCP server? Check out:

- **Python**: [`mcp` package](https://pypi.org/project/mcp/)
- **TypeScript**: [`@modelcontextprotocol/sdk`](https://www.npmjs.com/package/@modelcontextprotocol/sdk)
- **Specification**: [MCP Protocol Documentation](https://spec.modelcontextprotocol.io/)

## Development

### Setup with UV

```bash
git clone https://github.com/chrishayuk/chuk-mcp
cd chuk-mcp

# Install with development dependencies
uv sync

# Activate the virtual environment
source .venv/bin/activate  # Linux/Mac
# or .venv\Scripts\activate  # Windows
```

### Traditional Setup

```bash
# Alternative setup with pip
pip install -e ".[dev]"
```

### Testing & Validation

```bash
# Quick validation
uv run examples/quickstart.py

# Run comprehensive tests
uv run examples/e2e_smoke_test_example.py --demo all

# Validate installation scenarios
uv run diagnostics/installation_scenarios_diagnostic.py

# Test specific functionality
uv run examples/e2e_smoke_test_example.py --smoke

# Performance benchmarks
uv run examples/e2e_smoke_test_example.py --performance
```

### Development Features

```bash
# Test with fallback validation
UV_MCP_FORCE_FALLBACK=1 uv run examples/quickstart.py

# Test with different Python versions
uv run --python 3.11 examples/quickstart.py
uv run --python 3.12 examples/quickstart.py
```

### Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for your changes
4. Ensure all tests pass with `uv run diagnostics/installation_scenarios_diagnostic.py`
5. Submit a pull request

## Performance & Monitoring

`chuk-mcp` includes built-in performance monitoring:

```python
import logging

# Enable detailed logging for debugging
logging.basicConfig(level=logging.DEBUG)

# Performance is optimized for:
# - Concurrent server connections
# - Efficient message routing  
# - Minimal memory allocation
# - Fast JSON serialization
```

**Performance Highlights:**
- **ğŸš€ Fast Startup**: < 1 second connection time
- **âš¡ High Throughput**: 50+ requests/second per connection
- **ğŸ”„ Concurrent Operations**: Full async/await support
- **ğŸ’¾ Memory Efficient**: Minimal overhead per connection

## Intelligent Dependency Management

`chuk-mcp` includes intelligent dependency handling with graceful fallbacks:

```python
# Check validation backend
from chuk_mcp.protocol.mcp_pydantic_base import PYDANTIC_AVAILABLE

if PYDANTIC_AVAILABLE:
    print("âœ… Using Pydantic for enhanced validation")
    print("   â€¢ Better error messages")
    print("   â€¢ Faster validation (Rust-based)")
    print("   â€¢ Advanced type coercion")
else:
    print("ğŸ“¦ Using lightweight fallback validation")
    print("   â€¢ Pure Python implementation")
    print("   â€¢ No external dependencies")
    print("   â€¢ ~20x slower but still fast")

# Force fallback mode for testing
import os
os.environ["MCP_FORCE_FALLBACK"] = "1"
```

### Installation Performance Matrix

| Installation | Startup Time | Validation Speed | Memory Usage | Dependencies |
|-------------|-------------|------------------|--------------|--------------|
| `chuk-mcp` | < 0.5s | 0.010ms/op | 15MB | Core only |
| `chuk-mcp[pydantic]` | < 1.0s | 0.000ms/op | 25MB | + Pydantic |
| `chuk-mcp[full]` | < 1.5s | 0.000ms/op | 35MB | All features |

## UV Integration Features

### Project Templates

```bash
# Start a new MCP client project
uv init my-mcp-client
cd my-mcp-client

# Add chuk-mcp with dependencies
uv add chuk-mcp[pydantic]

# Add development tools
uv add --dev pytest black isort

# Create example
cat > main.py << 'EOF'
import anyio
from chuk_mcp import stdio_client, StdioServerParameters

async def main():
    # Your MCP client code here
    pass

if __name__ == "__main__":
    anyio.run(main)
EOF
```

### UV Scripts

Add to your `pyproject.toml`:

```toml
[tool.uv]
dev-dependencies = [
    "chuk-mcp[dev]",
]

[project.scripts]
mcp-client = "my_mcp_client:main"

[tool.uv.scripts]
test-mcp = "uv run examples/quickstart.py"
validate = "uv run diagnostics/installation_scenarios_diagnostic.py"
```

## Support & Community

- **ğŸ“– Documentation**: [Full API Documentation](https://docs.example.com)
- **ğŸ› Issues**: [GitHub Issues](https://github.com/chrishayuk/chuk-mcp/issues)
- **ğŸ’¬ Discussions**: [GitHub Discussions](https://github.com/chrishayuk/chuk-mcp/discussions)
- **ğŸ“§ Email**: For private inquiries
- **ğŸš€ UV**: [UV Package Manager](https://github.com/astral-sh/uv)

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built on the [Model Context Protocol](https://modelcontextprotocol.io/) specification
- Inspired by the official [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- Thanks to the MCP community for feedback and contributions
- Special thanks to the [UV](https://github.com/astral-sh/uv) team for making Python package management fast and reliable
