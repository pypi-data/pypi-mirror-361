#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
"""
Lightweight completion entrypoint for cli.py
Generated by FastEntry - DO NOT EDIT MANUALLY
"""

import os
import sys
from pathlib import Path

def is_completion_request():
    """Check if this is an argcomplete completion request"""
    return os.environ.get('_ARGCOMPLETE') == '1'

def handle_completion_fast():
    """Handle completion requests with minimal imports"""
    try:
        # Try to use snapshot first
        snapshot_path = Path(__file__).parent / "cli_snapshot.json"
        if snapshot_path.exists():
            from fastentry import FastEntry
            try:
                fast_entry = FastEntry(str(snapshot_path))
            except Exception as e:
                raise

            # Create minimal parser for completion
            import argparse
            parser = argparse.ArgumentParser(add_help=False)
            parser.add_argument('-h', '--help', action='help', help='show this help message and exit')

            try:
                result = fast_entry.autocomplete(parser)
                if result:
                    # Use the stored completion function
                    import argcomplete
                    if hasattr(parser, '_fastentry_completer'):
                        completer = getattr(parser, '_fastentry_completer')
                        # Get the current word being completed
                        import os
                        comp_line = os.environ.get('COMP_LINE', '')
                        comp_point = int(os.environ.get('COMP_POINT', 0))
                        words = comp_line.split()

                        # Improved extraction for dynamic completions
                        last_option = None
                        prefix = ''
                        option_being_completed = None
                        # Walk through words to find the last option and set prefix
                        i = 1  # skip the command name
                        while i < len(words):
                            word = words[i]
                            if word.startswith('-'):
                                last_option = word
                                if i == len(words) - 1:
                                    # Cursor is after an option, completing its value
                                    prefix = ''
                                    option_being_completed = last_option
                                    break
                                elif i == len(words) - 2:
                                    # Cursor is after a value for an option
                                    prefix = words[-1]
                                    option_being_completed = last_option
                                    break
                            i += 1
                        else:
                            # Not completing an option value, use improved logic
                            if comp_line.endswith(' ') and comp_point <= len(comp_line):
                                # If the line ends with a space, we're completing after the last word
                                prefix = ''
                            elif len(words) > 1:
                                # Check if we're completing the last word or if there's a partial word
                                if comp_point == len(comp_line):
                                    # Cursor is at the end, completing the last word
                                    prefix = words[-1]
                                else:
                                    # Cursor is in the middle of a word, extract the partial word
                                    partial_word = comp_line[comp_point:].split()[0] if comp_line[comp_point:].strip() else ''
                                    prefix = partial_word
                            else:
                                prefix = ''

                        # Create a mock parsed_args object with the command path (up to the first option)
                        import argparse
                        mock_args = argparse.Namespace()
                        command_path = []
                        for w in words[1:]:
                            if w.startswith('-'):
                                break
                            command_path.append(w)
                        for i, cmd in enumerate(command_path):
                            setattr(mock_args, f'command_{i}', cmd)
                        if command_path:
                            setattr(mock_args, 'command', command_path[0])

                        completions = completer(prefix, mock_args, option_being_completed=option_being_completed)

                        # Print completions for bash
                        for completion in completions:
                            print(completion)
                    else:
                        argcomplete.autocomplete(parser)
                    return
                else:
                    pass
            except Exception as e:
                raise

        # Fallback to regular argcomplete
        import argcomplete
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument('-h', '--help', action='help', help='show this help message and exit')
        argcomplete.autocomplete(parser)

    except Exception as e:
        # Final fallback: import the original CLI (slow but works)
        print(f"Fast completion failed: {e}", file=sys.stderr)
        import cli
        cli.main()

def main():
    """Main entry point"""
    if is_completion_request():
        handle_completion_fast()
        return

    # Import and run the original CLI
    import cli
    cli.main()

if __name__ == "__main__":
    main()
