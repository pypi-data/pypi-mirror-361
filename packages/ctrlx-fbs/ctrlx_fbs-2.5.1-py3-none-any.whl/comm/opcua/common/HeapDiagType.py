# automatically generated by the FlatBuffers compiler, do not modify

# namespace: common

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class HeapDiagType(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = HeapDiagType()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsHeapDiagType(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # HeapDiagType
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # HeapDiagType
    def UsedMemory(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # HeapDiagType
    def MaxUsedMemory(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # HeapDiagType
    def TotalMemory(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def HeapDiagTypeStart(builder): builder.StartObject(3)
def Start(builder):
    return HeapDiagTypeStart(builder)
def HeapDiagTypeAddUsedMemory(builder, usedMemory): builder.PrependUint32Slot(0, usedMemory, 0)
def AddUsedMemory(builder, usedMemory):
    return HeapDiagTypeAddUsedMemory(builder, usedMemory)
def HeapDiagTypeAddMaxUsedMemory(builder, maxUsedMemory): builder.PrependUint32Slot(1, maxUsedMemory, 0)
def AddMaxUsedMemory(builder, maxUsedMemory):
    return HeapDiagTypeAddMaxUsedMemory(builder, maxUsedMemory)
def HeapDiagTypeAddTotalMemory(builder, totalMemory): builder.PrependUint32Slot(2, totalMemory, 0)
def AddTotalMemory(builder, totalMemory):
    return HeapDiagTypeAddTotalMemory(builder, totalMemory)
def HeapDiagTypeEnd(builder): return builder.EndObject()
def End(builder):
    return HeapDiagTypeEnd(builder)

class HeapDiagTypeT(object):

    # HeapDiagTypeT
    def __init__(self):
        self.usedMemory = 0  # type: int
        self.maxUsedMemory = 0  # type: int
        self.totalMemory = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        heapDiagType = HeapDiagType()
        heapDiagType.Init(buf, pos)
        return cls.InitFromObj(heapDiagType)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, heapDiagType):
        x = HeapDiagTypeT()
        x._UnPack(heapDiagType)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.usedMemory == other.usedMemory and \
            self.maxUsedMemory == other.maxUsedMemory and \
            self.totalMemory == other.totalMemory

    # HeapDiagTypeT
    def _UnPack(self, heapDiagType):
        if heapDiagType is None:
            return
        self.usedMemory = heapDiagType.UsedMemory()
        self.maxUsedMemory = heapDiagType.MaxUsedMemory()
        self.totalMemory = heapDiagType.TotalMemory()

    # HeapDiagTypeT
    def Pack(self, builder):
        HeapDiagTypeStart(builder)
        HeapDiagTypeAddUsedMemory(builder, self.usedMemory)
        HeapDiagTypeAddMaxUsedMemory(builder, self.maxUsedMemory)
        HeapDiagTypeAddTotalMemory(builder, self.totalMemory)
        heapDiagType = HeapDiagTypeEnd(builder)
        return heapDiagType
