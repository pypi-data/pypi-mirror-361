"""
Auto-generated types from PostCrawl API.

DO NOT EDIT THIS FILE MANUALLY!
Re-generate with: cd sdks/typegen && python generate.py
"""

# generated by datamodel-codegen:
#   filename:  combined.schema.json
#   timestamp: 2025-07-09T20:51:54+00:00

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Any, Literal

from pydantic import BaseModel, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class CseImageItem(BaseModel):
    src: str


class Pagemap(BaseModel):
    cse_image: list[CseImageItem] | None = None


class Snippet(BaseModel):
    snippet: str


class DerivedStructData(BaseModel):
    formatted_url: Annotated[str | None, Field(alias="formattedUrl")] = None
    html_formatted_url: Annotated[str | None, Field(alias="htmlFormattedUrl")] = None
    link: str | None = None
    pagemap: Pagemap | None = None
    snippets: list[Snippet] | None = None
    title: str | None = None


class Document(BaseModel):
    derived_struct_data: Annotated[DerivedStructData | None, Field(alias="derivedStructData")] = (
        None
    )


class GoogleSearchItem(BaseModel):
    document: Document | None = None


class SearchService(BaseModel):
    pass


class ExtractResultModel(BaseModel):
    """
    Result model for calculating credits after extract operation execution
    """

    include_comments: bool | None = None
    successful_urls: Annotated[list[str], Field(alias="successfulUrls")]


class PlatformCounts(BaseModel):
    reddit: float
    tiktok: float
    unknown: float


class RedditComment(BaseModel):
    created_at: Annotated[datetime, Field(alias="createdAt")]
    downvotes: float
    id: str
    parent_id: Annotated[str, Field(alias="parentId")]
    permalink: str
    replies: list[RedditComment] | None = None
    score: float
    text: str
    upvotes: float


class RedditCommentAPI(BaseModel):
    created_at: Annotated[str, Field(alias="createdAt")]
    downvotes: float
    id: str
    parent_id: Annotated[str, Field(alias="parentId")]
    permalink: str
    replies: list[RedditCommentAPI] | None = None
    score: float
    text: str
    upvotes: float


class RedditPost(BaseModel):
    comments: list[RedditComment] | None = None
    created_at: Annotated[datetime, Field(alias="createdAt")]
    description: str
    downvotes: float
    id: str
    name: str
    score: float
    subreddit_name: Annotated[str, Field(alias="subredditName")]
    title: str
    upvotes: float
    url: str


class SNEResultModel(BaseModel):
    """
    Result model for calculating credits after search-and-extract operation execution
    """

    include_comments: bool | None = None
    search_result_count: Annotated[float, Field(alias="searchResultCount")]
    social_platforms: list[Literal["reddit", "tiktok"]]
    successful_extract_urls: Annotated[list[str], Field(alias="successfulExtractUrls")]


class SearchResult(BaseModel):
    date: str
    image_url: Annotated[str, Field(alias="imageUrl")]
    snippet: str
    title: str
    url: str


class SearchResultModel(BaseModel):
    """
    Result model for calculating credits after search operation execution
    """

    actual_result_count: Annotated[float, Field(alias="actualResultCount")]


class SocialPlatform(RootModel[Literal["reddit", "tiktok"]]):
    root: Literal["reddit", "tiktok"]


T = SearchService


class TiktokReply(BaseModel):
    avatar_url: Annotated[str, Field(alias="avatarUrl")]
    created_at: Annotated[datetime, Field(alias="createdAt")]
    id: str
    likes: float
    nickname: str
    text: str
    username: str


class FieldNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefined(
    BaseModel
):
    comments: list[RedditCommentAPI] | None = None
    created_at: Annotated[str, Field(alias="createdAt")]
    description: str
    downvotes: float
    id: str
    name: str
    score: float
    subreddit_name: Annotated[str, Field(alias="subredditName")]
    title: str
    upvotes: float
    url: str


class FieldTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlString(
    BaseModel
):
    avatar_url: Annotated[str, Field(alias="avatarUrl")]
    created_at: Annotated[str, Field(alias="createdAt")]
    id: str
    likes: float
    nickname: str
    text: str
    username: str


class ExtractFormData(BaseModel):
    include_comments: bool | None = None
    request_type: Literal["extract"]
    response_mode: Literal["markdown", "raw"] | None = None
    urls: str


class ExtractModel(BaseModel):
    include_comments: bool | None = None
    response_mode: Literal["markdown", "raw"] | None = None
    urls: list[str]


ExtractRequest = ExtractModel


class SearchAndExtractFormData(BaseModel):
    include_comments: bool | None = None
    page: float
    query: str
    request_type: Literal["search-and-extract"]
    response_mode: Literal["markdown", "raw"] | None = None
    results: float
    social_platforms: list[Literal["reddit", "tiktok"]]


class SearchAndExtractModel(BaseModel):
    include_comments: bool | None = None
    page: float
    query: str
    response_mode: Literal["markdown", "raw"] | None = None
    results: float
    social_platforms: list[Literal["reddit", "tiktok"]]


SearchAndExtractRequest = SearchAndExtractModel


class SearchFormData(BaseModel):
    page: float
    query: str
    request_type: Literal["search"]
    results: float
    social_platforms: list[Literal["reddit", "tiktok"]]


class SearchRequest(BaseModel):
    page: float
    query: str
    results: float
    social_platforms: list[Literal["reddit", "tiktok"]]


SearchFormField = SearchFormData

SearchFormFieldAndExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined = (
    SearchAndExtractFormData
)

FieldTitleStringDateStringUrlStringSnippetStringImageUrlString = SearchResult

FieldUrlsStringRequestTypeExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined = (
    ExtractFormData
)


class Country(
    RootModel[
        Literal[
            "ad",
            "ae",
            "ag",
            "ai",
            "al",
            "all",
            "am",
            "an",
            "ao",
            "aq",
            "ar",
            "as",
            "at",
            "au",
            "aw",
            "az",
            "ba",
            "bb",
            "bd",
            "be",
            "bf",
            "bg",
            "bh",
            "bi",
            "bj",
            "bm",
            "bn",
            "bo",
            "br",
            "bs",
            "bt",
            "bv",
            "bw",
            "by",
            "bz",
            "ca",
            "cc",
            "cd",
            "cf",
            "cg",
            "ch",
            "ci",
            "ck",
            "cl",
            "cm",
            "cn",
            "co",
            "cr",
            "cs",
            "cu",
            "cv",
            "cx",
            "cy",
            "cz",
            "de",
            "dj",
            "dk",
            "dm",
            "do",
            "dz",
            "ec",
            "ee",
            "eg",
            "eh",
            "er",
            "es",
            "et",
            "f",
            "fi",
            "fj",
            "fk",
            "fm",
            "fo",
            "fr",
            "ga",
            "gd",
            "ge",
            "gf",
            "gh",
            "gi",
            "gl",
            "gm",
            "gn",
            "gp",
            "gq",
            "gr",
            "gs",
            "gt",
            "gu",
            "gw",
            "gy",
            "hk",
            "hm",
            "hn",
            "hr",
            "ht",
            "hu",
            "id",
            "ie",
            "il",
            "in",
            "io",
            "iq",
            "ir",
            "is",
            "it",
            "jm",
            "jo",
            "jp",
            "ke",
            "kg",
            "kh",
            "ki",
            "km",
            "kn",
            "kp",
            "kr",
            "kw",
            "ky",
            "kz",
            "la",
            "lb",
            "lc",
            "li",
            "lk",
            "lr",
            "ls",
            "lt",
            "lu",
            "lv",
            "ly",
            "ma",
            "mc",
            "md",
            "mg",
            "mh",
            "mk",
            "ml",
            "mm",
            "mn",
            "mo",
            "mp",
            "mq",
            "mr",
            "ms",
            "mt",
            "mu",
            "mv",
            "mw",
            "mx",
            "my",
            "mz",
            "na",
            "nc",
            "ne",
            "nf",
            "ng",
            "ni",
            "nl",
            "no",
            "np",
            "nr",
            "nu",
            "nz",
            "om",
            "pa",
            "pe",
            "pf",
            "pg",
            "ph",
            "pk",
            "pl",
            "pm",
            "pn",
            "pr",
            "ps",
            "pt",
            "pw",
            "py",
            "qa",
            "re",
            "ro",
            "ru",
            "rw",
            "sa",
            "sb",
            "sc",
            "sd",
            "se",
            "sg",
            "sh",
            "si",
            "sj",
            "sk",
            "sl",
            "sm",
            "sn",
            "so",
            "sr",
            "st",
            "sv",
            "sy",
            "sz",
            "tc",
            "td",
            "tf",
            "tg",
            "th",
            "tj",
            "tk",
            "tl",
            "tm",
            "tn",
            "to",
            "tr",
            "tt",
            "tv",
            "tw",
            "tz",
            "ua",
            "ug",
            "uk",
            "um",
            "us",
            "uy",
            "uz",
            "va",
            "vc",
            "ve",
            "vg",
            "vi",
            "vn",
            "vu",
            "wf",
            "ws",
            "ye",
            "yt",
            "za",
            "zm",
            "zw",
        ]
    ]
):
    root: Literal[
        "ad",
        "ae",
        "ag",
        "ai",
        "al",
        "all",
        "am",
        "an",
        "ao",
        "aq",
        "ar",
        "as",
        "at",
        "au",
        "aw",
        "az",
        "ba",
        "bb",
        "bd",
        "be",
        "bf",
        "bg",
        "bh",
        "bi",
        "bj",
        "bm",
        "bn",
        "bo",
        "br",
        "bs",
        "bt",
        "bv",
        "bw",
        "by",
        "bz",
        "ca",
        "cc",
        "cd",
        "cf",
        "cg",
        "ch",
        "ci",
        "ck",
        "cl",
        "cm",
        "cn",
        "co",
        "cr",
        "cs",
        "cu",
        "cv",
        "cx",
        "cy",
        "cz",
        "de",
        "dj",
        "dk",
        "dm",
        "do",
        "dz",
        "ec",
        "ee",
        "eg",
        "eh",
        "er",
        "es",
        "et",
        "f",
        "fi",
        "fj",
        "fk",
        "fm",
        "fo",
        "fr",
        "ga",
        "gd",
        "ge",
        "gf",
        "gh",
        "gi",
        "gl",
        "gm",
        "gn",
        "gp",
        "gq",
        "gr",
        "gs",
        "gt",
        "gu",
        "gw",
        "gy",
        "hk",
        "hm",
        "hn",
        "hr",
        "ht",
        "hu",
        "id",
        "ie",
        "il",
        "in",
        "io",
        "iq",
        "ir",
        "is",
        "it",
        "jm",
        "jo",
        "jp",
        "ke",
        "kg",
        "kh",
        "ki",
        "km",
        "kn",
        "kp",
        "kr",
        "kw",
        "ky",
        "kz",
        "la",
        "lb",
        "lc",
        "li",
        "lk",
        "lr",
        "ls",
        "lt",
        "lu",
        "lv",
        "ly",
        "ma",
        "mc",
        "md",
        "mg",
        "mh",
        "mk",
        "ml",
        "mm",
        "mn",
        "mo",
        "mp",
        "mq",
        "mr",
        "ms",
        "mt",
        "mu",
        "mv",
        "mw",
        "mx",
        "my",
        "mz",
        "na",
        "nc",
        "ne",
        "nf",
        "ng",
        "ni",
        "nl",
        "no",
        "np",
        "nr",
        "nu",
        "nz",
        "om",
        "pa",
        "pe",
        "pf",
        "pg",
        "ph",
        "pk",
        "pl",
        "pm",
        "pn",
        "pr",
        "ps",
        "pt",
        "pw",
        "py",
        "qa",
        "re",
        "ro",
        "ru",
        "rw",
        "sa",
        "sb",
        "sc",
        "sd",
        "se",
        "sg",
        "sh",
        "si",
        "sj",
        "sk",
        "sl",
        "sm",
        "sn",
        "so",
        "sr",
        "st",
        "sv",
        "sy",
        "sz",
        "tc",
        "td",
        "tf",
        "tg",
        "th",
        "tj",
        "tk",
        "tl",
        "tm",
        "tn",
        "to",
        "tr",
        "tt",
        "tv",
        "tw",
        "tz",
        "ua",
        "ug",
        "uk",
        "um",
        "us",
        "uy",
        "uz",
        "va",
        "vc",
        "ve",
        "vg",
        "vi",
        "vn",
        "vu",
        "wf",
        "ws",
        "ye",
        "yt",
        "za",
        "zm",
        "zw",
    ]


class Language(
    RootModel[
        Literal[
            "ar-SA",
            "bn-BD",
            "bn-IN",
            "cs-CZ",
            "da-DK",
            "de-AT",
            "de-CH",
            "de-DE",
            "el-GR",
            "en-AU",
            "en-CA",
            "en-GB",
            "en-IE",
            "en-IN",
            "en-NZ",
            "en-US",
            "en-ZA",
            "fi-FI",
            "fr-BE",
            "fr-CA",
            "fr-CH",
            "fr-FR",
            "he-IL",
            "hi-IN",
            "hu-HU",
            "id-ID",
            "it-CH",
            "it-IT",
            "ja-JP",
            "ko-KR",
            "nl-BE",
            "nl-NL",
            "no-NO",
            "pl-PL",
            "pt-BR",
            "pt-PT",
            "ro-RO",
            "ru-RU",
            "sk-SK",
            "sv-SE",
            "ta-IN",
            "ta-LK",
            "th-TH",
            "tr-TR",
            "zh-CN",
            "zh-HK",
            "zh-TW",
        ]
    ]
):
    root: Literal[
        "ar-SA",
        "bn-BD",
        "bn-IN",
        "cs-CZ",
        "da-DK",
        "de-AT",
        "de-CH",
        "de-DE",
        "el-GR",
        "en-AU",
        "en-CA",
        "en-GB",
        "en-IE",
        "en-IN",
        "en-NZ",
        "en-US",
        "en-ZA",
        "fi-FI",
        "fr-BE",
        "fr-CA",
        "fr-CH",
        "fr-FR",
        "he-IL",
        "hi-IN",
        "hu-HU",
        "id-ID",
        "it-CH",
        "it-IT",
        "ja-JP",
        "ko-KR",
        "nl-BE",
        "nl-NL",
        "no-NO",
        "pl-PL",
        "pt-BR",
        "pt-PT",
        "ro-RO",
        "ru-RU",
        "sk-SK",
        "sv-SE",
        "ta-IN",
        "ta-LK",
        "th-TH",
        "tr-TR",
        "zh-CN",
        "zh-HK",
        "zh-TW",
    ]


class ExtractInput(BaseModel):
    detailed: bool | None = None
    response_mode: Literal["markdown", "raw"]
    sources: list[Literal["reddit", "tiktok"]]
    urls: list[str]


class ExtractionInput(RootModel[list[str]]):
    root: list[str]


ExtractorClient = SearchService


class PostOutputT(BaseModel):
    error: str | None = None
    markdown: str | None = None
    raw: RedditPost | TiktokPost | None = None
    source: Literal["reddit", "tiktok"]
    url: str


class PostURLRequest(BaseModel):
    detailed: bool | None = None
    urls: list[str]


class PostsResponse(BaseModel):
    fails: float
    posts_responses: Annotated[list[PostOutputT], Field(alias="postsResponses")]
    requests: float
    time: float


class SearchInput(BaseModel):
    autocorrect: bool
    country: (
        Literal[
            "ad",
            "ae",
            "ag",
            "ai",
            "al",
            "all",
            "am",
            "an",
            "ao",
            "aq",
            "ar",
            "as",
            "at",
            "au",
            "aw",
            "az",
            "ba",
            "bb",
            "bd",
            "be",
            "bf",
            "bg",
            "bh",
            "bi",
            "bj",
            "bm",
            "bn",
            "bo",
            "br",
            "bs",
            "bt",
            "bv",
            "bw",
            "by",
            "bz",
            "ca",
            "cc",
            "cd",
            "cf",
            "cg",
            "ch",
            "ci",
            "ck",
            "cl",
            "cm",
            "cn",
            "co",
            "cr",
            "cs",
            "cu",
            "cv",
            "cx",
            "cy",
            "cz",
            "de",
            "dj",
            "dk",
            "dm",
            "do",
            "dz",
            "ec",
            "ee",
            "eg",
            "eh",
            "er",
            "es",
            "et",
            "f",
            "fi",
            "fj",
            "fk",
            "fm",
            "fo",
            "fr",
            "ga",
            "gd",
            "ge",
            "gf",
            "gh",
            "gi",
            "gl",
            "gm",
            "gn",
            "gp",
            "gq",
            "gr",
            "gs",
            "gt",
            "gu",
            "gw",
            "gy",
            "hk",
            "hm",
            "hn",
            "hr",
            "ht",
            "hu",
            "id",
            "ie",
            "il",
            "in",
            "io",
            "iq",
            "ir",
            "is",
            "it",
            "jm",
            "jo",
            "jp",
            "ke",
            "kg",
            "kh",
            "ki",
            "km",
            "kn",
            "kp",
            "kr",
            "kw",
            "ky",
            "kz",
            "la",
            "lb",
            "lc",
            "li",
            "lk",
            "lr",
            "ls",
            "lt",
            "lu",
            "lv",
            "ly",
            "ma",
            "mc",
            "md",
            "mg",
            "mh",
            "mk",
            "ml",
            "mm",
            "mn",
            "mo",
            "mp",
            "mq",
            "mr",
            "ms",
            "mt",
            "mu",
            "mv",
            "mw",
            "mx",
            "my",
            "mz",
            "na",
            "nc",
            "ne",
            "nf",
            "ng",
            "ni",
            "nl",
            "no",
            "np",
            "nr",
            "nu",
            "nz",
            "om",
            "pa",
            "pe",
            "pf",
            "pg",
            "ph",
            "pk",
            "pl",
            "pm",
            "pn",
            "pr",
            "ps",
            "pt",
            "pw",
            "py",
            "qa",
            "re",
            "ro",
            "ru",
            "rw",
            "sa",
            "sb",
            "sc",
            "sd",
            "se",
            "sg",
            "sh",
            "si",
            "sj",
            "sk",
            "sl",
            "sm",
            "sn",
            "so",
            "sr",
            "st",
            "sv",
            "sy",
            "sz",
            "tc",
            "td",
            "tf",
            "tg",
            "th",
            "tj",
            "tk",
            "tl",
            "tm",
            "tn",
            "to",
            "tr",
            "tt",
            "tv",
            "tw",
            "tz",
            "ua",
            "ug",
            "uk",
            "um",
            "us",
            "uy",
            "uz",
            "va",
            "vc",
            "ve",
            "vg",
            "vi",
            "vn",
            "vu",
            "wf",
            "ws",
            "ye",
            "yt",
            "za",
            "zm",
            "zw",
        ]
        | None
    ) = None
    end_date: datetime | None = None
    language: (
        Literal[
            "ar-SA",
            "bn-BD",
            "bn-IN",
            "cs-CZ",
            "da-DK",
            "de-AT",
            "de-CH",
            "de-DE",
            "el-GR",
            "en-AU",
            "en-CA",
            "en-GB",
            "en-IE",
            "en-IN",
            "en-NZ",
            "en-US",
            "en-ZA",
            "fi-FI",
            "fr-BE",
            "fr-CA",
            "fr-CH",
            "fr-FR",
            "he-IL",
            "hi-IN",
            "hu-HU",
            "id-ID",
            "it-CH",
            "it-IT",
            "ja-JP",
            "ko-KR",
            "nl-BE",
            "nl-NL",
            "no-NO",
            "pl-PL",
            "pt-BR",
            "pt-PT",
            "ro-RO",
            "ru-RU",
            "sk-SK",
            "sv-SE",
            "ta-IN",
            "ta-LK",
            "th-TH",
            "tr-TR",
            "zh-CN",
            "zh-HK",
            "zh-TW",
        ]
        | None
    ) = None
    page: float
    query: str
    results: float
    social_platforms: list[Literal["reddit", "tiktok"]]
    start_date: datetime | None = None


class GuidedSearchResultItem(BaseModel):
    category: str | None = None
    confidence: float | None = None
    display_text: Annotated[str, Field(alias="displayText")]
    query: str


RecordStringUnknown = SearchService


class Params(BaseModel):
    user_country_code: str


class GuidedSearchResult(BaseModel):
    suggestions: list[GuidedSearchResultItem]


class Source(BaseModel):
    document_id: Annotated[str, Field(alias="documentId")]
    snippet: str | None = None
    title: str | None = None


class SearchSummary(BaseModel):
    confidence: float | None = None
    sources: list[Source] | None = None
    summary_text: Annotated[str, Field(alias="summaryText")]


class SnippetModel(BaseModel):
    html_snippet: Annotated[str | None, Field(alias="htmlSnippet")] = None
    snippet: str


class SpellCorrectionSpec(BaseModel):
    mode: Literal["AUTO", "MODE_UNSPECIFIED", "SUGGEST_ONLY"] | None = None


PostOutput = PostOutputT


class TiktokComment(BaseModel):
    avatar_url: Annotated[str, Field(alias="avatarUrl")]
    created_at: Annotated[datetime, Field(alias="createdAt")]
    id: str
    likes: float
    nickname: str
    replies: list[TiktokReply]
    text: str
    username: str


class TiktokPost(BaseModel):
    field_has_error: Annotated[bool | None, Field(alias="_hasError")] = None
    comments: list[TiktokComment]
    created_at: Annotated[datetime, Field(alias="createdAt")]
    description: str
    detailed_description: Annotated[str | None, Field(alias="detailedDescription")] = None
    hashtags: list[str]
    id: str
    keywords: list[str] | None = None
    likes: str
    title: str | None = None
    total_comments: Annotated[float, Field(alias="totalComments")]
    url: str
    username: str


class FieldTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlString(
    BaseModel
):
    avatar_url: Annotated[str, Field(alias="avatarUrl")]
    created_at: Annotated[str, Field(alias="createdAt")]
    id: str
    likes: float
    nickname: str
    replies: list[
        FieldTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlString
    ]
    text: str
    username: str


class FieldUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefined(
    BaseModel
):
    field_has_error: Annotated[bool | None, Field(alias="_hasError")] = None
    comments: list[
        FieldTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlString
    ]
    created_at: Annotated[str, Field(alias="createdAt")]
    description: str
    detailed_description: Annotated[str | None, Field(alias="detailedDescription")] = None
    hashtags: list[str]
    id: str
    keywords: list[str] | None = None
    likes: str
    title: str | None = None
    total_comments: Annotated[float, Field(alias="totalComments")]
    url: str
    username: str


class PlaygroundFormData(
    RootModel[
        FieldUrlsStringRequestTypeExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined
        | SearchFormField
        | SearchFormFieldAndExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined
    ]
):
    root: (
        FieldUrlsStringRequestTypeExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined
        | SearchFormField
        | SearchFormFieldAndExtractIncludeCommentsBooleanUndefinedResponseModeRawMarkdownUndefined
    )


class SearchResponse(
    RootModel[list[FieldTitleStringDateStringUrlStringSnippetStringImageUrlString]]
):
    root: list[FieldTitleStringDateStringUrlStringSnippetStringImageUrlString]


class FieldSourceStringUrlStringErrorStringNullUndefinedRawNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefinedUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefinedNullUndefinedMarkdownStringNullUndefined(
    BaseModel
):
    error: str | None = None
    markdown: str | None = None
    raw: (
        FieldNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefined
        | FieldUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefined
        | None
    ) = None
    source: str
    url: str


class SNEInput(SearchInput):
    include_comments: bool | None = None
    response_mode: Literal["markdown", "raw"]


class DerivedStructData1(BaseModel):
    formatted_url: Annotated[str | None, Field(alias="formattedUrl")] = None
    html_formatted_url: Annotated[str | None, Field(alias="htmlFormattedUrl")] = None
    html_title: Annotated[str | None, Field(alias="htmlTitle")] = None
    link: str | None = None
    pagemap: RecordStringUnknown | None = None
    snippets: list[SnippetModel]
    title: str | None = None


class Document1(BaseModel):
    derived_struct_data: Annotated[DerivedStructData1, Field(alias="derivedStructData")]
    id: str | None = None
    name: str | None = None


class SearchLiteSearchPayload(BaseModel):
    filter: str | None = None
    """
    Filter string for search results.
    For date range filtering use format: "publishDate >= 'YYYY-MM-DD' AND publishDate <= 'YYYY-MM-DD'"
    """
    language_code: Annotated[str | None, Field(alias="languageCode")] = None
    offset: float | None = None
    page_size: Annotated[float | None, Field(alias="pageSize")] = None
    params: Params | None = None
    query: str
    spell_correction_spec: Annotated[
        SpellCorrectionSpec | None, Field(alias="spellCorrectionSpec")
    ] = None


class SearchLiteSearchResult(BaseModel):
    document: Document1
    id: str


class SearchOutput(BaseModel):
    attribution_token: Annotated[str | None, Field(alias="attributionToken")] = None
    guided_search_result: Annotated[
        GuidedSearchResult | None, Field(alias="guidedSearchResult")
    ] = None
    next_page_token: Annotated[str | None, Field(alias="nextPageToken")] = None
    results: list[SearchLiteSearchResult] | None = None
    summary: SearchSummary | None = None
    total_size: Annotated[float | None, Field(alias="totalSize")] = None


ExtractedPost = FieldSourceStringUrlStringErrorStringNullUndefinedRawNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefinedUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefinedNullUndefinedMarkdownStringNullUndefined


class ExtractResponse(
    RootModel[
        list[
            FieldSourceStringUrlStringErrorStringNullUndefinedRawNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefinedUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefinedNullUndefinedMarkdownStringNullUndefined
        ]
    ]
):
    root: list[
        FieldSourceStringUrlStringErrorStringNullUndefinedRawNameStringTitleStringUrlStringIdStringDescriptionStringSubredditNameStringUpvotesNumberDownvotesNumberScoreNumberCreatedAtStringCommentsRedditCommentAPIUndefinedUsernameStringUrlStringIdStringDescriptionStringCreatedAtStringCommentsTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringRepliesTextStringUsernameStringIdStringCreatedAtStringLikesNumberNicknameStringAvatarUrlStringHashtagsStringLikesStringTotalCommentsNumberTitleStringUndefinedDetailedDescriptionStringUndefinedKeywordsStringUndefinedHasErrorBooleanUndefinedNullUndefinedMarkdownStringNullUndefined
    ]


class SearchAndExtractResponse(ExtractResponse):
    pass


SearchLiteSearchResponse = SearchOutput

RedditComment.model_rebuild()
RedditCommentAPI.model_rebuild()
