# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from frequenz.api.microgrid.v1alpha18 import microgrid_pb2 as frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2

GRPC_GENERATED_VERSION = '1.72.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in frequenz/api/microgrid/v1alpha18/microgrid_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class MicrogridStub(object):
    """The Frequenz Microgrid API
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetMicrogrid = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/GetMicrogrid',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.GetMicrogridResponse.FromString,
                _registered_method=True)
        self.ListElectricalComponents = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/ListElectricalComponents',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsResponse.FromString,
                _registered_method=True)
        self.ListSensors = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/ListSensors',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorsResponse.FromString,
                _registered_method=True)
        self.ListElectricalComponentConnections = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/ListElectricalComponentConnections',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsResponse.FromString,
                _registered_method=True)
        self.ReceiveElectricalComponentTelemetryStream = channel.unary_stream(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/ReceiveElectricalComponentTelemetryStream',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamResponse.FromString,
                _registered_method=True)
        self.ReceiveSensorTelemetryStream = channel.unary_stream(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/ReceiveSensorTelemetryStream',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamResponse.FromString,
                _registered_method=True)
        self.AugmentElectricalComponentBounds = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/AugmentElectricalComponentBounds',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsResponse.FromString,
                _registered_method=True)
        self.SetElectricalComponentPower = channel.unary_stream(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/SetElectricalComponentPower',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerResponse.FromString,
                _registered_method=True)
        self.StartElectricalComponent = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/StartElectricalComponent',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StartElectricalComponentRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)
        self.PutElectricalComponentInStandby = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/PutElectricalComponentInStandby',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.PutElectricalComponentInStandbyRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)
        self.StopElectricalComponent = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/StopElectricalComponent',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StopElectricalComponentRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)
        self.AckElectricalComponentError = channel.unary_unary(
                '/frequenz.api.microgrid.v1alpha18.Microgrid/AckElectricalComponentError',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AckElectricalComponentErrorRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)


class MicrogridServicer(object):
    """The Frequenz Microgrid API
    """

    def GetMicrogrid(self, request, context):
        """Returns information about the local microgrid.
        This information that describes the overall microgrid, as opposed to its
        electrical components or sensors, e.g., the microgrid ID, location.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListElectricalComponents(self, request, context):
        """List electrical components in the local microgrid, optionally filtered by a
        given list of electrical component IDs and their categories.

        Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        If provided, the filters for electrical component IDs and categories have
        an `AND` relationship with one another, meaning that they are applied
        serially, but the elements within a single filter list have an `OR`
        relationship with each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
        `ElectricalComponentCategory::ELECTRICAL_COMPONENT_CATEGORY_INVERTER`,
        `ElectricalComponentCategory::ELECTRICAL_COMPONENT_CATEGORY_BATTERY`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories
        `ElectricalComponentCategory::ELECTRICAL_COMPONENT_CATEGORY_INVERTER` OR
        `ElectricalComponentCategory::ELECTRICAL_COMPONENT_CATEGORY_BATTERY`.

        If a filter list is empty, then that filter is not applied.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListSensors(self, request, context):
        """Returns a list of sensors in the local microgrid, optionally filtered by a
        given list of sensor IDs.

        Sensors measure physical metrics in the microgrid's surroundings, and are
        not classified as electrical components.

        If provided, the filters for sensor IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,

        If a filter list is empty, then that filter is not applied.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListElectricalComponentConnections(self, request, context):
        """Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        This RPC return a list of the connections between two electrical
        components, denoted by `(start, end)`. The direction of a connection is
        always away from the grid endpoint, i.e. aligned with the direction of
        positive current according to the passive sign convention:
        https://en.wikipedia.org/wiki/Passive_sign_convention

        The request may be filtered by `start`/`end` electrical component(s) of
        individual connections.  If provided, the `start` and `end` filters have an
        `AND` relationship between each other, meaning that they are applied
        serially, but an `OR` relationship with other elements in the same list.
        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
        result should have all the connections where
        * each `start` electrical component ID is either `1`, `2`, OR `3`,
        AND
        * each `end` electrical component ID is either `4`, `5`, OR `6`.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReceiveElectricalComponentTelemetryStream(self, request, context):
        """Returns a stream containing data from a electrical component with a given ID.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReceiveSensorTelemetryStream(self, request, context):
        """Returns a stream containing data from a sensor with a given ID.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AugmentElectricalComponentBounds(self, request, context):
        """Augments the overall bounds for a given metric of a given electrical
        component with the provided bounds.
        Returns the UTC time at which the provided bounds will expire and its
        effects will no longer be visible in the overall bounds for the
        given metric.

        The request parameters allows users to select a duration until
        which the bounds will stay in effect. If no duration is provided, then the
        bounds will be removed after a default duration of 5 seconds.

        Inclusion bounds give the range that the system will try to keep the
        metric within. If the metric goes outside of these bounds, the system will
        try to bring it back within the bounds.
        If the bounds for a metric are [[`lower_1`, `upper_1`],
        [`lower_2`, `upper_2`]], then this metric's `value` needs to comply with
        the constraints
        `lower_1 <= value <= upper_1` OR `lower_2 <= value <= upper_2`.

        If multiple inclusion bounds have been provided for a metric, then the
        overlapping bounds are merged into a single bound, and non-overlapping
        bounds are kept separate.
        E.g. if the bounds are [[0, 10], [5, 15], [20, 30]], then the resulting
        bounds will be [[0, 15], [20, 30]].

        The following diagram illustrates how bounds are applied:
        ```
        lower_1  upper_1
        <----|========|--------|========|-------->
        lower_2  upper_2
        ```
        The bounds in this example are `[[lower_1, upper_1], [lower_2, upper_2]]`.
        ---- values here are considered out of range.
        ==== values here are considered within range.

        Note that for power metrics, regardless of the bounds, 0W is always
        allowed.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetElectricalComponentPower(self, request, context):
        """Sets the active or reactive power output of a electrical component to a
        specified target.
        This RPC allows setting either active or reactive power in a single
        request. Setting both simultaneously is not supported; clients must issue
        separate requests for each power type.

        Clients are expected to provide the target power in the request parameters.
        The target power is specified in watts (W) for active power, and in
        volt-amperes reactive (VAR) for reactive power. The sign-convention for the
        target power is as follows:

        For active power:
        - Negative values (-) indicate discharge towards the grid.
        - Positive values (+) indicate charge from the direction of the grid.

        For reactive power:
        - Negative values (-) indicate capacitive reactive power, where the
        current leads the voltage.
        - Positive values (+) indicate inductive reactive power, where the
        current lags the voltage.

        Note that the target electrical component may have a resolution of more
        than 1 W or 1 VAr. E.g., an inverter may have a resolution of 88 W.
        In such cases, the target power's magnitude will be floored to the nearest
        multiple of the resolution.

        The server provides a stream of responses in return. Each response will
        contain the current status of the request.
        **Initial response:** The initial response will be sent immediately after
        the request is received, and will indicate whether the request was accepted
        or rejected. If the request was accepted, this response will also contain
        the timestamp until which the given power command will stay in effect,
        after which the electrical component will be returned to its default state.
        **Subsequent response:** After the initial response, the server will send
        another response in the stream, which will be the final response. It will
        indicate whether the request was successful, failed, or overridden by
        another request. If the request was successful, it will also contain the
        timestamp until which the given power command will stay in effect, after
        which the electrical component will be returned to its default state.

        This command is supported for the following electrical component
        categories, provided the specific model also supports it:
        - `ELECTRICAL_COMPONENT_CATEGORY_CAPACITOR_BANK`
        - `ELECTRICAL_COMPONENT_CATEGORY_CHP`
        - `ELECTRICAL_COMPONENT_CATEGORY_ELECTROLYZER`
        - `ELECTRICAL_COMPONENT_CATEGORY_EV_CHARGER`
        - `ELECTRICAL_COMPONENT_CATEGORY_INVERTER`
        - `ELECTRICAL_COMPONENT_CATEGORY_WIND_TURBINE`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StartElectricalComponent(self, request, context):
        """Starts the electrical component, and brings it into a state where it is
        immediately operational.

        Performs the following sequence of actions for the following electrical
        component categories:

        * Inverter:
        * closes DC relays, if the feature is available
        * closes AC relays
        * sets power output to 0

        * Battery: Checks if DC relays are open, then
        * closes DC relays

        * Relays:
        * closes relays

        * Precharge Modules:
        * starts the precharge process, and eventually closes the DC relays.

        If any of the above mentioned actions for a given electrical component has
        already been performed, then this method call effectively skips that
        action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PutElectricalComponentInStandby(self, request, context):
        """Sets the given electrical component into a standby state, from which it can
        take a few minutes to return to an operational state. A transition to an
        operational state can be triggered by calling the
        `StartElectricalComponent` RPC, or the `SetElectricalComponentPowerActive`
        RPC.

        Performs the following sequence actions for the following electrical
        component categories:

        * Inverter: Checks if AC and DC relays are closed, then
        * sets power to 0, and
        * opens AC relays

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given electrical component has
        already been performed, then this method call effectively skips that
        action.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StopElectricalComponent(self, request, context):
        """Stops the electrical component completely, potentially disengaging its
        power electronics controller(s).

        Performs the following sequence actions for the following electrical
        component categories:

        * Inverter:
        * Brings electrical component to the cold-standby state
        * opens DC relays

        * Battery: Checks if the power output is 0, then
        * opens DC relays

        * Relays:
        * opens relays

        * Precharge Modules:
        * opens the DC relays.

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given electrical component has
        already been performed, then this method call effectively skips that
        action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AckElectricalComponentError(self, request, context):
        """Acknowledges any recoverable error reported by the electrical component,
        and brings it back to the stopped or cold-standby state.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MicrogridServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GetMicrogrid': grpc.unary_unary_rpc_method_handler(
                    servicer.GetMicrogrid,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.GetMicrogridResponse.SerializeToString,
            ),
            'ListElectricalComponents': grpc.unary_unary_rpc_method_handler(
                    servicer.ListElectricalComponents,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsResponse.SerializeToString,
            ),
            'ListSensors': grpc.unary_unary_rpc_method_handler(
                    servicer.ListSensors,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorsResponse.SerializeToString,
            ),
            'ListElectricalComponentConnections': grpc.unary_unary_rpc_method_handler(
                    servicer.ListElectricalComponentConnections,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsResponse.SerializeToString,
            ),
            'ReceiveElectricalComponentTelemetryStream': grpc.unary_stream_rpc_method_handler(
                    servicer.ReceiveElectricalComponentTelemetryStream,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamResponse.SerializeToString,
            ),
            'ReceiveSensorTelemetryStream': grpc.unary_stream_rpc_method_handler(
                    servicer.ReceiveSensorTelemetryStream,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamResponse.SerializeToString,
            ),
            'AugmentElectricalComponentBounds': grpc.unary_unary_rpc_method_handler(
                    servicer.AugmentElectricalComponentBounds,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsResponse.SerializeToString,
            ),
            'SetElectricalComponentPower': grpc.unary_stream_rpc_method_handler(
                    servicer.SetElectricalComponentPower,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerResponse.SerializeToString,
            ),
            'StartElectricalComponent': grpc.unary_unary_rpc_method_handler(
                    servicer.StartElectricalComponent,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StartElectricalComponentRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'PutElectricalComponentInStandby': grpc.unary_unary_rpc_method_handler(
                    servicer.PutElectricalComponentInStandby,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.PutElectricalComponentInStandbyRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'StopElectricalComponent': grpc.unary_unary_rpc_method_handler(
                    servicer.StopElectricalComponent,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StopElectricalComponentRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'AckElectricalComponentError': grpc.unary_unary_rpc_method_handler(
                    servicer.AckElectricalComponentError,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AckElectricalComponentErrorRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'frequenz.api.microgrid.v1alpha18.Microgrid', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('frequenz.api.microgrid.v1alpha18.Microgrid', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Microgrid(object):
    """The Frequenz Microgrid API
    """

    @staticmethod
    def GetMicrogrid(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/GetMicrogrid',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.GetMicrogridResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListElectricalComponents(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/ListElectricalComponents',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListSensors(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/ListSensors',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListSensorsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListElectricalComponentConnections(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/ListElectricalComponentConnections',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ListElectricalComponentConnectionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReceiveElectricalComponentTelemetryStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/ReceiveElectricalComponentTelemetryStream',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveElectricalComponentTelemetryStreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReceiveSensorTelemetryStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/ReceiveSensorTelemetryStream',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.ReceiveSensorTelemetryStreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AugmentElectricalComponentBounds(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/AugmentElectricalComponentBounds',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AugmentElectricalComponentBoundsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SetElectricalComponentPower(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/SetElectricalComponentPower',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.SetElectricalComponentPowerResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StartElectricalComponent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/StartElectricalComponent',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StartElectricalComponentRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PutElectricalComponentInStandby(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/PutElectricalComponentInStandby',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.PutElectricalComponentInStandbyRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StopElectricalComponent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/StopElectricalComponent',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.StopElectricalComponentRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AckElectricalComponentError(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/frequenz.api.microgrid.v1alpha18.Microgrid/AckElectricalComponentError',
            frequenz_dot_api_dot_microgrid_dot_v1alpha18_dot_microgrid__pb2.AckElectricalComponentErrorRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
