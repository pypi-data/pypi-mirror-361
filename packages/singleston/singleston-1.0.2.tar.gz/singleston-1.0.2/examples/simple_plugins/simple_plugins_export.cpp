/*
 * AMALGAMATED C/C++ SOURCE FILE
 * Generated by Singleston v1.0.2
 * A powerful source file amalgamator for C/C++ projects
 *
 * Generation Date: 2025-07-09 22:48:21 UTC
 * Author: Adrien Soursou
 * Homepage: https://github.com/ChuOkupai/singleston
 *
 * This file contains the amalgamated source code from multiple
 * source files. It has been automatically generated and should
 * not be edited manually.
 *
 * Original project structure has been flattened into this single
 * file while preserving all functionality and dependencies.
 */

#include <algorithm>
#include <cmath>
#include <iostream>
#include <memory>
#include <vector>

# include <string>

class IPlugin {
public:
	virtual ~IPlugin() = default;

	// Plugin identification
	virtual std::string getName() const = 0;
	virtual std::string getVersion() const = 0;
	virtual std::string getDescription() const = 0;

	// Plugin lifecycle
	virtual bool initialize() = 0;
	virtual void execute() = 0;
	virtual void shutdown() = 0;
};

class PluginRegistry {
public:
	static PluginRegistry& getInstance();

	// Plugin management
	void registerPlugin(std::unique_ptr<IPlugin> plugin);
	void executeAll();
	void shutdownAll();
	void listPlugins() const;
	
	// Get plugin by name
	IPlugin* getPlugin(const std::string& name) const;
	
	// Get all plugins
	const std::vector<std::unique_ptr<IPlugin>>& getPlugins() const;

private:
	PluginRegistry() = default;
	std::vector<std::unique_ptr<IPlugin>> plugins_;
};

// Helper macro for plugin registration
#define REGISTER_PLUGIN(PluginClass) \
	static bool registered_##PluginClass = []() { \
		PluginRegistry::getInstance().registerPlugin(std::make_unique<PluginClass>()); \
		return true; \
	}();


int main() {
	std::cout << "=== Plugin System Demo ===" << std::endl;

	// List all registered plugins
	PluginRegistry& registry = PluginRegistry::getInstance();
	registry.listPlugins();

	// Execute all plugins
	registry.executeAll();

	std::cout << "\n=== Demo: Get specific plugin ===" << std::endl;
	IPlugin* mathPlugin = registry.getPlugin("MathPlugin");
	if (mathPlugin) {
		std::cout << "Found plugin: " << mathPlugin->getName() 
				  << " v" << mathPlugin->getVersion() << std::endl;
	}

	// Shutdown all plugins
	registry.shutdownAll();

	std::cout << "\n=== Plugin System Demo Complete ===" << std::endl;
	return 0;
}


// Singleton implementation
PluginRegistry& PluginRegistry::getInstance() {
	static PluginRegistry instance;
	return instance;
}

void PluginRegistry::registerPlugin(std::unique_ptr<IPlugin> plugin) {
	if (plugin) {
		std::cout << "Registering plugin: " << plugin->getName() << std::endl;
		plugins_.push_back(std::move(plugin));
	}
}

void PluginRegistry::executeAll() {
	std::cout << "\n=== Executing all plugins ===" << std::endl;
	for (auto& plugin : plugins_) {
		if (plugin->initialize()) {
			std::cout << "Executing: " << plugin->getName() << std::endl;
			plugin->execute();
		} else {
			std::cout << "Failed to initialize: " << plugin->getName() << std::endl;
		}
	}
}

void PluginRegistry::shutdownAll() {
	std::cout << "\n=== Shutting down all plugins ===" << std::endl;
	for (auto& plugin : plugins_) {
		std::cout << "Shutting down: " << plugin->getName() << std::endl;
		plugin->shutdown();
	}
}

void PluginRegistry::listPlugins() const {
	std::cout << "\n=== Registered Plugins ===" << std::endl;
	for (const auto& plugin : plugins_) {
		std::cout << "Name: " << plugin->getName() << std::endl;
		std::cout << "Version: " << plugin->getVersion() << std::endl;
		std::cout << "Description: " << plugin->getDescription() << std::endl;
		std::cout << "---" << std::endl;
	}
}

IPlugin* PluginRegistry::getPlugin(const std::string& name) const {
	auto it = std::find_if(plugins_.begin(), plugins_.end(),
		[&name](const std::unique_ptr<IPlugin>& plugin) {
			return plugin->getName() == name;
		});

	return (it != plugins_.end()) ? it->get() : nullptr;
}

const std::vector<std::unique_ptr<IPlugin>>& PluginRegistry::getPlugins() const {
	return plugins_;
}


class MathPlugin : public IPlugin {
public:
	std::string getName() const override {
		return "MathPlugin";
	}

	std::string getVersion() const override {
		return "1.0.0";
	}

	std::string getDescription() const override {
		return "Provides basic mathematical operations and calculations";
	}

	bool initialize() override {
		std::cout << "  [MathPlugin] Initializing math operations..." << std::endl;
		return true;
	}

	void execute() override {
		std::cout << "  [MathPlugin] Performing mathematical calculations:" << std::endl;

		// Demonstrate some math operations
		double a = 15.5, b = 3.2;
		std::cout << "    " << a << " + " << b << " = " << (a + b) << std::endl;
		std::cout << "    " << a << " * " << b << " = " << (a * b) << std::endl;
		std::cout << "    sqrt(" << a << ") = " << std::sqrt(a) << std::endl;
		std::cout << "    sin(Ï€/2) = " << std::sin(M_PI / 2) << std::endl;

		// Calculate factorial of 5
		int n = 5;
		int factorial = 1;
		for (int i = 1; i <= n; ++i) {
			factorial *= i;
		}
		std::cout << "    " << n << "! = " << factorial << std::endl;
	}

	void shutdown() override {
		std::cout << "  [MathPlugin] Cleaning up math operations..." << std::endl;
	}
};

REGISTER_PLUGIN(MathPlugin);


class StringPlugin : public IPlugin {
public:
	std::string getName() const override {
		return "StringPlugin";
	}

	std::string getVersion() const override {
		return "2.1.0";
	}

	std::string getDescription() const override {
		return "Provides string manipulation and text processing utilities";
	}

	bool initialize() override {
		std::cout << "  [StringPlugin] Initializing string operations..." << std::endl;
		return true;
	}

	void execute() override {
		std::cout << "  [StringPlugin] Performing string operations:" << std::endl;

		// Demonstrate string operations
		std::string text = "Hello, Plugin System!";
		std::cout << "    Original: \"" << text << "\"" << std::endl;

		// Convert to uppercase
		std::string upper = text;
		std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
		std::cout << "    Uppercase: \"" << upper << "\"" << std::endl;

		// Reverse string
		std::string reversed = text;
		std::reverse(reversed.begin(), reversed.end());
		std::cout << "    Reversed: \"" << reversed << "\"" << std::endl;

		// Count words
		int wordCount = countWords(text);
		std::cout << "    Word count: " << wordCount << std::endl;

		// Find substring
		std::string search = "Plugin";
		size_t pos = text.find(search);
		if (pos != std::string::npos) {
			std::cout << "    Found \"" << search << "\" at position " << pos << std::endl;
		}

		// Split into words
		std::vector<std::string> words = splitString(text, ' ');
		std::cout << "    Words: ";
		for (size_t i = 0; i < words.size(); ++i) {
			if (i > 0) std::cout << ", ";
			std::cout << "\"" << words[i] << "\"";
		}
		std::cout << std::endl;
	}

	void shutdown() override {
		std::cout << "  [StringPlugin] Cleaning up string operations..." << std::endl;
	}

private:
	int countWords(const std::string& str) {
		if (str.empty()) return 0;

		int count = 0;
		bool inWord = false;

		for (char c : str) {
			if (c != ' ' && c != '\t' && c != '\n') {
				if (!inWord) {
					count++;
					inWord = true;
				}
			} else {
				inWord = false;
			}
		}

		return count;
	}

	std::vector<std::string> splitString(const std::string& str, char delimiter) {
		std::vector<std::string> tokens;
		std::string token;

		for (char c : str) {
			if (c == delimiter) {
				if (!token.empty()) {
					tokens.push_back(token);
					token.clear();
				}
			} else {
				token += c;
			}
		}

		if (!token.empty()) {
			tokens.push_back(token);
		}

		return tokens;
	}
};

REGISTER_PLUGIN(StringPlugin);
