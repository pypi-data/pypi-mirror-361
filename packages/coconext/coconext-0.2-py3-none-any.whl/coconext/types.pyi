from __future__ import annotations

from collections.abc import Iterable, Sequence, Sized
from typing import Generic, Literal, Protocol, Self, TypeVar, overload

class Range(Sequence[int]):
    @overload
    def __init__(self, start: int, stop: int) -> None: ...
    @overload
    def __init__(self, start: int, direction: Literal["to", "downto"], stop: int): ...
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, idx: int, /) -> int: ...
    @overload
    def __getitem__(self, idx: slice, /) -> Range: ...
    def __len__(self) -> int: ...

T_co = TypeVar("T_co", covariant=True)
T = TypeVar("T")

class SizedIterable(Sized, Iterable[T_co], Protocol[T_co]): ...

class ConstArrayLike(Generic[T_co]):
    @property
    def left(self) -> int: ...
    @property
    def range(self) -> int: ...
    @property
    def direction(self) -> int: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, value: object, /) -> bool: ...
    def __iter__(self) -> Iterable[T_co]: ...
    def __reversed__(self) -> Iterable[T_co]: ...
    @overload
    def __getitem__(self, idx: int, /) -> T_co: ...
    @overload
    def __getitem__(self, idx: slice, /) -> ArrayLike[T_co]: ...
    def index(self, value: object, start: int = ..., stop: int = ..., /) -> int: ...
    def count(self, value: object, /) -> int: ...

class ArrayLike(ConstArrayLike[T]):
    @overload
    def __setitem__(self, idx: int, value: T, /) -> None: ...
    @overload
    def __setitem__(self, idx: slice, value: SizedIterable[T], /) -> None: ...

class Array(ArrayLike[T]):
    def __init__(self, value: SizedIterable[T_co], /) -> None: ...

class Logic:
    def __init__(self, literal: int | str | bool | Logic, /) -> None: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __and__(self, other: Self, /) -> Self: ...
    def __rand__(self, other: Self, /) -> Self: ...
    def __or__(self, other: Self, /) -> Self: ...
    def __ror__(self, other: Self, /) -> Self: ...
    def __xor__(self, other: Self, /) -> Self: ...
    def __rxor__(self, other: Self, /) -> Self: ...
    def __not__(self) -> Self: ...

class Bit(Logic): ...

LogicT_co = TypeVar("LogicT_co", covariant=True, bound=Logic)
LogicT = TypeVar("LogicT", bound=Logic)

class ConstLogicArrayLike(ConstArrayLike[LogicT_co]):
    def __and__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __rand__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __or__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __ror__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __xor__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __rxor__(
        self, other: ConstLogicArrayLike[LogicT_co], /
    ) -> LogicArrayLike[LogicT_co]: ...
    def __not__(self) -> LogicArrayLike[LogicT_co]: ...

class LogicArrayLike(ConstLogicArrayLike[LogicT]): ...
class LogicArray: ...  # implements LogicArray[Logic]
class BitArray: ...  # implements LogicArray[Bit]
class Unsigned: ...  # implements LogicArray[Bit], Arithmetic
class Signed: ...  # implements LogicArray[Bit], Arithmetic
class Ufixed: ...  # implements LogicArray[Bit], Arithmetic
class Sfixed: ...  # implements LogicArray[Bit], Arithmetic
class Float: ...  # implements LogicArray[Bit], Arithmetic
