# DO NOT EDIT THIS FILE MANUALLY - it will be overwritten.
# Generated by: erdo gen-client
"""
Auto-generated type definitions from shared Go types.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID


# ParameterType (from ParameterType in Go)
class ParameterType(str, Enum):
    """Enum for ParameterType values"""

    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    BOOL = "bool"
    JSON = "json"


# ParameterHydrationBehaviour (from ParameterHydrationBehaviour in Go)
class ParameterHydrationBehaviour(str, Enum):
    """Enum for ParameterHydrationBehaviour values"""

    HYDRATE = "hydrate"
    RAW = "raw"
    NONE = "none"


# OutputVisibility (from OutputVisibility in Go)
class OutputVisibility(str, Enum):
    """Enum for OutputVisibility values"""

    VISIBLE = "visible"
    HIDDEN = "hidden"


# OutputContentType (from OutputContentType in Go)
class OutputContentType(str, Enum):
    """Enum for OutputContentType values"""

    TEXT = "text"
    JSON = "json"
    HTML = "html"


# HandlerType (from HandlerType in Go)
class HandlerType(str, Enum):
    """Enum for HandlerType values"""

    INTERMEDIATE = "intermediate"
    FINAL = "final"


# ExecutionModeType (from ExecutionModeType in Go)
class ExecutionModeType(str, Enum):
    """Enum for ExecutionModeType values"""

    ALL = "all"
    ITERATE_OVER = "iterate_over"
    ALL_BACKGROUND = "all_background"


# Model (from Model in Go)
class LlmModel(str, Enum):
    """Enum for LlmModel values"""

    CLAUDE_3_7_SONNET_20250219 = "claude-3-7-sonnet-20250219"
    CLAUDE_SONNET_4_20250514 = "claude-sonnet-4-20250514"
    CLAUDE_3_5_HAIKU_20241022 = "claude-3-5-haiku-20241022"
    GPT_4O = "gpt-4o"
    GPT_4O_MINI = "gpt-4o-mini"
    GPT_4_1 = "gpt-4.1"
    GPT_4_1_MINI = "gpt-4.1-mini"
    GPT_4_1_NANO = "gpt-4.1-nano"


# OutputBehaviorType (from OutputBehaviorType in Go)
class OutputBehaviorType(str, Enum):
    """Enum for OutputBehaviorType values"""

    STEP_ONLY = "step_only"
    MERGE = "merge"
    OVERWRITE = "overwrite"


# CredentialSource (from CredentialSource in Go)
class CredentialSource(str, Enum):
    """Enum for CredentialSource values"""

    INTEGRATION_CREDENTIALS = "integration_credentials"
    CONFIG_PROVIDER_CREDENTIALS = "config_provider_credentials"
    SEGMENT = "segment"
    DATASET_PARAMETERS = "dataset_parameters"


# SensitivityLevel (from SensitivityLevel in Go)
class SensitivityLevel(str, Enum):
    """Enum for SensitivityLevel values"""

    NEVER_VIEWABLE = "never_viewable"
    OWNER_VIEWABLE = "owner_viewable"
    ADMIN_VIEWABLE = "admin_viewable"
    EDIT_VIEWABLE = "edit_viewable"
    ALL_VIEWABLE = "all_viewable"


# JSONSchemaType (from JSONSchemaType in Go)
class JSONSchemaType(str, Enum):
    """Enum for JSONSchemaType values"""

    STRING = "string"
    NUMBER = "number"
    BOOLEAN = "boolean"
    OBJECT = "object"
    ARRAY = "array"


# InvocationEventType (from InvocationEventType in Go)
class InvocationEventType(str, Enum):
    """Enum for InvocationEventType values"""

    BOT_STARTED = "bot started"
    MESSAGE_CREATED = "message created"
    MESSAGE_FINISHED = "message finished"
    MESSAGE_CONTENT_DELTA = "message content delta"
    CREATE_MESSAGE_CONTENT = "create message content"
    MESSAGE_CONTENT_RESULT = "message content result"
    STEP_OUTPUT_CREATED = "step output created"
    STEP_OUTPUT_FINISHED = "step output finished"
    STEP_OUTPUT_CONTENT_DELTA = "step output content delta"
    CREATE_STEP_OUTPUT_CONTENT = "create step output content"
    STEP_OUTPUT_CONTENT_RESULT = "step output content result"
    STEP_STARTED = "step started"
    STEP_RESULT = "step result"
    RESULT_HANDLER_STARTED = "result handler started"
    REQUIRES_INFO = "requires info"
    ERROR = "error"
    STATUS = "status"
    RESULT = "result"
    DATASET_CREATED = "dataset created"


# Status (from Status in Go)
class Status(str, Enum):
    """Enum for Status values"""

    SKIPPED = "skipped"
    SUCCESS = "success"
    BREAK = "break"
    ERROR = "error"
    REQUIRES_INFO = "requires info"
    GO_TO_STEP = "go to step"


# Error (from Error in Go)
class Error(str, Enum):
    """Enum for Error values"""

    ACTION_NOT_FOUND = "action not found"
    INTERNAL_ERROR = "internal error"
    INFO_NEEDED = "info needed"
    TERMINATED = "terminated"
    BAD_REQUEST = "bad request"


# DatasetType (from DatasetType in Go)
class DatasetType(str, Enum):
    """Enum for DatasetType values"""

    FILE = "file"
    DATABASE = "database"
    INTEGRATION = "integration"


# IntegrationType (from IntegrationType in Go)
class IntegrationType(str, Enum):
    """Enum for IntegrationType values"""

    API = "api"
    DATABASE = "database"
    FILE = "file"


# AuthType (from AuthType in Go)
class AuthType(str, Enum):
    """Enum for AuthType values"""

    OAUTH2 = "oauth2"
    API_KEY = "api_key"
    DATABASE = "database"
    BASIC_AUTH = "basic_auth"


# IntegrationStatus (from IntegrationStatus in Go)
class IntegrationStatus(str, Enum):
    """Enum for IntegrationStatus values"""

    ACTIVE = "active"
    INACTIVE = "inactive"
    BETA = "beta"
    COMING_SOON = "coming_soon"
    ERROR = "error"
    NEEDS_REAUTH = "needs_reauth"


# SegmentSelectionType (from SegmentSelectionType in Go)
class SegmentSelectionType(str, Enum):
    """Enum for SegmentSelectionType values"""

    SINGLE = "single"
    MULTIPLE = "multiple"
    REQUIRED = "required"
    OPTIONAL = "optional"


# ExpiryType (from ExpiryType in Go)
class ExpiryType(str, Enum):
    """Enum for ExpiryType values"""

    OAUTH_DEFAULT = "oauth_default"
    CONSTANT = "constant"
    OAUTH_FIELD = "oauth_field"


# ResourceType (from ResourceType in Go)
class ResourceType(str, Enum):
    """Enum for ResourceType values"""

    TABLE = "table"
    ENDPOINT = "endpoint"
    DOCUMENT = "document"
    PARTIAL_DOCUMENT = "partial_document"
    ENTITY = "entity"
    SHEET = "sheet"


# ResourceState (from ResourceState in Go)
class ResourceState(str, Enum):
    """Enum for ResourceState values"""

    ACTIVE = "active"
    REMOVED = "removed"
    DELETED = "deleted"


# ResourceRelationshipType (from ResourceRelationshipType in Go)
class ResourceRelationshipType(str, Enum):
    """Enum for ResourceRelationshipType values"""

    ACCEPTS = "accepts"
    RETURNS = "returns"
    LINKS_TO = "links_to"


# ResourceAttachType (from ResourceAttachType in Go)
class ResourceAttachType(str, Enum):
    """Enum for ResourceAttachType values"""

    ALWAYS = "always"
    SEARCHABLE = "searchable"


# Strongly-typed classes from Go structs
@dataclass
class Bot:
    """Bot matching Go backend structure."""

    id: str
    name: str
    description: str
    code: str
    file_path: str
    organization_id: str
    visibility: str
    source: str
    persona: Optional[str] = None
    running_message: Optional[str] = None
    finished_message: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["name"] = self.name
        result["description"] = self.description
        result["code"] = self.code
        result["file_path"] = self.file_path
        if self.persona is not None:
            result["persona"] = self.persona
        if self.running_message is not None:
            result["running_message"] = self.running_message
        if self.finished_message is not None:
            result["finished_message"] = self.finished_message
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        result["organization_id"] = self.organization_id
        result["visibility"] = self.visibility
        result["source"] = self.source
        return result


@dataclass
class ParameterDefinition:
    """ParameterDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    is_required: bool
    id: Optional[UUID] = None
    bot_id: Optional[UUID] = None
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    value_sources: List["ParameterValueSource"] = None
    interpreters: List["ParameterInterpreter"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.bot_id is not None:
            result["bot_id"] = self.bot_id
        result["name"] = self.name
        result["key"] = self.key
        if self.description is not None:
            result["description"] = self.description
        result["type"] = self.type
        result["is_required"] = self.is_required
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        if self.value_sources is not None:
            result["value_sources"] = self.value_sources
        if self.interpreters is not None:
            result["interpreters"] = self.interpreters
        return result


@dataclass
class ParameterValueSource:
    """ParameterValueSource matching Go backend structure."""

    type: Any
    parameters: Any
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    on_populate: List["ParameterValueSourceHandler"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = self.parameter_definition_id
        result["type"] = self.type
        result["parameters"] = self.parameters
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        if self.on_populate is not None:
            result["on_populate"] = self.on_populate
        return result


@dataclass
class ParameterValueSourceHandler:
    """ParameterValueSourceHandler matching Go backend structure."""

    action_type: str
    parameters: Any
    execution_mode: str
    id: Optional[UUID] = None
    parameter_value_source_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_value_source_id is not None:
            result["parameter_value_source_id"] = self.parameter_value_source_id
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        result["execution_mode"] = self.execution_mode
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class ParameterInterpreter:
    """ParameterInterpreter matching Go backend structure."""

    action_type: str
    parameters: Any
    interpreter_order: int
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = self.parameter_definition_id
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        result["interpreter_order"] = self.interpreter_order
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class AgentDiscovery:
    """AgentDiscovery matching Go backend structure."""

    bot: "Bot"
    parameter_definitions: List["ParameterDefinition"]
    steps: List["StepWithHandlers"]
    file_path: str
    source_code: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["bot"] = self.bot
        result["parameter_definitions"] = self.parameter_definitions
        result["steps"] = self.steps
        result["file_path"] = self.file_path
        result["source_code"] = self.source_code
        return result


@dataclass
class ExecutionModeConfig:
    """ExecutionMode matching Go backend structure."""

    mode: str
    data: Any
    if_condition: Optional["ConditionDefinition"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["mode"] = self.mode
        result["data"] = self.data
        if self.if_condition is not None:
            result["if_condition"] = self.if_condition
        return result


@dataclass
class UpsertBotRequest:
    """UpsertBotRequest matching Go backend structure."""

    bot: "Bot"
    steps: List["APIStepWithHandlers"]
    source: str
    parameter_definitions: List["APIParameterDefinition"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["bot"] = self.bot
        result["steps"] = self.steps
        result["source"] = self.source
        if self.parameter_definitions is not None:
            result["parameter_definitions"] = self.parameter_definitions
        return result


@dataclass
class BotsResponse:
    """BotsResponse matching Go backend structure."""

    bots: List["Bot"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["bots"] = self.bots
        return result


@dataclass
class StepsResponse:
    """StepsResponse matching Go backend structure."""

    steps: List["APIStep"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["steps"] = self.steps
        return result


@dataclass
class ServiceDefinition:
    """ServiceDefinition matching Go backend structure."""

    name: str
    description: str
    actions: List["ActionDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["description"] = self.description
        result["actions"] = self.actions
        return result


@dataclass
class ActionDefinition:
    """ActionDefinition matching Go backend structure."""

    name: str
    description: str
    parameters: List["ParameterDefinition"]
    result_schema: Optional["ResultSchema"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["description"] = self.description
        result["parameters"] = self.parameters
        if self.result_schema is not None:
            result["result_schema"] = self.result_schema
        return result


@dataclass
class ResultSchema:
    """ResultSchema matching Go backend structure."""

    properties: Any
    description: str = None
    required_fields: List[str] = None
    optional_fields: List[str] = None
    examples: List[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.description is not None:
            result["description"] = self.description
        if self.required_fields is not None:
            result["required_fields"] = self.required_fields
        if self.optional_fields is not None:
            result["optional_fields"] = self.optional_fields
        result["properties"] = self.properties
        if self.examples is not None:
            result["examples"] = self.examples
        return result


@dataclass
class PropertySchema:
    """PropertySchema matching Go backend structure."""

    type: Any
    description: str = None
    items: Optional["PropertySchema"] = None
    properties: Any = None
    example: Any = None
    enum: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.description is not None:
            result["description"] = self.description
        if self.items is not None:
            result["items"] = self.items
        if self.properties is not None:
            result["properties"] = self.properties
        if self.example is not None:
            result["example"] = self.example
        if self.enum is not None:
            result["enum"] = self.enum
        return result


@dataclass
class IntegrationSchema:
    """IntegrationSchema matching Go backend structure."""

    key: str
    name: str
    description: str
    type: str
    auth_types: List[str]
    credential_schema: Any
    available_scopes: List[str]
    documentation_url: str
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["key"] = self.key
        result["name"] = self.name
        result["description"] = self.description
        result["type"] = self.type
        result["auth_types"] = self.auth_types
        result["credential_schema"] = self.credential_schema
        result["available_scopes"] = self.available_scopes
        result["documentation_url"] = self.documentation_url
        if self.codegen_details is not None:
            result["codegen_details"] = self.codegen_details
        if self.analysis_details is not None:
            result["analysis_details"] = self.analysis_details
        return result


@dataclass
class CodegenDetails:
    """CodegenDetails matching Go backend structure."""

    code: str
    imports: List[str]
    hint: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["code"] = self.code
        result["imports"] = self.imports
        if self.hint is not None:
            result["hint"] = self.hint
        return result


@dataclass
class AnalysisDetails:
    """AnalysisDetails matching Go backend structure."""

    imports: List[str]
    code: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["imports"] = self.imports
        result["code"] = self.code
        return result


@dataclass
class CredentialSchema:
    """CredentialSchema matching Go backend structure."""

    type: str
    description: str
    required: bool
    source: Any
    sensitivity: Any = None
    jq: str = None
    header: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        result["description"] = self.description
        result["required"] = self.required
        result["source"] = self.source
        if self.sensitivity is not None:
            result["sensitivity"] = self.sensitivity
        if self.jq is not None:
            result["jq"] = self.jq
        if self.header is not None:
            result["header"] = self.header
        return result


@dataclass
class ExportActionsResponse:
    """ExportActionsResponse matching Go backend structure."""

    services: Any
    integrations: Any

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["services"] = self.services
        result["integrations"] = self.integrations
        return result


@dataclass
class ConditionDefinition:
    """ConditionDefinition matching Go backend structure."""

    type: str
    conditions: List["ConditionDefinition"] = None
    leaf: Any = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.conditions is not None:
            result["conditions"] = self.conditions
        if self.leaf is not None:
            result["leaf"] = self.leaf
        return result


@dataclass
class TempCondition:
    """TempCondition matching Go backend structure."""

    type: str
    conditions: Any = None
    leaf: Any = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.conditions is not None:
            result["conditions"] = self.conditions
        if self.leaf is not None:
            result["leaf"] = self.leaf
        return result


@dataclass
class StepWithHandlers:
    """StepWithHandlers matching Go backend structure."""

    step: "Step"
    result_handlers: List["ResultHandler"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["step"] = self.step
        result["result_handlers"] = self.result_handlers
        return result


@dataclass
class ResultHandler:
    """ResultHandler matching Go backend structure."""

    type: str
    if_conditions: "ConditionDefinition"
    result_handler_order: int
    output_content_type: str
    steps: List["StepWithHandlers"]
    history_content_type: Optional[str] = None
    ui_content_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        result["if_conditions"] = self.if_conditions
        result["result_handler_order"] = self.result_handler_order
        result["output_content_type"] = self.output_content_type
        if self.history_content_type is not None:
            result["history_content_type"] = self.history_content_type
        if self.ui_content_type is not None:
            result["ui_content_type"] = self.ui_content_type
        result["steps"] = self.steps
        return result


@dataclass
class JSONSchemaProperty:
    """JSONSchemaProperty matching Go backend structure."""

    type: Any
    description: str = None
    items: Optional["JSONSchemaProperty"] = None
    enum: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.description is not None:
            result["description"] = self.description
        if self.items is not None:
            result["items"] = self.items
        if self.enum is not None:
            result["enum"] = self.enum
        return result


@dataclass
class JSONSchema:
    """JSONSchema matching Go backend structure."""

    type: Any
    properties: Any = None
    required: List[str] = None
    items: Optional["JSONSchemaProperty"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.properties is not None:
            result["properties"] = self.properties
        if self.required is not None:
            result["required"] = self.required
        if self.items is not None:
            result["items"] = self.items
        return result


@dataclass
class Tool:
    """Tool matching Go backend structure."""

    name: str
    description: str
    input_schema: "JSONSchema"
    action_type: str
    parameters: Any
    bot_output_visibility: str = None
    history_content_type: str = None
    ui_content_type: str = None
    as_root: bool = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["description"] = self.description
        result["input_schema"] = self.input_schema
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        if self.bot_output_visibility is not None:
            result["bot_output_visibility"] = self.bot_output_visibility
        if self.history_content_type is not None:
            result["history_content_type"] = self.history_content_type
        if self.ui_content_type is not None:
            result["ui_content_type"] = self.ui_content_type
        if self.as_root is not None:
            result["as_root"] = self.as_root
        return result


@dataclass
class Message:
    """Message matching Go backend structure."""

    id: str
    role: str
    content: str
    created_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["role"] = self.role
        result["content"] = self.content
        if self.created_at is not None:
            result["created_at"] = self.created_at
        return result


@dataclass
class SystemParameters:
    """SystemParameters matching Go backend structure."""

    current_date: str
    messages: List["Message"]
    session_messages: List["Message"]
    current_message: str
    thread_id: UUID
    organization_id: str
    invocation_id: UUID

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["current_date"] = self.current_date
        result["messages"] = self.messages
        result["session_messages"] = self.session_messages
        result["current_message"] = self.current_message
        result["thread_id"] = self.thread_id
        result["organization_id"] = self.organization_id
        result["invocation_id"] = self.invocation_id
        return result


@dataclass
class Result:
    """Result matching Go backend structure."""

    status: Any
    parameters: Optional[Any] = None
    output: Optional[Any] = None
    message: Optional[str] = None
    error: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["status"] = self.status
        if self.parameters is not None:
            result["parameters"] = self.parameters
        if self.output is not None:
            result["output"] = self.output
        if self.message is not None:
            result["message"] = self.message
        if self.error is not None:
            result["error"] = self.error
        return result


@dataclass
class APIStep:
    """APIStep matching Go backend structure."""

    id: str
    bot_id: str
    action_type: str
    parameters: Any
    step_order: int
    output_content_type: str
    user_output_visibility: str
    bot_output_visibility: str
    execution_mode: "APIExecutionMode"
    output_behaviour: Any
    output_channels: List[str]
    parameter_hydration_behaviour: Any
    depends_on: Optional[List[str]] = None
    key: Optional[str] = None
    running_message: Optional[str] = None
    finished_message: Optional[str] = None
    history_content_type: Optional[str] = None
    ui_content_type: Optional[str] = None
    result_handler_id: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["bot_id"] = self.bot_id
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        if self.depends_on is not None:
            result["depends_on"] = self.depends_on
        if self.key is not None:
            result["key"] = self.key
        result["step_order"] = self.step_order
        result["output_content_type"] = self.output_content_type
        result["user_output_visibility"] = self.user_output_visibility
        result["bot_output_visibility"] = self.bot_output_visibility
        result["execution_mode"] = self.execution_mode
        result["output_behaviour"] = self.output_behaviour
        result["output_channels"] = self.output_channels
        if self.running_message is not None:
            result["running_message"] = self.running_message
        if self.finished_message is not None:
            result["finished_message"] = self.finished_message
        if self.history_content_type is not None:
            result["history_content_type"] = self.history_content_type
        if self.ui_content_type is not None:
            result["ui_content_type"] = self.ui_content_type
        result["parameter_hydration_behaviour"] = self.parameter_hydration_behaviour
        if self.result_handler_id is not None:
            result["result_handler_id"] = self.result_handler_id
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class APIParameterValueSource:
    """APIParameterValueSource matching Go backend structure."""

    type: Any
    parameters: Any
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    on_populate: List["APIParameterValueSourceHandler"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = self.parameter_definition_id
        result["type"] = self.type
        result["parameters"] = self.parameters
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        if self.on_populate is not None:
            result["on_populate"] = self.on_populate
        return result


@dataclass
class APIParameterValueSourceHandler:
    """APIParameterValueSourceHandler matching Go backend structure."""

    action_type: str
    parameters: Any
    execution_mode: "APIExecutionMode"
    id: Optional[UUID] = None
    parameter_value_source_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_value_source_id is not None:
            result["parameter_value_source_id"] = self.parameter_value_source_id
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        result["execution_mode"] = self.execution_mode
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class APIParameterInterpreter:
    """APIParameterInterpreter matching Go backend structure."""

    action_type: str
    parameters: Any
    interpreter_order: int
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = self.parameter_definition_id
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        result["interpreter_order"] = self.interpreter_order
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class APIExecutionMode:
    """APIExecutionMode matching Go backend structure."""

    mode: str
    data: Any
    if_condition: Optional["APIConditionDefinition"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["mode"] = self.mode
        result["data"] = self.data
        if self.if_condition is not None:
            result["if_condition"] = self.if_condition
        return result


@dataclass
class APIConditionDefinition:
    """APIConditionDefinition matching Go backend structure."""

    type: str
    conditions: List["APIConditionDefinition"] = None
    leaf: Any = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.conditions is not None:
            result["conditions"] = self.conditions
        if self.leaf is not None:
            result["leaf"] = self.leaf
        return result


@dataclass
class APITool:
    """APITool matching Go backend structure."""

    name: str
    description: str
    input_schema: Any
    action_type: str
    parameters: Any
    bot_output_visibility: str = None
    history_content_type: str = None
    ui_content_type: str = None
    as_root: bool = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["description"] = self.description
        result["input_schema"] = self.input_schema
        result["action_type"] = self.action_type
        result["parameters"] = self.parameters
        if self.bot_output_visibility is not None:
            result["bot_output_visibility"] = self.bot_output_visibility
        if self.history_content_type is not None:
            result["history_content_type"] = self.history_content_type
        if self.ui_content_type is not None:
            result["ui_content_type"] = self.ui_content_type
        if self.as_root is not None:
            result["as_root"] = self.as_root
        return result


@dataclass
class APIResultHandler:
    """APIResultHandler matching Go backend structure."""

    type: str
    if_conditions: "APIConditionDefinition"
    result_handler_order: int
    output_content_type: str
    steps: List["APIStepWithHandlers"]
    history_content_type: Optional[str] = None
    ui_content_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        result["if_conditions"] = self.if_conditions
        result["result_handler_order"] = self.result_handler_order
        result["output_content_type"] = self.output_content_type
        if self.history_content_type is not None:
            result["history_content_type"] = self.history_content_type
        if self.ui_content_type is not None:
            result["ui_content_type"] = self.ui_content_type
        result["steps"] = self.steps
        return result


@dataclass
class APIParameterDefinition:
    """APIParameterDefinition matching Go backend structure."""

    name: str
    key: str
    type: str
    is_required: bool
    id: Optional[UUID] = None
    bot_id: Optional[UUID] = None
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id
        if self.bot_id is not None:
            result["bot_id"] = self.bot_id
        result["name"] = self.name
        result["key"] = self.key
        if self.description is not None:
            result["description"] = self.description
        result["type"] = self.type
        result["is_required"] = self.is_required
        if self.created_at is not None:
            result["created_at"] = self.created_at
        if self.updated_at is not None:
            result["updated_at"] = self.updated_at
        return result


@dataclass
class APIStepWithHandlers:
    """APIStepWithHandlers matching Go backend structure."""

    step: "APIStep"
    result_handlers: List["APIResultHandler"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["step"] = self.step
        result["result_handlers"] = self.result_handlers
        return result


@dataclass
class Dataset:
    """Dataset matching Go backend structure."""

    id: UUID
    type: DatasetType
    key: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    analysis_summary: Optional[str] = None
    last_analyzed: Optional[datetime] = None
    instructions: Optional[str] = None
    file: Optional[str] = None
    file_type: Optional[str] = None
    filename: Optional[str] = None
    url: Optional[str] = None
    integration_id: Optional[UUID] = None
    integration_config_id: Optional[UUID] = None
    integration_config: Optional[IntegrationConfig] = None
    encrypted_integration_credentials: Optional[Any] = None
    credential_schema: Optional[Any] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    available_scopes: Optional[List[str]] = None
    parameters: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["type"] = self.type
        if self.key is not None:
            result["key"] = self.key
        if self.name is not None:
            result["name"] = self.name
        if self.description is not None:
            result["description"] = self.description
        if self.analysis_summary is not None:
            result["analysis_summary"] = self.analysis_summary
        if self.last_analyzed is not None:
            result["last_analyzed"] = self.last_analyzed
        if self.instructions is not None:
            result["instructions"] = self.instructions
        if self.file is not None:
            result["file"] = self.file
        if self.file_type is not None:
            result["file_type"] = self.file_type
        if self.filename is not None:
            result["filename"] = self.filename
        if self.url is not None:
            result["url"] = self.url
        if self.integration_id is not None:
            result["integration_id"] = self.integration_id
        if self.integration_config_id is not None:
            result["integration_config_id"] = self.integration_config_id
        if self.integration_config is not None:
            result["integration_config"] = self.integration_config
        if self.encrypted_integration_credentials is not None:
            result["encrypted_integration_credentials"] = (
                self.encrypted_integration_credentials
            )
        if self.credential_schema is not None:
            result["credential_schema"] = self.credential_schema
        if self.codegen_details is not None:
            result["codegen_details"] = self.codegen_details
        if self.analysis_details is not None:
            result["analysis_details"] = self.analysis_details
        if self.available_scopes is not None:
            result["available_scopes"] = self.available_scopes
        if self.parameters is not None:
            result["parameters"] = self.parameters
        return result


@dataclass
class BotResource:
    """BotResource matching Go backend structure."""

    id: int
    created_by: str
    extra: Any
    dataset: Optional[Dataset] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        if self.dataset is not None:
            result["dataset"] = self.dataset
        result["created_by"] = self.created_by
        result["extra"] = self.extra
        return result


@dataclass
class UIConfigIcon:
    """UIConfigIcon matching Go backend structure."""

    set: str
    name: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["set"] = self.set
        result["name"] = self.name
        return result


@dataclass
class UIConfig:
    """UIConfig matching Go backend structure."""

    brand_logo_icon: "UIConfigIcon"
    brand_color: str
    button_style: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["brand_logo_icon"] = self.brand_logo_icon
        result["brand_color"] = self.brand_color
        result["button_style"] = self.button_style
        return result


@dataclass
class ErrorHandlingConfig:
    """ErrorHandlingConfig matching Go backend structure."""

    ignore_errors: List[str] = None
    error_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.ignore_errors is not None:
            result["ignore_errors"] = self.ignore_errors
        if self.error_path is not None:
            result["error_path"] = self.error_path
        return result


@dataclass
class SegmentLevel:
    """SegmentLevel matching Go backend structure."""

    name: str
    type: str
    selectable: bool
    url_template: str = None
    method: str = None
    body: str = None
    id_path: str = None
    id_regex: str = None
    name_path: str = None
    parent_key: str = None
    required_credentials: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["type"] = self.type
        result["selectable"] = self.selectable
        if self.url_template is not None:
            result["url_template"] = self.url_template
        if self.method is not None:
            result["method"] = self.method
        if self.body is not None:
            result["body"] = self.body
        if self.id_path is not None:
            result["id_path"] = self.id_path
        if self.id_regex is not None:
            result["id_regex"] = self.id_regex
        if self.name_path is not None:
            result["name_path"] = self.name_path
        if self.parent_key is not None:
            result["parent_key"] = self.parent_key
        if self.required_credentials is not None:
            result["required_credentials"] = self.required_credentials
        return result


@dataclass
class SegmentConfig:
    """SegmentConfig matching Go backend structure."""

    selection_type: Any
    description: str
    hierarchical: bool
    levels: List["SegmentLevel"]
    min_selections: Optional[int] = None
    max_selections: Optional[int] = None
    base_url: str = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["selection_type"] = self.selection_type
        if self.min_selections is not None:
            result["min_selections"] = self.min_selections
        if self.max_selections is not None:
            result["max_selections"] = self.max_selections
        result["description"] = self.description
        result["hierarchical"] = self.hierarchical
        if self.base_url is not None:
            result["base_url"] = self.base_url
        result["levels"] = self.levels
        if self.error_handling is not None:
            result["error_handling"] = self.error_handling
        return result


@dataclass
class ResourceTypeConfig:
    """ResourceTypeConfig matching Go backend structure."""

    type: str
    url_template: str
    id_path: str
    name_path: str
    method: str = None
    body: str = None
    description_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        result["url_template"] = self.url_template
        if self.method is not None:
            result["method"] = self.method
        if self.body is not None:
            result["body"] = self.body
        result["id_path"] = self.id_path
        result["name_path"] = self.name_path
        if self.description_path is not None:
            result["description_path"] = self.description_path
        return result


@dataclass
class DatasetResourceDiscoveryConfig:
    """DatasetResourceDiscoveryConfig matching Go backend structure."""

    min_resources_required: int
    table_query: str = None
    relationship_query: str = None
    index_query: str = None
    constraint_query: str = None
    statistics_query: str = None
    size_query: str = None
    base_url: str = None
    resource_types: List["ResourceTypeConfig"] = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["min_resources_required"] = self.min_resources_required
        if self.table_query is not None:
            result["table_query"] = self.table_query
        if self.relationship_query is not None:
            result["relationship_query"] = self.relationship_query
        if self.index_query is not None:
            result["index_query"] = self.index_query
        if self.constraint_query is not None:
            result["constraint_query"] = self.constraint_query
        if self.statistics_query is not None:
            result["statistics_query"] = self.statistics_query
        if self.size_query is not None:
            result["size_query"] = self.size_query
        if self.base_url is not None:
            result["base_url"] = self.base_url
        if self.resource_types is not None:
            result["resource_types"] = self.resource_types
        if self.error_handling is not None:
            result["error_handling"] = self.error_handling
        return result


@dataclass
class ExpiryConfig:
    """ExpiryConfig matching Go backend structure."""

    type: Any
    duration: Any = None
    field_name: str = None
    refresh_token_duration: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.duration is not None:
            result["duration"] = self.duration
        if self.field_name is not None:
            result["field_name"] = self.field_name
        if self.refresh_token_duration is not None:
            result["refresh_token_duration"] = self.refresh_token_duration
        return result


@dataclass
class SegmentOption:
    """SegmentOption matching Go backend structure."""

    id: str
    name: str
    type: str
    metadata: Any
    children: List["SegmentOption"]
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["name"] = self.name
        result["type"] = self.type
        if self.parent_id is not None:
            result["parent_id"] = self.parent_id
        result["metadata"] = self.metadata
        result["children"] = self.children
        return result


@dataclass
class IntegrationDefinition:
    """IntegrationDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    auth_types: List[Any]
    status: Any
    description: Optional[str] = None
    provider_name: Optional[str] = None
    documentation_url: Optional[str] = None
    openapi_documentation_url: Optional[str] = None
    llms_txt_url: Optional[str] = None
    healthcheck_url: Optional[str] = None
    auth_url: Optional[str] = None
    token_url: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    available_scopes: List[str] = None
    optional_scopes: List[str] = None
    scope_separator: Optional[str] = None
    api_version: Optional[str] = None
    api_version_description: Optional[str] = None
    credential_schema: Any = None
    ui_config: Optional["UIConfig"] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    segment_config: Optional["SegmentConfig"] = None
    dataset_resource_discovery_config: Optional["DatasetResourceDiscoveryConfig"] = None
    expiry_config: Optional["ExpiryConfig"] = None
    provider_credentials: Any = None
    default_resource_attach_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["key"] = self.key
        result["type"] = self.type
        result["auth_types"] = self.auth_types
        result["status"] = self.status
        if self.description is not None:
            result["description"] = self.description
        if self.provider_name is not None:
            result["provider_name"] = self.provider_name
        if self.documentation_url is not None:
            result["documentation_url"] = self.documentation_url
        if self.openapi_documentation_url is not None:
            result["openapi_documentation_url"] = self.openapi_documentation_url
        if self.llms_txt_url is not None:
            result["llms_txt_url"] = self.llms_txt_url
        if self.healthcheck_url is not None:
            result["healthcheck_url"] = self.healthcheck_url
        if self.auth_url is not None:
            result["auth_url"] = self.auth_url
        if self.token_url is not None:
            result["token_url"] = self.token_url
        if self.client_id is not None:
            result["client_id"] = self.client_id
        if self.client_secret is not None:
            result["client_secret"] = self.client_secret
        if self.available_scopes is not None:
            result["available_scopes"] = self.available_scopes
        if self.optional_scopes is not None:
            result["optional_scopes"] = self.optional_scopes
        if self.scope_separator is not None:
            result["scope_separator"] = self.scope_separator
        if self.api_version is not None:
            result["api_version"] = self.api_version
        if self.api_version_description is not None:
            result["api_version_description"] = self.api_version_description
        if self.credential_schema is not None:
            result["credential_schema"] = self.credential_schema
        if self.ui_config is not None:
            result["ui_config"] = self.ui_config
        if self.codegen_details is not None:
            result["codegen_details"] = self.codegen_details
        if self.analysis_details is not None:
            result["analysis_details"] = self.analysis_details
        if self.segment_config is not None:
            result["segment_config"] = self.segment_config
        if self.dataset_resource_discovery_config is not None:
            result["dataset_resource_discovery_config"] = (
                self.dataset_resource_discovery_config
            )
        if self.expiry_config is not None:
            result["expiry_config"] = self.expiry_config
        if self.provider_credentials is not None:
            result["provider_credentials"] = self.provider_credentials
        if self.default_resource_attach_type is not None:
            result["default_resource_attach_type"] = self.default_resource_attach_type
        return result


@dataclass
class IntegrationConfig:
    """IntegrationConfig matching Go backend structure."""

    definition: "IntegrationDefinition"
    source: str
    file_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["definition"] = self.definition
        result["source"] = self.source
        if self.file_path is not None:
            result["file_path"] = self.file_path
        return result


@dataclass
class PythonIntegrationInstance:
    """PythonIntegrationInstance matching Go backend structure."""

    config: IntegrationConfig
    credentials: Any
    methods: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = self.config
        result["credentials"] = self.credentials
        if self.methods is not None:
            result["methods"] = self.methods
        return result


@dataclass
class IntegrationDiscovery:
    """IntegrationDiscovery matching Go backend structure."""

    config: IntegrationConfig
    file_path: str
    source_code: str
    instance: Optional["PythonIntegrationInstance"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = self.config
        if self.instance is not None:
            result["instance"] = self.instance
        result["file_path"] = self.file_path
        result["source_code"] = self.source_code
        return result


@dataclass
class UpsertIntegrationRequest:
    """UpsertIntegrationRequest matching Go backend structure."""

    integration: "IntegrationDefinition"
    source: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration"] = self.integration
        result["source"] = self.source
        return result


@dataclass
class UpsertIntegrationResponse:
    """UpsertIntegrationResponse matching Go backend structure."""

    integration_id: str
    status: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration_id"] = self.integration_id
        result["status"] = self.status
        return result


@dataclass
class ListIntegrationsResponse:
    """ListIntegrationsResponse matching Go backend structure."""

    integrations: List["IntegrationDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = self.integrations
        return result


@dataclass
class ExportIntegrationsResponse:
    """ExportIntegrationsResponse matching Go backend structure."""

    integrations: Any

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = self.integrations
        return result


@dataclass
class Memory:
    """Memory matching Go backend structure."""

    id: str
    content: str
    description: str
    state: str
    created_by_entity_type: str
    created_by_id: str
    created_at: datetime
    updated_at: datetime
    type: str
    current_version: int
    approval_status: str
    tags: List[str] = None
    estimated_stale_at: Optional[datetime] = None
    stale_when_text: Optional[str] = None
    created_from: Optional[str] = None
    organization_id: Optional[str] = None
    extra: Any = None
    dataset_id: Optional[str] = None
    integration_config_id: Optional[str] = None
    user_id: Optional[str] = None
    thread_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["content"] = self.content
        result["description"] = self.description
        if self.tags is not None:
            result["tags"] = self.tags
        result["state"] = self.state
        if self.estimated_stale_at is not None:
            result["estimated_stale_at"] = self.estimated_stale_at
        if self.stale_when_text is not None:
            result["stale_when_text"] = self.stale_when_text
        result["created_by_entity_type"] = self.created_by_entity_type
        result["created_by_id"] = self.created_by_id
        if self.created_from is not None:
            result["created_from"] = self.created_from
        if self.organization_id is not None:
            result["organization_id"] = self.organization_id
        if self.extra is not None:
            result["extra"] = self.extra
        result["created_at"] = self.created_at
        result["updated_at"] = self.updated_at
        result["type"] = self.type
        if self.dataset_id is not None:
            result["dataset_id"] = self.dataset_id
        if self.integration_config_id is not None:
            result["integration_config_id"] = self.integration_config_id
        if self.user_id is not None:
            result["user_id"] = self.user_id
        if self.thread_id is not None:
            result["thread_id"] = self.thread_id
        result["current_version"] = self.current_version
        result["approval_status"] = self.approval_status
        return result


@dataclass
class Resource:
    """Resource matching Go backend structure."""

    id: str
    key: str
    name: str
    type: Any
    created_at: datetime
    updated_at: datetime
    integration_config_id: str
    state: Any
    attach_type: Any
    dataset_id: str
    description: Optional[str] = None
    use_cases: List[str] = None
    tags: List[str] = None
    instructions: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["key"] = self.key
        result["name"] = self.name
        result["type"] = self.type
        if self.description is not None:
            result["description"] = self.description
        if self.use_cases is not None:
            result["use_cases"] = self.use_cases
        if self.tags is not None:
            result["tags"] = self.tags
        result["created_at"] = self.created_at
        result["updated_at"] = self.updated_at
        result["integration_config_id"] = self.integration_config_id
        result["state"] = self.state
        result["attach_type"] = self.attach_type
        result["dataset_id"] = self.dataset_id
        if self.instructions is not None:
            result["instructions"] = self.instructions
        return result


# Integration classes from Go structs
@dataclass
class UIConfigIcon:
    """UIConfigIcon matching Go backend structure."""

    set: str
    name: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["set"] = self.set
        result["name"] = self.name
        return result


@dataclass
class UIConfig:
    """UIConfig matching Go backend structure."""

    brand_logo_icon: "UIConfigIcon"
    brand_color: str
    button_style: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["brand_logo_icon"] = self.brand_logo_icon
        result["brand_color"] = self.brand_color
        result["button_style"] = self.button_style
        return result


@dataclass
class ErrorHandlingConfig:
    """ErrorHandlingConfig matching Go backend structure."""

    ignore_errors: List[str] = None
    error_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.ignore_errors is not None:
            result["ignore_errors"] = self.ignore_errors
        if self.error_path is not None:
            result["error_path"] = self.error_path
        return result


@dataclass
class SegmentLevel:
    """SegmentLevel matching Go backend structure."""

    name: str
    type: str
    selectable: bool
    url_template: str = None
    method: str = None
    body: str = None
    id_path: str = None
    id_regex: str = None
    name_path: str = None
    parent_key: str = None
    required_credentials: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["type"] = self.type
        result["selectable"] = self.selectable
        if self.url_template is not None:
            result["url_template"] = self.url_template
        if self.method is not None:
            result["method"] = self.method
        if self.body is not None:
            result["body"] = self.body
        if self.id_path is not None:
            result["id_path"] = self.id_path
        if self.id_regex is not None:
            result["id_regex"] = self.id_regex
        if self.name_path is not None:
            result["name_path"] = self.name_path
        if self.parent_key is not None:
            result["parent_key"] = self.parent_key
        if self.required_credentials is not None:
            result["required_credentials"] = self.required_credentials
        return result


@dataclass
class SegmentConfig:
    """SegmentConfig matching Go backend structure."""

    selection_type: Any
    description: str
    hierarchical: bool
    levels: List["SegmentLevel"]
    min_selections: Optional[int] = None
    max_selections: Optional[int] = None
    base_url: str = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["selection_type"] = self.selection_type
        if self.min_selections is not None:
            result["min_selections"] = self.min_selections
        if self.max_selections is not None:
            result["max_selections"] = self.max_selections
        result["description"] = self.description
        result["hierarchical"] = self.hierarchical
        if self.base_url is not None:
            result["base_url"] = self.base_url
        result["levels"] = self.levels
        if self.error_handling is not None:
            result["error_handling"] = self.error_handling
        return result


@dataclass
class ResourceTypeConfig:
    """ResourceTypeConfig matching Go backend structure."""

    type: str
    url_template: str
    id_path: str
    name_path: str
    method: str = None
    body: str = None
    description_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        result["url_template"] = self.url_template
        if self.method is not None:
            result["method"] = self.method
        if self.body is not None:
            result["body"] = self.body
        result["id_path"] = self.id_path
        result["name_path"] = self.name_path
        if self.description_path is not None:
            result["description_path"] = self.description_path
        return result


@dataclass
class DatasetResourceDiscoveryConfig:
    """DatasetResourceDiscoveryConfig matching Go backend structure."""

    min_resources_required: int
    table_query: str = None
    relationship_query: str = None
    index_query: str = None
    constraint_query: str = None
    statistics_query: str = None
    size_query: str = None
    base_url: str = None
    resource_types: List["ResourceTypeConfig"] = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["min_resources_required"] = self.min_resources_required
        if self.table_query is not None:
            result["table_query"] = self.table_query
        if self.relationship_query is not None:
            result["relationship_query"] = self.relationship_query
        if self.index_query is not None:
            result["index_query"] = self.index_query
        if self.constraint_query is not None:
            result["constraint_query"] = self.constraint_query
        if self.statistics_query is not None:
            result["statistics_query"] = self.statistics_query
        if self.size_query is not None:
            result["size_query"] = self.size_query
        if self.base_url is not None:
            result["base_url"] = self.base_url
        if self.resource_types is not None:
            result["resource_types"] = self.resource_types
        if self.error_handling is not None:
            result["error_handling"] = self.error_handling
        return result


@dataclass
class ExpiryConfig:
    """ExpiryConfig matching Go backend structure."""

    type: Any
    duration: Any = None
    field_name: str = None
    refresh_token_duration: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type
        if self.duration is not None:
            result["duration"] = self.duration
        if self.field_name is not None:
            result["field_name"] = self.field_name
        if self.refresh_token_duration is not None:
            result["refresh_token_duration"] = self.refresh_token_duration
        return result


@dataclass
class SegmentOption:
    """SegmentOption matching Go backend structure."""

    id: str
    name: str
    type: str
    metadata: Any
    children: List["SegmentOption"]
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id
        result["name"] = self.name
        result["type"] = self.type
        if self.parent_id is not None:
            result["parent_id"] = self.parent_id
        result["metadata"] = self.metadata
        result["children"] = self.children
        return result


@dataclass
class IntegrationDefinition:
    """IntegrationDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    auth_types: List[Any]
    status: Any
    description: Optional[str] = None
    provider_name: Optional[str] = None
    documentation_url: Optional[str] = None
    openapi_documentation_url: Optional[str] = None
    llms_txt_url: Optional[str] = None
    healthcheck_url: Optional[str] = None
    auth_url: Optional[str] = None
    token_url: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    available_scopes: List[str] = None
    optional_scopes: List[str] = None
    scope_separator: Optional[str] = None
    api_version: Optional[str] = None
    api_version_description: Optional[str] = None
    credential_schema: Any = None
    ui_config: Optional["UIConfig"] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    segment_config: Optional["SegmentConfig"] = None
    dataset_resource_discovery_config: Optional["DatasetResourceDiscoveryConfig"] = None
    expiry_config: Optional["ExpiryConfig"] = None
    provider_credentials: Any = None
    default_resource_attach_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name
        result["key"] = self.key
        result["type"] = self.type
        result["auth_types"] = self.auth_types
        result["status"] = self.status
        if self.description is not None:
            result["description"] = self.description
        if self.provider_name is not None:
            result["provider_name"] = self.provider_name
        if self.documentation_url is not None:
            result["documentation_url"] = self.documentation_url
        if self.openapi_documentation_url is not None:
            result["openapi_documentation_url"] = self.openapi_documentation_url
        if self.llms_txt_url is not None:
            result["llms_txt_url"] = self.llms_txt_url
        if self.healthcheck_url is not None:
            result["healthcheck_url"] = self.healthcheck_url
        if self.auth_url is not None:
            result["auth_url"] = self.auth_url
        if self.token_url is not None:
            result["token_url"] = self.token_url
        if self.client_id is not None:
            result["client_id"] = self.client_id
        if self.client_secret is not None:
            result["client_secret"] = self.client_secret
        if self.available_scopes is not None:
            result["available_scopes"] = self.available_scopes
        if self.optional_scopes is not None:
            result["optional_scopes"] = self.optional_scopes
        if self.scope_separator is not None:
            result["scope_separator"] = self.scope_separator
        if self.api_version is not None:
            result["api_version"] = self.api_version
        if self.api_version_description is not None:
            result["api_version_description"] = self.api_version_description
        if self.credential_schema is not None:
            result["credential_schema"] = self.credential_schema
        if self.ui_config is not None:
            result["ui_config"] = self.ui_config
        if self.codegen_details is not None:
            result["codegen_details"] = self.codegen_details
        if self.analysis_details is not None:
            result["analysis_details"] = self.analysis_details
        if self.segment_config is not None:
            result["segment_config"] = self.segment_config
        if self.dataset_resource_discovery_config is not None:
            result["dataset_resource_discovery_config"] = (
                self.dataset_resource_discovery_config
            )
        if self.expiry_config is not None:
            result["expiry_config"] = self.expiry_config
        if self.provider_credentials is not None:
            result["provider_credentials"] = self.provider_credentials
        if self.default_resource_attach_type is not None:
            result["default_resource_attach_type"] = self.default_resource_attach_type
        return result


@dataclass
class IntegrationConfig:
    """IntegrationConfig matching Go backend structure."""

    definition: "IntegrationDefinition"
    source: str
    file_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["definition"] = self.definition
        result["source"] = self.source
        if self.file_path is not None:
            result["file_path"] = self.file_path
        return result


@dataclass
class PythonIntegrationInstance:
    """PythonIntegrationInstance matching Go backend structure."""

    config: IntegrationConfig
    credentials: Any
    methods: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = self.config
        result["credentials"] = self.credentials
        if self.methods is not None:
            result["methods"] = self.methods
        return result


@dataclass
class IntegrationDiscovery:
    """IntegrationDiscovery matching Go backend structure."""

    config: IntegrationConfig
    file_path: str
    source_code: str
    instance: Optional["PythonIntegrationInstance"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = self.config
        if self.instance is not None:
            result["instance"] = self.instance
        result["file_path"] = self.file_path
        result["source_code"] = self.source_code
        return result


@dataclass
class UpsertIntegrationRequest:
    """UpsertIntegrationRequest matching Go backend structure."""

    integration: "IntegrationDefinition"
    source: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration"] = self.integration
        result["source"] = self.source
        return result


@dataclass
class UpsertIntegrationResponse:
    """UpsertIntegrationResponse matching Go backend structure."""

    integration_id: str
    status: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration_id"] = self.integration_id
        result["status"] = self.status
        return result


@dataclass
class ListIntegrationsResponse:
    """ListIntegrationsResponse matching Go backend structure."""

    integrations: List["IntegrationDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = self.integrations
        return result


@dataclass
class ExportIntegrationsResponse:
    """ExportIntegrationsResponse matching Go backend structure."""

    integrations: Any

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = self.integrations
        return result


# Auto-generated __all__ list for import *
__all__ = [
    "ParameterType",
    "ParameterHydrationBehaviour",
    "OutputVisibility",
    "OutputContentType",
    "HandlerType",
    "ExecutionModeType",
    "LlmModel",
    "OutputBehaviorType",
    "CredentialSource",
    "SensitivityLevel",
    "JSONSchemaType",
    "InvocationEventType",
    "Status",
    "Error",
    "DatasetType",
    "IntegrationType",
    "AuthType",
    "IntegrationStatus",
    "SegmentSelectionType",
    "ExpiryType",
    "ResourceType",
    "ResourceState",
    "ResourceRelationshipType",
    "ResourceAttachType",
    "Bot",
    "ParameterDefinition",
    "ParameterValueSource",
    "ParameterValueSourceHandler",
    "ParameterInterpreter",
    "AgentDiscovery",
    "ExecutionModeConfig",
    "UpsertBotRequest",
    "BotsResponse",
    "StepsResponse",
    "ServiceDefinition",
    "ActionDefinition",
    "ResultSchema",
    "PropertySchema",
    "IntegrationSchema",
    "CodegenDetails",
    "AnalysisDetails",
    "CredentialSchema",
    "ExportActionsResponse",
    "ConditionDefinition",
    "TempCondition",
    "StepWithHandlers",
    "ResultHandler",
    "JSONSchemaProperty",
    "JSONSchema",
    "Tool",
    "Message",
    "SystemParameters",
    "Result",
    "APIStep",
    "APIParameterValueSource",
    "APIParameterValueSourceHandler",
    "APIParameterInterpreter",
    "APIExecutionMode",
    "APIConditionDefinition",
    "APITool",
    "APIResultHandler",
    "APIParameterDefinition",
    "APIStepWithHandlers",
    "Dataset",
    "BotResource",
    "UIConfigIcon",
    "UIConfig",
    "ErrorHandlingConfig",
    "SegmentLevel",
    "SegmentConfig",
    "ResourceTypeConfig",
    "DatasetResourceDiscoveryConfig",
    "ExpiryConfig",
    "SegmentOption",
    "IntegrationDefinition",
    "IntegrationConfig",
    "PythonIntegrationInstance",
    "IntegrationDiscovery",
    "UpsertIntegrationRequest",
    "UpsertIntegrationResponse",
    "ListIntegrationsResponse",
    "ExportIntegrationsResponse",
    "Memory",
    "Resource",
]


# Helper functions for creating bot definitions
def create_step(
    key: str,
    action_type: str,
    parameters: Dict[str, Any] = None,
    depends_on: List[str] = None,
    **kwargs,
) -> Dict[str, Any]:
    """Create a step definition dictionary."""
    step = {
        "key": key,
        "action_type": action_type,
        "parameters": parameters or {},
        "output_content_type": kwargs.get("output_content_type", "text"),
        "user_output_visibility": kwargs.get("user_output_visibility", "visible"),
        "bot_output_visibility": kwargs.get("bot_output_visibility", "hidden"),
    }

    # Add optional fields if provided
    for field in [
        "history_content_type",
        "ui_content_type",
        "running_message",
        "finished_message",
    ]:
        if field in kwargs:
            step[field] = kwargs[field]

    return {
        "step": step,
        "depends_on": depends_on,
        "result_handlers": [],
        "output_channels": [],
    }


def create_result_handler(
    condition: Dict[str, Any],
    action_type: str = None,
    parameters: Dict[str, Any] = None,
    steps: List[Dict[str, Any]] = None,
    **kwargs,
) -> Dict[str, Any]:
    """Create a result handler definition dictionary."""
    handler = {
        "type": kwargs.get("type", "final"),
        "if_conditions": condition,
        "output_content_type": kwargs.get("output_content_type", "text"),
        "steps": steps or [],
    }

    # Add optional fields
    for field in ["history_content_type", "ui_content_type"]:
        if field in kwargs:
            handler[field] = kwargs[field]

    # If action_type is provided, create a step for it
    if action_type:
        step = {
            "key": f"handler_step_{len(handler['steps'])}",
            "action_type": action_type,
            "parameters": parameters or {},
            "output_content_type": "text",
            "user_output_visibility": "visible",
            "bot_output_visibility": "hidden",
        }
        handler["steps"].append(step)

    return handler


def create_bot(
    name: str, description: str = "", visibility: str = "private", **kwargs
) -> Dict[str, Any]:
    """Create a bot definition dictionary."""
    return {
        "Name": name,
        "Description": description,
        "Visibility": visibility,
        "RunningMessage": {
            "String": kwargs.get("running_message", ""),
            "Valid": bool(kwargs.get("running_message")),
        },
        "FinishedMessage": {
            "String": kwargs.get("finished_message", ""),
            "Valid": bool(kwargs.get("finished_message")),
        },
        "Persona": {
            "String": kwargs.get("persona", ""),
            "Valid": bool(kwargs.get("persona")),
        },
        "Source": "python",
    }
