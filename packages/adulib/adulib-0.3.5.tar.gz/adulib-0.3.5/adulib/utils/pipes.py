# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../pts/api/utils/02_pipes.pct.py.

# %% auto 0
__all__ = ['psum', 'pmin', 'pmax', 'pabs', 'padd', 'psub', 'pmul', 'pdiv', 'pmod', 'ptype', 'plist', 'ptuple', 'pdict', 'pset',
           'pint', 'pfloat', 'pstr', 'pbool', 'pjoin', 'psplit', 'pstrip', 'plstrip', 'prstrip', 'pupper', 'plower',
           'pbind', 'ppartial', 'papply', 'pcall', 'pflatten', 'plen', 'pmap', 'puniq', 'ptranspose', 'pfilter',
           'psort', 'pt', 'penumerate', 'pzip', 'pslice', 'pbatched', 'pchain', 'pchain_with', 'pdedup', 'pgroupby',
           'ppermutations', 'preverse', 'pskip_while', 'ptail', 'ptake', 'ptake_while', 'ptraverse', 'pget', 'pgetattr',
           'ptee', 'pshow', 'pwrite', 'pread', 'pcopy', 'psave_pkl', 'pload_pkl', 'pto_df', 'pcopy_df', 'papply_mask',
           'pto_json', 'pfrom_json']

# %% ../../../pts/api/utils/02_pipes.pct.py 3
import pipe
import tempfile
import pickle

# %% ../../../pts/api/utils/02_pipes.pct.py 4
class PipeRRShift:
    def __init__(self, func):
        self.__doc__ = func.__doc__
        self.func = func

    def __call__(self, *args, **kwargs):
        return PipeRRShift(lambda x: self.func(x, *args, **kwargs))

    def __rrshift__(self, other):
        return self.func(other)

# %% ../../../pts/api/utils/02_pipes.pct.py 6
psum = pipe.Pipe(lambda x, start=0: sum(x, start=start))
pmin = pipe.Pipe(lambda x, key=(lambda y:y): min(x, key=key))
pmax = pipe.Pipe(lambda x, key=(lambda y:y): max(x, key=key))
pabs = pipe.Pipe(lambda x: abs(x))
padd = pipe.Pipe(lambda x, y: x + y)
psub = pipe.Pipe(lambda x, y: x - y)
pmul = pipe.Pipe(lambda x, y: x * y)
pdiv = pipe.Pipe(lambda x, y: x / y)
pmod = pipe.Pipe(lambda x, y: x % y)

# %% ../../../pts/api/utils/02_pipes.pct.py 12
ptype = pipe.Pipe(lambda x, typ: typ(x))
plist = pipe.Pipe(lambda x: list(x))
ptuple = pipe.Pipe(lambda x: tuple(x))
pdict = pipe.Pipe(lambda x: dict(x))
pset = pipe.Pipe(lambda x: set(x))
pint = pipe.Pipe(lambda x: int(x))
pfloat = pipe.Pipe(lambda x: float(x))
pstr = pipe.Pipe(lambda x: str(x))
pbool = pipe.Pipe(lambda x: bool(x))

# %% ../../../pts/api/utils/02_pipes.pct.py 15
pjoin = pipe.Pipe(lambda x, sep: sep.join(str(i) for i in x))
psplit = pipe.Pipe(lambda x, sep=None, maxsplit=-1: x.split(sep, maxsplit=maxsplit))
pstrip = pipe.Pipe(lambda x, chars=None: x.strip(chars))
plstrip = pipe.Pipe(lambda x, chars=None: x.lstrip(chars))
prstrip = pipe.Pipe(lambda x, chars=None: x.rstrip(chars))
pupper = pipe.Pipe(lambda x: x.upper())
plower = pipe.Pipe(lambda x: x.lower())

# %% ../../../pts/api/utils/02_pipes.pct.py 18
pbind = pipe.Pipe(lambda x, f, *args, **kwargs: lambda *args2, **kwargs2: f(x, *args, *args2, **kwargs, **kwargs2))
ppartial = pipe.Pipe(lambda f, *args, **kwargs: lambda *args2, **kwargs2: f(*args, *args2, **kwargs, **kwargs2))
papply = pipe.Pipe(lambda x, f: f(x))
pcall = pipe.Pipe(lambda f, *args, **kwargs: f(*args, **kwargs))

# %% ../../../pts/api/utils/02_pipes.pct.py 23
def _pflatten_helper(lst, curr_level, levels=None):
    """Helper function to flatten a nested list."""
    if levels is not None and curr_level > levels:
        yield lst
        return
    for item in lst:
        if isinstance(item, list):
            yield from _pflatten_helper(item, curr_level+1, levels)
        else:
            yield item

pflatten = pipe.Pipe(lambda x, levels=None: _pflatten_helper(x, 0, levels))
plen = pipe.Pipe(lambda x: len(x))

# %% ../../../pts/api/utils/02_pipes.pct.py 24
pmap = pipe.map
puniq = pipe.uniq
ptranspose = pipe.transpose
pfilter = pipe.filter
psort = pipe.sort
pt = pipe.t
penumerate = pipe.enumerate
pzip = pipe.izip
pslice = pipe.islice

pbatched = pipe.batched
pchain = pipe.chain
pchain_with = pipe.chain_with
pdedup = pipe.dedup
pgroupby = pipe.groupby
ppermutations = pipe.permutations
preverse = pipe.reverse
pskip_while = pipe.skip_while
ptail = pipe.tail
ptake = pipe.take
ptake_while = pipe.take_while
ptraverse = pipe.traverse

# %% ../../../pts/api/utils/02_pipes.pct.py 29
pget = pipe.Pipe(lambda x, k: x[k])
pgetattr = pipe.Pipe(lambda x, k: getattr(x, k))
ptee = pipe.tee

# %% ../../../pts/api/utils/02_pipes.pct.py 33
@pipe.Pipe
def pwrite(content, file_path=None, mode='w'):
    if file_path is None:
        file_path = tempfile.NamedTemporaryFile(delete=False).name
    with open(file_path, mode) as f:
        f.write(content)
    return file_path
    
@pipe.Pipe
def pread(file_path, mode='r'):
    with open(file_path, mode) as f:
        return f.read()
    
pshow = pipe.Pipe(lambda x: print(x) or x)  # Returns x for chaining

@pipe.Pipe
def pcopy(content):
    """Copy content to clipboard."""
    import pyperclip
    pyperclip.copy(content)
    return content

# %% ../../../pts/api/utils/02_pipes.pct.py 37
@pipe.Pipe
def psave_pkl(obj, file_path=None):
    """Write an object to a pickle file."""
    if file_path is None:
        file_path = tempfile.NamedTemporaryFile(delete=False).name
    with open(file_path, 'wb') as f:
        pickle.dump(obj, f)
    return file_path
    
@pipe.Pipe
def pload_pkl(file_path):
    """Read a pickle file and return the object."""
    with open(file_path, 'rb') as f:
        return pickle.load(f)

# %% ../../../pts/api/utils/02_pipes.pct.py 39
@pipe.Pipe
def pto_df(data, **kwargs):
    """Create a pandas DataFrame."""
    import pandas as pd
    return pd.DataFrame(data, **kwargs)

@PipeRRShift
def pcopy_df(df):
    """
    Copy a DataFrame to clipboard in a format compatible with Google Sheets or Excel.
    
    Usage:
    ```python
    df >> pcopy_df
    ```
    """
    from adulib.utils.wrangle import df_to_clipboard
    df_to_clipboard(df)
    return df

@PipeRRShift
def papply_mask(mask, df):
    """
    Apply a mask to a DataFrame.
    
    Usage:
    ```python
    mask >> papply_mask(df)
    ```
    """
    return df[mask]

# %% ../../../pts/api/utils/02_pipes.pct.py 43
@pipe.Pipe
def pto_json(data, **kwargs):
    """Convert data to JSON string."""
    import json
    return json.dumps(data, **kwargs)

@pipe.Pipe
def pfrom_json(json_str, **kwargs):
    import json
    """Convert JSON string to Python object."""
    return json.loads(json_str, **kwargs)
