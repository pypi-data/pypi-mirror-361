#include "fex.h"
#include <cstring>
#include <stdexcept>

// --- S-Box: Custom, nonlinear, invertible 8-bit S-box ---
// This S-box is generated by a simple nonlinear transformation and a fixed permutation.
// For beta, we use a simple invertible function for demonstration.
uint8_t FEX::sbox(uint8_t x) {
    // Example: invert bits, rotate left by 3, xor with 0xA5
    return static_cast<uint8_t>(((x ^ 0xA5) << 3) | ((x ^ 0xA5) >> 5));
}

uint8_t FEX::inv_sbox(uint8_t x) {
    // Inverse of sbox: rotate right by 3, xor with 0xA5
    uint8_t y = static_cast<uint8_t>((x >> 3) | (x << 5));
    return y ^ 0xA5;
}

// --- P-Box: Custom permutation of 128 bits ---
// For speed, we permute bytes in a fixed pattern (beta: simple shuffle)
void FEX::pbox(uint8_t* block) {
    // Permute bytes: 0->7, 1->14, 2->5, 3->12, ... (example pattern)
    const uint8_t perm[16] = {7,14,5,12,3,10,1,8,15,2,13,4,9,0,11,6};
    uint8_t tmp[16];
    for (int i = 0; i < 16; ++i) tmp[i] = block[perm[i]];
    std::memcpy(block, tmp, 16);
}

void FEX::inv_pbox(uint8_t* block) {
    const uint8_t perm[16] = {7,14,5,12,3,10,1,8,15,2,13,4,9,0,11,6};
    uint8_t tmp[16];
    for (int i = 0; i < 16; ++i) tmp[perm[i]] = block[i];
    std::memcpy(block, tmp, 16);
}

// --- Key Schedule: Expand user key into round keys ---
void FEX::key_schedule(const uint8_t* key, size_t key_len_bytes) {
    // Number of rounds: proportional to key length (min 8, max 32)
    num_rounds_ = 8 + (key_len_bytes * 8) / 64;
    if (num_rounds_ > 32) num_rounds_ = 32;
    if (num_rounds_ < 8) num_rounds_ = 8;
    round_keys_.resize(num_rounds_);
    // Simple key expansion: hash key bytes into 64-bit round keys
    for (size_t r = 0; r < num_rounds_; ++r) {
        uint64_t rk = 0;
        for (size_t i = 0; i < key_len_bytes; ++i) {
            rk ^= static_cast<uint64_t>(key[i]) << ((8 * ((i + r) % 8)));
            rk = (rk << 5) | (rk >> (59)); // rotate left 5
            rk ^= (0x9E3779B97F4A7C15ull * (r + 1)); // mix with golden ratio
        }
        round_keys_[r] = rk;
    }
}

// --- Constructor ---
FEX::FEX(const uint8_t* key, size_t key_len_bytes) {
    if (key_len_bytes * 8 < MIN_KEY_BITS || key_len_bytes * 8 > MAX_KEY_BITS) {
        throw std::invalid_argument("Key length out of bounds");
    }
    key_schedule(key, key_len_bytes);
}

// --- Encrypt a single 128-bit block (in-place) ---
void FEX::encrypt_block(uint8_t* block) const {
    // Feistel-like SPN: 16 rounds, each round: S-box, P-box, key-mix
    uint8_t state[16];
    std::memcpy(state, block, 16);
    for (size_t r = 0; r < num_rounds_; ++r) {
        // Key mixing: xor 8 bytes from round key
        for (int i = 0; i < 16; ++i) {
            state[i] ^= static_cast<uint8_t>((round_keys_[r] >> (8 * (i % 8))) & 0xFF);
        }
        // S-box layer
        for (int i = 0; i < 16; ++i) {
            state[i] = sbox(state[i]);
        }
        // P-box layer (skip on last round)
        if (r != num_rounds_ - 1) {
            pbox(state);
        }
    }
    std::memcpy(block, state, 16);
}

// --- Decrypt a single 128-bit block (in-place) ---
void FEX::decrypt_block(uint8_t* block) const {
    uint8_t state[16];
    std::memcpy(state, block, 16);
    for (size_t r = num_rounds_; r-- > 0;) {
        // Inverse P-box (skip on first round)
        if (r != num_rounds_ - 1) {
            inv_pbox(state);
        }
        // Inverse S-box
        for (int i = 0; i < 16; ++i) {
            state[i] = inv_sbox(state[i]);
        }
        // Key mixing
        for (int i = 0; i < 16; ++i) {
            state[i] ^= static_cast<uint8_t>((round_keys_[r] >> (8 * (i % 8))) & 0xFF);
        }
    }
    std::memcpy(block, state, 16);
}

// --- PKCS#7 Padding ---
std::vector<uint8_t> FEX::pad(const std::vector<uint8_t>& data) {
    size_t pad_len = BLOCK_SIZE - (data.size() % BLOCK_SIZE);
    std::vector<uint8_t> out = data;
    out.insert(out.end(), pad_len, static_cast<uint8_t>(pad_len));
    return out;
}

std::vector<uint8_t> FEX::unpad(const std::vector<uint8_t>& data) {
    if (data.empty() || data.size() % BLOCK_SIZE != 0) throw std::runtime_error("Invalid padding");
    uint8_t pad_len = data.back();
    if (pad_len == 0 || pad_len > BLOCK_SIZE) throw std::runtime_error("Invalid padding");
    for (size_t i = data.size() - pad_len; i < data.size(); ++i) {
        if (data[i] != pad_len) throw std::runtime_error("Invalid padding");
    }
    return std::vector<uint8_t>(data.begin(), data.end() - pad_len);
}
