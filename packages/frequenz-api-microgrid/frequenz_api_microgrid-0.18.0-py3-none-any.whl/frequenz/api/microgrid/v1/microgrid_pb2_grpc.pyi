"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Microgrid API

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import abc
import collections.abc
import frequenz.api.microgrid.v1.microgrid_pb2
import google.protobuf.empty_pb2
import grpc
import grpc.aio
import typing

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

class MicrogridStub:
    """The Frequenz Microgrid API"""

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    GetMicrogridMetadata: grpc.UnaryUnaryMultiCallable[
        google.protobuf.empty_pb2.Empty,
        frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse,
    ]
    """Returns the microgrid metadata
    The metadata consists of information that describes the overall
    microgrid, as opposed to its electrical components or sensors,
    e.g., the microgrid ID, location.
    """

    ListComponents: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse,
    ]
    """List electrical components in the local microgrid, optionally filtered by a
    given list of component IDs and component categories.

    Electrical components are a part of a microgrid's electrical infrastructure
    are can be connected to each other to form an electrical circuit, which can
    then be represented as a graph.

    If provided, the filters for component IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
     `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

    If a filter list is empty, then that filter is not applied.
    """

    ListSensors: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse,
    ]
    """Returns a list of sensors in the local microgrid, optionally filtered by a
    given list of sensor IDs and sensor categories.

    Sensors measure physical metrics in the microgrid's surroundings, and are
    not classified as electrical components.

    If provided, the filters for sensor IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,
     `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR
    `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.

    If a filter list is empty, then that filter is not applied.
    """

    ListConnections: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse,
    ]
    """Electrical components are a part of a microgrid's electrical infrastructure
    are can be connected to each other to form an electrical circuit, which can
    then be represented as a graph.

    This RPC return a list of the connections between two components, denoted
    by `(start, end)`. The direction of a connection is always away from the
    grid endpoint, i.e. aligned with the direction of positive current
    according to the passive sign convention:
    https://en.wikipedia.org/wiki/Passive_sign_convention

    The request may be filtered by `start`/`end` component(s) of individual
    connections.  If provided, the `start` and `end` filters have an `AND`
    relationship between each other, meaning that they are applied serially,
    but an `OR` relationship with other elements in the same list.
    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
    result should have all the connections where
    * each `start` component ID is either `1`, `2`, OR `3`,
     AND
    * each `end` component ID is either `4`, `5`, OR `6`.
    """

    ReceiveComponentDataStream: grpc.UnaryStreamMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse,
    ]
    """Returns a stream containing data from a component with a given ID."""

    ReceiveSensorDataStream: grpc.UnaryStreamMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse,
    ]
    """Returns a stream containing data from a sensor with a given ID."""

    AddComponentBounds: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsResponse,
    ]
    """Adds inclusion bounds for a given metric of a given component. Returns the
    time at which the bounds will expire (as a timestamp (UTC)).

    The request parameters allows users to select a duration until
    which the bounds will stay in effect. If no duration is provided, then the
    bounds will be removed after a default duration of 5 seconds.

    Inclusion bounds give the range that the system will try to keep the
    metric within. If the metric goes outside of these bounds, the system will
    try to bring it back within the bounds.
    If the bounds for a metric are [[`lower_1`, `upper_1`],
    [`lower_2`, `upper_2`]], then this metric's `value` needs to comply with
    the constraints
    `lower_1 <= value <= upper_1` OR `lower_2 <= value <= upper_2`.

    If multiple inclusion bounds have been provided for a metric, then the
    overlapping bounds are merged into a single bound, and non-overlapping
    bounds are kept separate.
    E.g. if the bounds are [[0, 10], [5, 15], [20, 30]], then the resulting
    bounds will be [[0, 15], [20, 30]].

    The following diagram illustrates how bounds are applied:
    ```
      lower_1  upper_1
    <----|========|--------|========|-------->
                        lower_2  upper_2
    ```
    The bounds in this example are `[[lower_1, upper_1], [lower_2, upper_2]]`.
    ---- values here are considered out of range.
    ==== values here are considered within range.

    Note that for power metrics, regardless of the bounds, 0W is always
    allowed.
    """

    SetComponentPowerActive: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveResponse,
    ]
    """Sets the active power output of a component with a given ID, provided the
    component supports it. The power output is specified in watts.

    The power output can be -ve or +ve, depending on whether the component is
    supposed to be discharging or charging, respectively.

    The return value is the timestamp until which the given power command will
    stay in effect. After this timestamp, the component's active power will be
    set to 0, if the API receives no further command to change it before then.
    By default, this timestamp will be set to the current time plus 60 seconds.

    Note that the target component may have a resolution of more than 1 W.
    E.g., an inverter may have a resolution of 88 W.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Sends the discharge command to the inverter, making it deliver
     AC power.
    """

    SetComponentPowerReactive: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveResponse,
    ]
    """Sets the reactive power output of a component with a given ID, provided the
    component supports it. The power output is specified in VAr.

    We follow the polarity specified in the IEEE 1459-2010 standard
    definitions, where
    - positive reactive is inductive (current is lagging the voltage)
    - negative reactive is capacitive (current is leading the voltage)

    The return value is the timestamp until which the given power command will
    stay in effect. After this timestamp, the component's reactive power will
    be set to 0, if the API receives no further command to change it before
    then.
    By default, this timestamp will be set to the current time plus 60 seconds.

    Note that the target component may have a resolution of more than 1 VAr.
    E.g., an inverter may have a resolution of 88 VAr.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.
    """

    StartComponent: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Starts the component, and brings it into a state where it is immediately
    operational.

    Performs the following sequence of actions for the following component
    categories:

    * Inverter:
     * closes DC relays, if the feature is available
     * closes AC relays
     * sets power output to 0

    * Battery: Checks if DC relays are open, then
     * closes DC relays

    * Relays:
     * closes relays

    * Precharge Modules:
     * starts the precharge process, and eventually closes the DC relays.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    PutComponentInStandby: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a standby state, from which it can take a
    few minutes to return to an operational state. A transition to an
    operational state can be triggered by calling the `StartComponent` RPC, or
    the `SetComponentPowerActive` RPC.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0, and
     * opens AC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call efffectively skips that action.
    """

    StopComponent: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Stops the component completely, potentially disengaging its power
    electronics controller(s).

    Performs the following sequence actions for the following component
    categories:

    * Inverter:
     * Brings component to the cold-standby state
     * opens DC relays

    * Battery: Checks if the power output is 0, then
     * opens DC relays

    * Relays:
     * opens relays

    * Precharge Modules:
     * opens the DC relays.

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    AckComponentError: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Acknowledges any recoverable error reported by the component, and brings it
    back to the stopped or cold-standby state.
    """

class MicrogridAsyncStub:
    """The Frequenz Microgrid API"""

    GetMicrogridMetadata: grpc.aio.UnaryUnaryMultiCallable[
        google.protobuf.empty_pb2.Empty,
        frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse,
    ]
    """Returns the microgrid metadata
    The metadata consists of information that describes the overall
    microgrid, as opposed to its electrical components or sensors,
    e.g., the microgrid ID, location.
    """

    ListComponents: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse,
    ]
    """List electrical components in the local microgrid, optionally filtered by a
    given list of component IDs and component categories.

    Electrical components are a part of a microgrid's electrical infrastructure
    are can be connected to each other to form an electrical circuit, which can
    then be represented as a graph.

    If provided, the filters for component IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
     `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

    If a filter list is empty, then that filter is not applied.
    """

    ListSensors: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse,
    ]
    """Returns a list of sensors in the local microgrid, optionally filtered by a
    given list of sensor IDs and sensor categories.

    Sensors measure physical metrics in the microgrid's surroundings, and are
    not classified as electrical components.

    If provided, the filters for sensor IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,
     `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR
    `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.

    If a filter list is empty, then that filter is not applied.
    """

    ListConnections: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse,
    ]
    """Electrical components are a part of a microgrid's electrical infrastructure
    are can be connected to each other to form an electrical circuit, which can
    then be represented as a graph.

    This RPC return a list of the connections between two components, denoted
    by `(start, end)`. The direction of a connection is always away from the
    grid endpoint, i.e. aligned with the direction of positive current
    according to the passive sign convention:
    https://en.wikipedia.org/wiki/Passive_sign_convention

    The request may be filtered by `start`/`end` component(s) of individual
    connections.  If provided, the `start` and `end` filters have an `AND`
    relationship between each other, meaning that they are applied serially,
    but an `OR` relationship with other elements in the same list.
    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
    result should have all the connections where
    * each `start` component ID is either `1`, `2`, OR `3`,
     AND
    * each `end` component ID is either `4`, `5`, OR `6`.
    """

    ReceiveComponentDataStream: grpc.aio.UnaryStreamMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse,
    ]
    """Returns a stream containing data from a component with a given ID."""

    ReceiveSensorDataStream: grpc.aio.UnaryStreamMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse,
    ]
    """Returns a stream containing data from a sensor with a given ID."""

    AddComponentBounds: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsResponse,
    ]
    """Adds inclusion bounds for a given metric of a given component. Returns the
    time at which the bounds will expire (as a timestamp (UTC)).

    The request parameters allows users to select a duration until
    which the bounds will stay in effect. If no duration is provided, then the
    bounds will be removed after a default duration of 5 seconds.

    Inclusion bounds give the range that the system will try to keep the
    metric within. If the metric goes outside of these bounds, the system will
    try to bring it back within the bounds.
    If the bounds for a metric are [[`lower_1`, `upper_1`],
    [`lower_2`, `upper_2`]], then this metric's `value` needs to comply with
    the constraints
    `lower_1 <= value <= upper_1` OR `lower_2 <= value <= upper_2`.

    If multiple inclusion bounds have been provided for a metric, then the
    overlapping bounds are merged into a single bound, and non-overlapping
    bounds are kept separate.
    E.g. if the bounds are [[0, 10], [5, 15], [20, 30]], then the resulting
    bounds will be [[0, 15], [20, 30]].

    The following diagram illustrates how bounds are applied:
    ```
      lower_1  upper_1
    <----|========|--------|========|-------->
                        lower_2  upper_2
    ```
    The bounds in this example are `[[lower_1, upper_1], [lower_2, upper_2]]`.
    ---- values here are considered out of range.
    ==== values here are considered within range.

    Note that for power metrics, regardless of the bounds, 0W is always
    allowed.
    """

    SetComponentPowerActive: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveResponse,
    ]
    """Sets the active power output of a component with a given ID, provided the
    component supports it. The power output is specified in watts.

    The power output can be -ve or +ve, depending on whether the component is
    supposed to be discharging or charging, respectively.

    The return value is the timestamp until which the given power command will
    stay in effect. After this timestamp, the component's active power will be
    set to 0, if the API receives no further command to change it before then.
    By default, this timestamp will be set to the current time plus 60 seconds.

    Note that the target component may have a resolution of more than 1 W.
    E.g., an inverter may have a resolution of 88 W.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Sends the discharge command to the inverter, making it deliver
     AC power.
    """

    SetComponentPowerReactive: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest,
        frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveResponse,
    ]
    """Sets the reactive power output of a component with a given ID, provided the
    component supports it. The power output is specified in VAr.

    We follow the polarity specified in the IEEE 1459-2010 standard
    definitions, where
    - positive reactive is inductive (current is lagging the voltage)
    - negative reactive is capacitive (current is leading the voltage)

    The return value is the timestamp until which the given power command will
    stay in effect. After this timestamp, the component's reactive power will
    be set to 0, if the API receives no further command to change it before
    then.
    By default, this timestamp will be set to the current time plus 60 seconds.

    Note that the target component may have a resolution of more than 1 VAr.
    E.g., an inverter may have a resolution of 88 VAr.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.
    """

    StartComponent: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Starts the component, and brings it into a state where it is immediately
    operational.

    Performs the following sequence of actions for the following component
    categories:

    * Inverter:
     * closes DC relays, if the feature is available
     * closes AC relays
     * sets power output to 0

    * Battery: Checks if DC relays are open, then
     * closes DC relays

    * Relays:
     * closes relays

    * Precharge Modules:
     * starts the precharge process, and eventually closes the DC relays.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    PutComponentInStandby: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a standby state, from which it can take a
    few minutes to return to an operational state. A transition to an
    operational state can be triggered by calling the `StartComponent` RPC, or
    the `SetComponentPowerActive` RPC.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0, and
     * opens AC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call efffectively skips that action.
    """

    StopComponent: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Stops the component completely, potentially disengaging its power
    electronics controller(s).

    Performs the following sequence actions for the following component
    categories:

    * Inverter:
     * Brings component to the cold-standby state
     * opens DC relays

    * Battery: Checks if the power output is 0, then
     * opens DC relays

    * Relays:
     * opens relays

    * Precharge Modules:
     * opens the DC relays.

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    AckComponentError: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest,
        google.protobuf.empty_pb2.Empty,
    ]
    """Acknowledges any recoverable error reported by the component, and brings it
    back to the stopped or cold-standby state.
    """

class MicrogridServicer(metaclass=abc.ABCMeta):
    """The Frequenz Microgrid API"""

    @abc.abstractmethod
    def GetMicrogridMetadata(
        self,
        request: google.protobuf.empty_pb2.Empty,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse]]:
        """Returns the microgrid metadata
        The metadata consists of information that describes the overall
        microgrid, as opposed to its electrical components or sensors,
        e.g., the microgrid ID, location.
        """

    @abc.abstractmethod
    def ListComponents(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse]]:
        """List electrical components in the local microgrid, optionally filtered by a
        given list of component IDs and component categories.

        Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        If provided, the filters for component IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
         `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
         `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

        If a filter list is empty, then that filter is not applied.
        """

    @abc.abstractmethod
    def ListSensors(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse]]:
        """Returns a list of sensors in the local microgrid, optionally filtered by a
        given list of sensor IDs and sensor categories.

        Sensors measure physical metrics in the microgrid's surroundings, and are
        not classified as electrical components.

        If provided, the filters for sensor IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
         `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,
         `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR
        `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.

        If a filter list is empty, then that filter is not applied.
        """

    @abc.abstractmethod
    def ListConnections(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse]]:
        """Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        This RPC return a list of the connections between two components, denoted
        by `(start, end)`. The direction of a connection is always away from the
        grid endpoint, i.e. aligned with the direction of positive current
        according to the passive sign convention:
        https://en.wikipedia.org/wiki/Passive_sign_convention

        The request may be filtered by `start`/`end` component(s) of individual
        connections.  If provided, the `start` and `end` filters have an `AND`
        relationship between each other, meaning that they are applied serially,
        but an `OR` relationship with other elements in the same list.
        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
        result should have all the connections where
        * each `start` component ID is either `1`, `2`, OR `3`,
         AND
        * each `end` component ID is either `4`, `5`, OR `6`.
        """

    @abc.abstractmethod
    def ReceiveComponentDataStream(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse], collections.abc.AsyncIterator[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse]]:
        """Returns a stream containing data from a component with a given ID."""

    @abc.abstractmethod
    def ReceiveSensorDataStream(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse], collections.abc.AsyncIterator[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse]]:
        """Returns a stream containing data from a sensor with a given ID."""

    @abc.abstractmethod
    def AddComponentBounds(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentBoundsResponse]]:
        """Adds inclusion bounds for a given metric of a given component. Returns the
        time at which the bounds will expire (as a timestamp (UTC)).

        The request parameters allows users to select a duration until
        which the bounds will stay in effect. If no duration is provided, then the
        bounds will be removed after a default duration of 5 seconds.

        Inclusion bounds give the range that the system will try to keep the
        metric within. If the metric goes outside of these bounds, the system will
        try to bring it back within the bounds.
        If the bounds for a metric are [[`lower_1`, `upper_1`],
        [`lower_2`, `upper_2`]], then this metric's `value` needs to comply with
        the constraints
        `lower_1 <= value <= upper_1` OR `lower_2 <= value <= upper_2`.

        If multiple inclusion bounds have been provided for a metric, then the
        overlapping bounds are merged into a single bound, and non-overlapping
        bounds are kept separate.
        E.g. if the bounds are [[0, 10], [5, 15], [20, 30]], then the resulting
        bounds will be [[0, 15], [20, 30]].

        The following diagram illustrates how bounds are applied:
        ```
          lower_1  upper_1
        <----|========|--------|========|-------->
                            lower_2  upper_2
        ```
        The bounds in this example are `[[lower_1, upper_1], [lower_2, upper_2]]`.
        ---- values here are considered out of range.
        ==== values here are considered within range.

        Note that for power metrics, regardless of the bounds, 0W is always
        allowed.
        """

    @abc.abstractmethod
    def SetComponentPowerActive(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveResponse]]:
        """Sets the active power output of a component with a given ID, provided the
        component supports it. The power output is specified in watts.

        The power output can be -ve or +ve, depending on whether the component is
        supposed to be discharging or charging, respectively.

        The return value is the timestamp until which the given power command will
        stay in effect. After this timestamp, the component's active power will be
        set to 0, if the API receives no further command to change it before then.
        By default, this timestamp will be set to the current time plus 60 seconds.

        Note that the target component may have a resolution of more than 1 W.
        E.g., an inverter may have a resolution of 88 W.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Sends the discharge command to the inverter, making it deliver
         AC power.
        """

    @abc.abstractmethod
    def SetComponentPowerReactive(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveResponse, collections.abc.Awaitable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveResponse]]:
        """Sets the reactive power output of a component with a given ID, provided the
        component supports it. The power output is specified in VAr.

        We follow the polarity specified in the IEEE 1459-2010 standard
        definitions, where
        - positive reactive is inductive (current is lagging the voltage)
        - negative reactive is capacitive (current is leading the voltage)

        The return value is the timestamp until which the given power command will
        stay in effect. After this timestamp, the component's reactive power will
        be set to 0, if the API receives no further command to change it before
        then.
        By default, this timestamp will be set to the current time plus 60 seconds.

        Note that the target component may have a resolution of more than 1 VAr.
        E.g., an inverter may have a resolution of 88 VAr.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.
        """

    @abc.abstractmethod
    def StartComponent(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Starts the component, and brings it into a state where it is immediately
        operational.

        Performs the following sequence of actions for the following component
        categories:

        * Inverter:
         * closes DC relays, if the feature is available
         * closes AC relays
         * sets power output to 0

        * Battery: Checks if DC relays are open, then
         * closes DC relays

        * Relays:
         * closes relays

        * Precharge Modules:
         * starts the precharge process, and eventually closes the DC relays.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """

    @abc.abstractmethod
    def PutComponentInStandby(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sets the given component into a standby state, from which it can take a
        few minutes to return to an operational state. A transition to an
        operational state can be triggered by calling the `StartComponent` RPC, or
        the `SetComponentPowerActive` RPC.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Checks if AC and DC relays are closed, then
         * sets power to 0, and
         * opens AC relays

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call efffectively skips that action.
        """

    @abc.abstractmethod
    def StopComponent(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Stops the component completely, potentially disengaging its power
        electronics controller(s).

        Performs the following sequence actions for the following component
        categories:

        * Inverter:
         * Brings component to the cold-standby state
         * opens DC relays

        * Battery: Checks if the power output is 0, then
         * opens DC relays

        * Relays:
         * opens relays

        * Precharge Modules:
         * opens the DC relays.

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """

    @abc.abstractmethod
    def AckComponentError(
        self,
        request: frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Acknowledges any recoverable error reported by the component, and brings it
        back to the stopped or cold-standby state.
        """

def add_MicrogridServicer_to_server(servicer: MicrogridServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
