# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs2

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Configuration of a waitstate that occurs before transitioning to the next operating state 'state'.
# A waitstate represents a pause that is entered before switching to the next operating state 'state'.
# This waitstate can be cancelled before the timeout is reached by:
# - a component,
# - executing the cancel command, or
# - removing the waitstate from the waitstates configuration.
class WaitstateComponent(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = WaitstateComponent()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsWaitstateComponent(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # WaitstateComponent
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The operating state that follows the waitstate pause.
    # WaitstateComponent
    def State(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 2

    # A unique identifier defined by the requester of the waitstate.
    # WaitstateComponent
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Timeout in milliseconds before switching to the next operating state 'state' (0 = infinite, meaning the cancel command is executed or it is cancelled by a component).
    # WaitstateComponent
    def Timeout(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 1000

    # Flag indicating whether the waitstate is still active or has expired.
    # WaitstateComponent
    def Active(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return True

    # Save the waitstate component to the persistent storage.
    # WaitstateComponent
    def Save(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return True

def WaitstateComponentStart(builder): builder.StartObject(5)
def Start(builder):
    return WaitstateComponentStart(builder)
def WaitstateComponentAddState(builder, state): builder.PrependInt8Slot(0, state, 2)
def AddState(builder, state):
    return WaitstateComponentAddState(builder, state)
def WaitstateComponentAddName(builder, name): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def AddName(builder, name):
    return WaitstateComponentAddName(builder, name)
def WaitstateComponentAddTimeout(builder, timeout): builder.PrependUint64Slot(2, timeout, 1000)
def AddTimeout(builder, timeout):
    return WaitstateComponentAddTimeout(builder, timeout)
def WaitstateComponentAddActive(builder, active): builder.PrependBoolSlot(3, active, 1)
def AddActive(builder, active):
    return WaitstateComponentAddActive(builder, active)
def WaitstateComponentAddSave(builder, save): builder.PrependBoolSlot(4, save, 1)
def AddSave(builder, save):
    return WaitstateComponentAddSave(builder, save)
def WaitstateComponentEnd(builder): return builder.EndObject()
def End(builder):
    return WaitstateComponentEnd(builder)

class WaitstateComponentT(object):

    # WaitstateComponentT
    def __init__(self):
        self.state = 2  # type: int
        self.name = None  # type: str
        self.timeout = 1000  # type: int
        self.active = True  # type: bool
        self.save = True  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        waitstateComponent = WaitstateComponent()
        waitstateComponent.Init(buf, pos)
        return cls.InitFromObj(waitstateComponent)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, waitstateComponent):
        x = WaitstateComponentT()
        x._UnPack(waitstateComponent)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.state == other.state and \
            self.name == other.name and \
            self.timeout == other.timeout and \
            self.active == other.active and \
            self.save == other.save

    # WaitstateComponentT
    def _UnPack(self, waitstateComponent):
        if waitstateComponent is None:
            return
        self.state = waitstateComponent.State()
        self.name = waitstateComponent.Name()
        self.timeout = waitstateComponent.Timeout()
        self.active = waitstateComponent.Active()
        self.save = waitstateComponent.Save()

    # WaitstateComponentT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        WaitstateComponentStart(builder)
        WaitstateComponentAddState(builder, self.state)
        if self.name is not None:
            WaitstateComponentAddName(builder, name)
        WaitstateComponentAddTimeout(builder, self.timeout)
        WaitstateComponentAddActive(builder, self.active)
        WaitstateComponentAddSave(builder, self.save)
        waitstateComponent = WaitstateComponentEnd(builder)
        return waitstateComponent
