# -*- coding: utf-8 -*-
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# This is part of the Exudyn GUI project
#
# Filename: model/objectRegistry.py
#
# Description:
#     Dynamically builds the object registry used in the Exudyn GUI.
#     Registers all core item types (Object*, Node*, Marker*, etc.) and
#     Create* helper functions from Exudyn into a unified `registry`.
#     Enables generic GUI form construction, item creation, and code generation.
#
# Authors:  Michael Pieber
# Date:     2025-05-21
#
# License:  BSD-3 license
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import exudyn as exu
import inspect
import copy

from guiForms.autoGeneratedForm import AutoGeneratedForm
from core.debug import debugLog, deepSummarize
from functions import userFunctions as uf
from functions import graphicsVisualizations as gv
from core.fieldValidation import getValidator
from core.fieldMetadata import reconstructGraphicsDataList
from core.debug import summarizeDict, deepSummarize
from model.modelData import existingNames, generateUniqueName, getNextCreationIndex
from core.fieldMetadata import FieldMetadataBuilder
from core.fieldValidation import validateAndPrepareFields
from pprint import pformat
import exudyn.graphics as gfx
import exudyn.utilities as exuutils
import numpy as np
import copy

registry = {}
categorizedRegistry = {}
usedUIDs = set()

def normalizeKnownOptionals(kwargs):
    if kwargs.get('drawSize') is None:
        kwargs['drawSize'] = -1.0
    if kwargs.get('color') is None:
        kwargs['color'] = [-1., -1., -1., -1.]
    return kwargs



def normalizeKnownOptionals(kwargs):
    """Handle known optional fields that may be None or invalid in Exudyn."""
    if 'drawSize' in kwargs and kwargs['drawSize'] is None:
        kwargs['drawSize'] = -1.0
    if 'color' in kwargs and kwargs['color'] is None:
        kwargs['color'] = [-1.0, -1.0, -1.0, -1.0]
    if 'graphicsDataList' in kwargs and kwargs['graphicsDataList'] is None:
        kwargs['graphicsDataList'] = []
    if 'graphicsDataUserFunction' in kwargs and kwargs['graphicsDataUserFunction'] is None:
        kwargs['graphicsDataUserFunction'] = 0
    if 'show' in kwargs and kwargs['show'] is None:
        kwargs['show'] = True
    if 'create2D' in kwargs and kwargs['create2D'] is None:
        kwargs['create2D'] = False
    if 'gravity' in kwargs and kwargs['gravity'] is None:
        kwargs['gravity'] = [0.0, 0.0, 0.0]
    return kwargs               





        
def isNameUsed(mbs, name):
    try:
        mbs.GetObjectByName(name)
        return True
    except Exception:
        return False
    
def makeUniqueName(mbs, baseName):
    i = 0
    while True:
        name = f"{baseName}_{i}" if i > 0 else baseName
        try:
            mbs.GetObjectByName(name)
            i += 1
        except Exception:
            return name
    
    
def unwrapIndex(value):
    """Convert Exudyn index object(s) or list of them to int(s)."""
    if isinstance(value, list):
        return [unwrapIndex(v) for v in value]
    if hasattr(value, '__index__'):
        return int(value)
    return value

def wrapIndex(key, value):
    """Wrap int(s) into the correct Exudyn index class based on the key."""
    mapping = {
        'nodeNumber': exu.NodeIndex,
        'markerNumber': exu.MarkerIndex,
        'objectNumber': exu.ObjectIndex,
        'bodyNumber': exu.ObjectIndex,       # treat bodyNumber as ObjectIndex
        'loadNumber': exu.LoadIndex,
        'sensorNumber': exu.SensorIndex,
        'nodeNumbers': exu.NodeIndex,
        'markerNumbers': exu.MarkerIndex,
        'objectNumbers': exu.ObjectIndex,
        'bodyNumbers': exu.ObjectIndex,
        'loadNumbers': exu.LoadIndex,
        'sensorNumbers': exu.SensorIndex,
        'bodyOrNodeList': exu.ObjectIndex,  
        'bodyList': exu.ObjectIndex
    }

    cls = mapping.get(key)
    if cls is None:
        return value

    if isinstance(value, list):
        return [cls(v) if not isinstance(v, cls) else v for v in value]
    else:
        return cls(value) if not isinstance(value, cls) else value

CATEGORY_SORT_ORDER = [
    "Nodes",
    "Objects (Body)",
    "Objects (SuperElement)",
    "Objects (FiniteElement)",
    "Objects (Joint)",
    "Objects (Connector)",
    "Objects (Constraint)",
    "Objects (Object)",
    "Markers",
    "Loads",
    "Sensors",
]
    
def categorize(objType):
    # Manual overrides (always take priority)
    CATEGORY_OVERRIDES = {
        "ObjectConnectorDistance": "Objects (Constraint)",
        "ObjectConnectorCoordinate": "Objects (Constraint)",
        "ObjectConnectorCoordinateVector": "Objects (Constraint)",
        "ObjectConnectorCoordinateSpringDamper": "Objects (Constraint)",
        "ObjectConnectorCoordinateSpringDamperExt": "Objects (Constraint)",
        "ObjectConnectorCoordinateRevoluteJoint": "Objects (Constraint)",
        "ObjectConnectorCoordinateRigidBodySpringDamper": "Objects (Constraint)",
        "ObjectConnectorCoordinateSet": "Objects (Constraint)",

        "ObjectFFRF": "Objects (SuperElement)",
        "ObjectFFRFreducedOrder": "Objects (SuperElement)",
        "ObjectKinematicTree": "Objects (SuperElement)",
        "ObjectGenericODE2": "Objects (SuperElement)",
        "ObjectGenericODE1": "Objects (Object)",
    }

    if objType in CATEGORY_OVERRIDES:
        return CATEGORY_OVERRIDES[objType]

    if objType.startswith("Create"):
        return "Create (Helpers)"
    elif objType.startswith("Node"):
        return "Nodes"
    elif objType.startswith("Marker"):
        return "Markers"
    elif objType.startswith("Load"):
        return "Loads"
    elif objType.startswith("Sensor"):
        return "Sensors"
    elif objType.startswith("ObjectJoint"):
        return "Objects (Joint)"
    elif objType.startswith("ObjectConnectorContact") or objType.startswith("ObjectContact"):
        return "Objects (Connector)"
    elif objType.startswith("ObjectConnector"):
        return "Objects (Connector)"
    elif objType in {
        "ObjectANCFCable", "ObjectANCFCable2D", "ObjectALEANCFCable2D",
        "ObjectANCFBeam", "ObjectANCFThinPlate",
        "ObjectBeamGeometricallyExact", "ObjectBeamGeometricallyExact2D"
    }:
        return "Objects (FiniteElement)"
    elif objType.startswith("Object"):
        return "Objects (Body)"

    # fallback
    debugLog(f"[categorize] âš ï¸ Unknown category for '{objType}', defaulting to 'Other'", origin="objectRegistry.py")
    return "Other"



def getExudynIndexClass(fieldName):
    if "node" in fieldName.lower():
        return exu.NodeIndex
    elif "marker" in fieldName.lower():
        return exu.MarkerIndex
    elif "object" in fieldName.lower() or "body" in fieldName.lower():
        return exu.ObjectIndex
    elif "load" in fieldName.lower():
        return exu.LoadIndex
    elif "sensor" in fieldName.lower():
        return exu.SensorIndex
    else:
        return lambda x: x  # fallback: identity

def getAllTypes():
    from inspect import isclass
    return [
        name for name in dir(exu.itemInterface)
        if name.startswith(("Object", "Load", "Sensor", "Node", "Marker")) and
           isclass(getattr(exu.itemInterface, name))
    ]


def getCreateFunctions():
    """Return all Create* functions dynamically bound to a MainSystem instance."""
    mbs = exu.MainSystem()
    return [
        name for name in dir(mbs)
        if name.startswith("Create") and callable(getattr(mbs, name))
    ]

def normalizeExudynIndices(result):
    """Convert Exudyn index objects or lists of them to ints or lists of ints."""
    if isinstance(result, dict):
        for k, v in result.items():
            if isinstance(v, list):
                result[k] = [int(x) if hasattr(x, '__index__') else x for x in v]
            else:
                if hasattr(v, '__index__'):
                    result[k] = int(v)
    else:
        if hasattr(result, '__index__'):
            result = int(result)
    return result

import numpy as np


# --- Graphics Data Evaluation ---
from exudyn import graphics as g

def evaluateGraphicsDataList(dataList):
    import exudyn.graphics as gfx
    import numpy as np

    def convertRecursively(value):
        if isinstance(value, np.ndarray):
            return value.tolist()
        elif isinstance(value, np.generic):
            return float(value)
        elif isinstance(value, list):
            return [convertRecursively(v) for v in value]
        elif isinstance(value, dict):
            return {k: convertRecursively(v) for k, v in value.items()}
        else:
            return value

    out = []
    for entry in dataList:
        if isinstance(entry, dict) and 'name' in entry and 'args' in entry:
            try:
                fullCall = f"gfx.{entry['name']}({entry['args']})"
                gd = eval(fullCall, {"gfx": gfx, "np": np})
                gd = convertRecursively(gd)  # ðŸ‘ˆ ensures no np.float64 remains
                out.append(gd)
            except Exception as e:
                debugLog(f"[evaluateGraphicsDataList] âŒ Failed to evaluate {entry['name']}({entry['args']}): {e}")
    return out







def evaluateGraphicsEntry(entry):
    """Convert {'name': ..., 'args': ...} or 'exu.graphics.NAME(...)' into exu.graphics.GraphicsData* object."""
    import exudyn.graphics as gfx
    try:
        if isinstance(entry, dict) and 'name' in entry and 'args' in entry:
            # Old dict format
            funcName = entry['name']
            argsStr = entry['args']
            fullCall = f"gfx.{funcName}({argsStr})"
            return eval(fullCall, {"gfx": gfx, "np": np})
        elif isinstance(entry, str) and entry.startswith('exu.graphics.') and '(' in entry:
            # New compact string format like 'exu.graphics.Sphere(...)'
            # Convert to gfx.Sphere(...) format
            fullCall = entry.replace('exu.graphics.', 'gfx.')
            return eval(fullCall, {"gfx": gfx, "np": np})
        else:
            raise ValueError(f"Invalid graphics entry format: {entry}")
    except Exception as e:
        debugLog(f"[evaluateGraphicsEntry] âŒ Failed to evaluate entry: {entry} â†’ {e}", origin="objectRegistry.py")
        return None


def genericBuilder(mbs, item, snippet_vars=None):
    # Accepts a model item in the new structure: {'creationIndex', 'type', 'data', 'GUI'}
    # snippet_vars: Optional dict of variables from PythonSnippets
    if 'data' in item:
        data = item['data']
        gui = item.get('GUI', {})
    else:
        data = item
        gui = {}

    objType = item.get('type') or data.get('objectType')    # --- Typo guard: auto-correct common typos ---
    if isinstance(objType, str):
        original_objType = objType
        # Fix double letters in common Create* types
        if 'Creaate' in objType:
            objType = objType.replace('Creaate', 'Create')
        if 'CreateRiigid' in objType:
            objType = objType.replace('CreateRiigid', 'CreateRigid')
        if 'CreateMaassPoint' in objType:
            objType = objType.replace('CreateMaassPoint', 'CreateMassPoint')
        
        if objType != original_objType:
            debugLog(f"[genericBuilder] âš ï¸ Typo detected: '{original_objType}' corrected to '{objType}'", origin="objectRegistry.py")
            data['objectType'] = objType
            item['type'] = objType

    regEntry = registry.get(objType)
    exudyn_fields = set()
      # Use FieldMetadataBuilder to determine valid Exudyn fields
    from core.fieldMetadata import FieldMetadataBuilder
    builder = FieldMetadataBuilder()
    metaFields = builder.build(objType)
    if metaFields and isinstance(metaFields, dict):
        exudyn_fields = set(metaFields.keys())
        debugLog(f"[genericBuilder] Using FieldMetadataBuilder for {objType}: {exudyn_fields}", origin="objectRegistry.py")
    elif regEntry and hasattr(regEntry.get('form', None), 'exudynFields'):
        exudyn_fields = set(regEntry['form'].exudynFields)
        debugLog(f"[genericBuilder] Using form.exudynFields for {objType}: {exudyn_fields}", origin="objectRegistry.py")
    else:
        # fallback: use all keys except known GUI/metadata (but KEEP name - it's needed for Exudyn)
        exudyn_fields = set(data.keys()) - {'returnValues', 'returnInfo', 'objIndex', 'objectNumber', 'show', 'creationIndex', 'creationUID'}
        debugLog(f"[genericBuilder] Using fallback logic for {objType}: {exudyn_fields}", origin="objectRegistry.py")
          # Build kwargs for Exudyn creation: ONLY Exudyn fields
    debugLog(f"[genericBuilder] DEBUG: data.keys() = {list(data.keys())}", origin="objectRegistry.py")
    debugLog(f"[genericBuilder] DEBUG: exudyn_fields = {exudyn_fields}", origin="objectRegistry.py")
    debugLog(f"[genericBuilder] DEBUG: intersection = {set(data.keys()) & exudyn_fields}", origin="objectRegistry.py")
    kwargs = {k: v for k, v in data.items() if k in exudyn_fields}
    debugLog(f"[genericBuilder] exudyn_fields = {exudyn_fields}", origin="objectRegistry.py")
    debugLog(f"[genericBuilder] kwargs before patch = {kwargs}", origin="objectRegistry.py")
    
    # âœ… SENSOR FIXES: Apply sensor-specific fixes IMMEDIATELY after kwargs construction
    if objType.startswith('Sensor'):
        debugLog(f"[genericBuilder] ðŸ”§ Applying early sensor fixes for {objType}", origin="objectRegistry.py")
        
        # Fix 1: Ensure fileName is always a string (Exudyn requirement)
        if 'fileName' in kwargs and kwargs['fileName'] is None:
            kwargs['fileName'] = ""
            debugLog(f"[genericBuilder] ðŸ”§ Fixed sensor fileName: None -> empty string", origin="objectRegistry.py")
        
        # Fix 2: Remove GUI-only fields for sensors
        gui_only_fields = ['isLegacy', 'summaryPythonCode']
        for field in gui_only_fields:
            if field in kwargs:
                del kwargs[field]
                debugLog(f"[genericBuilder] ðŸ”§ Removed GUI-only field '{field}' for sensor", origin="objectRegistry.py")
        
        # Fix 3: Auto-generate fileName if writeToFile=True but fileName is empty
        if kwargs.get('writeToFile', False) and (not kwargs.get('fileName') or kwargs.get('fileName').strip() == ''):
            sensor_name = kwargs.get('name', 'sensor')
            output_type = kwargs.get('outputVariableType', 'output')
            auto_filename = f"{sensor_name}_{output_type}.txt"
            kwargs['fileName'] = auto_filename
            debugLog(f"[genericBuilder] ðŸ”§ Auto-generated fileName for sensor: {auto_filename}", origin="objectRegistry.py")
    
    # Always ensure 'name' is present in kwargs if in data
    if 'name' not in kwargs and 'name' in data:
        kwargs['name'] = data['name']
        debugLog(f"[genericBuilder] Patched 'name' into kwargs: {kwargs['name']}", origin="objectRegistry.py")
    debugLog(f"[genericBuilder] kwargs after patch = {kwargs}", origin="objectRegistry.py")
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ If there is a "Connection" key, strip/translate here â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #
    # data["Connection"] is one of: "bodyNumbers", "bodyOrNodeList", or "bodyList".
    # We must ensure that exactly one of those ends up in kwargs, and remove/translate the others.

    conn = data.get("Connection", None)
    if conn is not None:
        if conn == "bodyNumbers":
            # Keep only "bodyNumbers"; remove the other two if present
            kwargs.pop("bodyOrNodeList",   None)
            kwargs.pop("bodyList",         None)

        elif conn == "bodyOrNodeList":
            # Keep only "bodyOrNodeList"; remove the other two
            original = kwargs.pop("bodyOrNodeList", None)
            kwargs.pop("bodyNumbers",      None)
            kwargs.pop("bodyList",         None)
            # Translate to C++ Create: expect exactly two indices
            if isinstance(original, (list, tuple)) and len(original) == 2:
                kwargs["bodyNumbers"] = list(original)
            else:
                raise ValueError(
                    "When Connection='bodyOrNodeList', you must select exactly two bodies or nodes."
                )

        elif conn == "bodyList":
            # Keep only "bodyList"; remove the other two
            kwargs.pop("bodyNumbers",      None)
            kwargs.pop("bodyOrNodeList",   None)
            # Translate "bodyList" â†’ "bodyNumbers"
            body_list_val = kwargs.pop("bodyList", None)
            if isinstance(body_list_val, (list, tuple)) and len(body_list_val) == 2:
                kwargs["bodyNumbers"] = list(body_list_val)
            else:
                raise ValueError(
                    "When Connection='bodyList', you must select exactly two bodies."
                )
        else:
            # (if someone set Connection to anything else, just remove all three)
            kwargs.pop("bodyNumbers",      None)
            kwargs.pop("bodyOrNodeList",   None)
            kwargs.pop("bodyList",         None)

        # Finally, drop the "Connection" key itselfâ€”it's not a real parameter for the C++ call
        kwargs.pop("Connection", None)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Validate and autofill fields before Create call
    from core.fieldValidation import validateAndPrepareFields
    success, missingFields, failedFields = validateAndPrepareFields(mbs, objType, kwargs)
    if not success:
        debugLog(f"[genericBuilder] âŒ Validation failed for {objType}: missing={missingFields}, failed={failedFields}", origin="objectRegistry.py")
        raise ValueError(f"[{objType}] Invalid or missing fields: {missingFields if missingFields else ''} {failedFields if failedFields else ''}")    
    
    debugLog(f"[genericBuilder] ðŸ· Requested name: {data['name']} for {data['objectType']}", origin="objectRegistry.py")    # Only rename if this name was already added
    if isNameUsed(mbs, data['name']):
        # Use the full name as base (don't strip digits - preserve user intent)
        baseName = data['name']
        uniqueName = generateUniqueName(baseName)
        debugLog(f"[genericBuilder] ðŸ›‘ Duplicate name '{data['name']}' detected, renaming to '{uniqueName}'", origin="objectRegistry.py")
        data['name'] = uniqueName
        kwargs['name'] = uniqueName
    else:
        kwargs['name'] = data['name']

    # Remove any internal Exudyn instances from kwargs
    for k in list(kwargs):
        v = kwargs[k]
        if hasattr(v, '__class__') and 'exu' in str(v.__class__):
            debugLog(f"[genericBuilder] âš ï¸ Removing internal Exudyn object from field '{k}'", origin="objectRegistry.py")
            del kwargs[k]
     # Clean mutually exclusive body lists that are exactly [None,None]
    for key in ['bodyList', 'bodyOrNodeList']:
        if key in kwargs and all(v is None for v in kwargs[key]):
            del kwargs[key]

    # --- Patch: robustly handle ('body', idx) and ('node', idx) tuples for bodyOrNodeList ---
    if 'bodyOrNodeList' in kwargs:
        val = kwargs['bodyOrNodeList']
        if isinstance(val, list) and all(isinstance(x, tuple) and len(x) == 2 for x in val):
            # Split into separate lists for bodies and nodes if needed, or flatten to indices if required by Exudyn
            # Here, we flatten to indices, but you can adapt as needed for downstream code
            kwargs['bodyOrNodeList'] = [idx for (_type, idx) in val]

    sig = None
    allowedParams = set()  # Initialize allowedParams    # Resolve constructor and signature
    if objType.startswith("Create") and hasattr(mbs, objType):
        method = getattr(mbs, objType)
        kwargs['returnDict'] = True  # ensure returnDict for consistent return
        sig = inspect.signature(method)
        allowedParams = set(sig.parameters.keys())  # Always set allowedParams

        # âœ… CRITICAL FIX: Convert nodeType from string to actual enum value
        if 'nodeType' in kwargs and isinstance(kwargs['nodeType'], str):
            nodeType_str = kwargs['nodeType']
            try:
                # Handle various string formats for nodeType
                if nodeType_str.startswith('exu.NodeType.'):
                    # "exu.NodeType.RotationEulerParameters" -> exu.NodeType.RotationEulerParameters
                    enum_name = nodeType_str.replace('exu.NodeType.', '')
                    kwargs['nodeType'] = getattr(exu.NodeType, enum_name)
                elif nodeType_str.startswith('NodeType.'):
                    # "NodeType.RotationEulerParameters" -> exu.NodeType.RotationEulerParameters
                    enum_name = nodeType_str.replace('NodeType.', '')
                    kwargs['nodeType'] = getattr(exu.NodeType, enum_name)
                else:
                    # "RotationEulerParameters" -> exu.NodeType.RotationEulerParameters
                    kwargs['nodeType'] = getattr(exu.NodeType, nodeType_str)
                debugLog(f"[genericBuilder] âœ… Converted nodeType '{nodeType_str}' â†’ {kwargs['nodeType']}", origin="objectRegistry.py")
            except AttributeError as e:
                debugLog(f"[genericBuilder] âŒ Invalid nodeType '{nodeType_str}': {e}", origin="objectRegistry.py")
                # Remove invalid nodeType to prevent Exudyn error
                del kwargs['nodeType']

        if not any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values()):
            for key in list(kwargs.keys()):
                if key not in allowedParams:
                    debugLog(f"[genericBuilder] âš ï¸ Stripping unsupported parameter '{key}' for {objType}", origin="objectRegistry.py")
                    kwargs.pop(key)

            # Evaluate inertia field if present
            if 'inertia' in kwargs and isinstance(kwargs['inertia'], str):
                inertiaScope = {}
                inertiaScope.update(vars(exuutils))  # include RigidBodyInertia etc.
                inertiaScope['exuutils'] = exuutils  # ensure exuutils is in scope
                inertiaStr = kwargs['inertia']
                if not inertiaStr.strip().startswith('exuutils.'):
                    inertiaStr = f"exuutils.{inertiaStr}"
                try:
                    kwargs['inertia'] = eval(inertiaStr, inertiaScope)
                    debugLog(f"[genericBuilder] âœ… inertia = {kwargs['inertia']}", origin="objectRegistry.py")
                except Exception as e:
                    debugLog(f"[genericBuilder] âŒ Could not eval inertia: {e}", origin="objectRegistry.py")
                    kwargs['inertia'] = None  # or raise, depending on design            # Handle graphics data list cleanup
            if 'graphicsDataList' in allowedParams:
                evaluatedGD = [
                    evaluateGraphicsEntry(e) for e in kwargs.get('graphicsDataList', [])
                    if isinstance(e, (dict, str))  # Accept both dict and string formats
                ]
                kwargs['graphicsDataList'] = [g for g in evaluatedGD if g is not None]
            else:
                kwargs.pop('graphicsDataList', None)
                debugLog(f"[genericBuilder] âš ï¸ Removed graphicsDataList (not in allowed params)", origin="objectRegistry.py")
        
        # Always clean up returnDict for Create* methods if not supported
        if 'returnDict' not in allowedParams:
            kwargs.pop('returnDict', None)
            debugLog(f"[genericBuilder] âš ï¸ Removed returnDict (not in allowed params)", origin="objectRegistry.py")

    # Log stored data before graphicsData evaluation
    dataForDebug = copy.deepcopy(data)
    if 'graphicsDataList' in dataForDebug:
        dataForDebug['graphicsDataList'] = deepSummarize(dataForDebug['graphicsDataList'], maxListLen=3)
    debugLog(f"[genericBuilder] âœ… Final stored data:\n{pformat(dataForDebug)}", origin="objectRegistry.py")


    try:
        # Debug-clean graphicsDataList
        kwargsForDebug = copy.deepcopy(kwargs)
        if 'graphicsDataList' in kwargsForDebug:
            cleanedGDList = []
            for entry in kwargsForDebug['graphicsDataList']:
                if isinstance(entry, dict):
                    cleanedGDList.append({k: v for k, v in entry.items() if k != 'object'})
                else:
                    cleanedGDList.append(entry)
            kwargsForDebug['graphicsDataList'] = deepSummarize(cleanedGDList, maxListLen=2)
        
        debugLog(f"[genericBuilder] ðŸ“¥ INPUT kwargs for {objType}:\n{pformat(kwargsForDebug)}", origin="objectRegistry.py")
        
        # Use the allowedParams from metaFields built earlier
        allowedParams = exudyn_fields  # We already have the valid fields from FieldMetadataBuilder
        
        if not allowedParams:
            try:
                sig = inspect.signature(getattr(mbs, objType))
                allowedParams = set(sig.parameters.keys())
                debugLog(f"[genericBuilder] â„¹ï¸ Fallback to inspect.signature() for {objType}", origin="objectRegistry.py")
            except Exception as e:
                debugLog(f"[genericBuilder] âš ï¸ Could not inspect signature for {objType}: {e}", origin="objectRegistry.py")
                allowedParams = set()
                
        for key in list(kwargs.keys()):
            if key not in allowedParams:
                debugLog(f"[genericBuilder] âš ï¸ Removing unsupported param '{key}'", origin="objectRegistry.py")
                del kwargs[key]

        if 'graphicsDataUserFunction' in kwargs:
            val = kwargs['graphicsDataUserFunction']
            if val in ['None', '', None]:
                kwargs['graphicsDataUserFunction'] = 0
                debugLog(f"[genericBuilder] ðŸ§¹ Cleaned graphicsDataUserFunction to 0", origin="objectRegistry.py")

        # --- Wrap indices before calling method ---
        for k in list(kwargs):
            if k in ['bodyNumbers', 'bodyOrNodeList', 'bodyList']:
                kwargs[k] = wrapIndex(k, kwargs[k])
        
        # Convert any "rotationMatrix" fields from lists into numpy arrays
        for matKey in ('referenceRotationMatrix', 'initialRotationMatrix'):
            if matKey in kwargs and isinstance(kwargs[matKey], list):
                try:
                    kwargs[matKey] = np.array(kwargs[matKey], dtype=float)
                except Exception as e:
                    debugLog(f"[genericBuilder] âš ï¸ Could not convert {matKey} to np.array: {e}", origin="objectRegistry.py")
        
        
        # â”€â”€â”€ unwrap inertia dict into a real RigidBodyInertia â”€â”€â”€
        if "inertia" in kwargs and isinstance(kwargs["inertia"], dict):
            entry = kwargs["inertia"]
            iname = entry.get("name","")
            iargs = entry.get("args","")
            
            # Clean up args string: remove None parameters
            if iargs:
                # Split args and filter out None values
                args_parts = []
                for part in iargs.split(','):
                    part = part.strip()
                    if part and not part.endswith('=None') and not part.endswith('= None'):
                        args_parts.append(part)
                iargs = ', '.join(args_parts)
            
            try:
                # Always resolve as exuutils.INERTIANAME(args) for both modern and legacy
                constructor = getattr(exuutils, iname)
                inert_obj = eval(f"constructor({iargs})", {"constructor": constructor, "np": np, "exuutils": exuutils})
                kwargs["inertia"] = inert_obj
            except Exception as e:
                debugLog(f"[genericBuilder] âŒ Could not build inertia '{iname}({iargs})': {e}", origin="objectRegistry.py")
                kwargs["inertia"] = None
          # Get user variables for evaluation
        from exudynGUI.core.variableManager import (
            parseUserVariables,
            getLiveUserVariableText,
            evaluateExpression,
            resolveSymbolicExpressions,
        )
        
        user_text = getLiveUserVariableText()
        user_vars = parseUserVariables(user_text)
        
        # Combine user variables with snippet variables
        combined_vars = user_vars.copy()
        if snippet_vars:
            combined_vars.update(snippet_vars)
            debugLog(f"[genericBuilder] ðŸ“ Combined variables: user={list(user_vars.keys())}, snippet={list(snippet_vars.keys())}", origin="objectRegistry.py")
        
        try:            # Build a mapping from symbolic variable names to actual integer values
            # by scanning the current model sequence for returnValues
            from model.modelData import modelSequence
            symbol_to_index = {}
            
            # Build the mapping from returnValues in existing objects
            for existing_item in modelSequence:
                data_section = existing_item.get('data', {})
                gui_section = existing_item.get('GUI', {})
                
                # Check both data and GUI sections for returnValues
                return_vals = gui_section.get('returnValues', data_section.get('returnValues', {}))
                obj_name = data_section.get('name', '')
                
                if return_vals and obj_name:
                    for key, value in return_vals.items():
                        if isinstance(value, int):
                            symbol_name = f"{obj_name}_{key}"
                            symbol_to_index[symbol_name] = value            # 1) Evaluate any single-string fields "m" â†’ number, etc.
            # AND resolve symbolic variable names to their actual integer values
            for key, val in list(kwargs.items()):
                if isinstance(val, str):
                    # First check if it's a symbolic variable name that we can resolve
                    if val in symbol_to_index:
                        kwargs[key] = symbol_to_index[val]
                        debugLog(f"[genericBuilder] âœ… Resolved symbolic variable '{val}' â†’ {symbol_to_index[val]} (field: {key})", origin="objectRegistry.py")
                    else:
                        # Skip symbolic variable names that we can't resolve
                        symbolic_suffixes = ['_nodeNumber', '_markerNumber', '_objectNumber', '_bodyNumber', '_loadNumber', '_sensorNumber']
                        is_symbolic = any(val.endswith(suffix) for suffix in symbolic_suffixes) and '_' in val
                        
                        if not is_symbolic:
                            try:
                                # âœ… ENHANCED: Use combined variables (user + snippet)
                                kwargs[key] = evaluateExpression(val, combined_vars)
                                debugLog(f"[genericBuilder] âœ… Resolved variable '{val}' â†’ {kwargs[key]} (field: {key})", origin="objectRegistry.py")
                            except Exception as e:
                                debugLog(f"[genericBuilder] âš ï¸ Could not resolve variable '{val}' (field: {key}): {e}", origin="objectRegistry.py")
                                pass
                        else:
                            debugLog(f"[genericBuilder] âš ï¸ Cannot resolve symbolic variable '{val}' (field: {key}) - object may not exist yet", origin="objectRegistry.py")
            
            # 2) Also handle lists that might contain symbolic variable names            for key, val in list(kwargs.items()):
                if isinstance(val, list):
                    resolved_list = []
                    for list_item in val:  # Changed from 'item' to 'list_item' to avoid shadowing
                        if isinstance(list_item, str) and list_item in symbol_to_index:
                            resolved_list.append(symbol_to_index[list_item])
                            debugLog(f"[genericBuilder] âœ… Resolved symbolic variable in list '{list_item}' â†’ {symbol_to_index[list_item]} (field: {key})", origin="objectRegistry.py")
                        else:
                            resolved_list.append(list_item)
                    kwargs[key] = resolved_list
            
            # 3) Do NOT run resolveSymbolicExpressions during object execution
            # This should only be used for code generation, not actual object creation
            debugLog(f"[genericBuilder] â„¹ï¸ Skipping resolveSymbolicExpressions for object execution", origin="objectRegistry.py")
        except:
            pass




        
        # --- DEBUG: Log offset type/value before Exudyn call ---
        if 'offset' in kwargs:
            debugLog(f"[genericBuilder] [DEBUG] Before Exudyn call: offset type={type(kwargs['offset'])}, value={kwargs['offset']}", origin="objectRegistry.py")
        
        # Finally call the Create* function:
        if objType.startswith("Create") and hasattr(mbs, objType):
            
            # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Delete "distance" if it is None â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
            if objType == "CreateDistanceConstraint":
                if "distance" in kwargs and kwargs["distance"] is None:
                    del kwargs["distance"]
            # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”            
            
            debugLog(f"[genericBuilder] ðŸ”§ Calling {objType} with kwargs: {kwargs}", origin="objectRegistry.py")
            result = method(**kwargs)
            debugLog(f"[genericBuilder] ðŸ“‹ Raw result from {objType}: {result} (type: {type(result)})", origin="objectRegistry.py")
            result = {k: unwrapIndex(v) for k, v in result.items()} if isinstance(result, dict) else unwrapIndex(result)
            if not isinstance(result, dict):
                # If the wrapper gave us [objIndex, marker0, marker1], extract the first entry.
                if isinstance(result, list) and len(result) >= 1:
                    objIdx = result[0]
                else:
                    objIdx = int(result)   # fallback if it really is a single integer
                
                # âœ… CRITICAL FIX: Use the correct return value key based on the Create function type
                if objType == "CreateForce":
                    result = {'loadNumber': objIdx}
                elif objType in ["CreateSensor", "CreateSensorBody", "CreateSensorNode", "CreateSensorMarker", "CreateSensorObject"]:
                    result = {'sensorNumber': objIdx}
                elif objType.startswith("CreateNode"):
                    result = {'nodeNumber': objIdx}
                elif objType.startswith("CreateMarker"):
                    result = {'markerNumber': objIdx}
                elif objType.startswith("CreateBody") or objType in ["CreateMassPoint", "CreateRigidBody"]:
                    result = {'bodyNumber': objIdx}
                else:
                    # Default to objectNumber for other Create* functions
                    result = {'objectNumber': objIdx}
                    
                debugLog(f"[genericBuilder] ðŸ”„ Converted result to: {result} for {objType}", origin="objectRegistry.py")
        
            existingNames.add(data['name'])
            data['creationIndex'] = data.get('creationIndex', getNextCreationIndex())
            returnValues = result if isinstance(result, dict) else {'objectNumber': result}
            
            for k in ['objectNumber', 'bodyNumber', 'nodeNumber', 'markerNumber', 'sensorNumber', 'loadNumber', 'systemDataNumber']:
                if k in returnValues:
                    objIndex = returnValues[k]
                    break
            else:
                objIndex = None
                
            # Store return values and info in GUI, not data
            if 'GUI' not in item:
                item['GUI'] = {}
                
            # âœ… PRESERVE ACTUAL RETURN VALUES: Don't "correct" them, use what Exudyn actually returns
            # The GUI returnValues reflect the real Exudyn API response
            # âœ… CRITICAL FIX: Ensure all returnValues are integers, not strings or Exudyn index objects
            fixed_returnValues = {}
            for k, v in returnValues.items():
                if isinstance(v, str) and v.isdigit():
                    fixed_returnValues[k] = int(v)
                elif isinstance(v, (int, float)):
                    fixed_returnValues[k] = int(v)
                elif hasattr(v, '__index__'):  # Handle Exudyn index objects like NodeIndex, ObjectIndex
                    fixed_returnValues[k] = int(v)
                else:
                    fixed_returnValues[k] = v
            
            item['GUI']['returnValues'] = fixed_returnValues
            debugLog(f"[objectRegistry] ðŸ“ Stored actual returnValues in GUI (fixed to integers): {fixed_returnValues}", origin="objectRegistry.py")
            item['GUI']['objIndex'] = objIndex
            item['GUI']['returnInfo'] = (
                " / ".join(f"{k}={v}" for k, v in returnValues.items() if isinstance(v, int))
                if isinstance(returnValues, dict) else f"Created ID {objIndex}"
            )
            
            preferredKey = next((k for k in ['objectNumber', 'bodyNumber', 'nodeNumber', 'markerNumber', 'sensorNumber', 'loadNumber'] if k in returnValues), None)
            # Don't add return values to data - they should only be in returnValues!
        
            if objIndex is not None:
                try:
                    if objIndex == 0:
                        debugLog(f"[genericBuilder] âš ï¸ objIndex=0 (special ground or invalid), skipping GetObject call", origin="objectRegistry.py")
                    else:
                        # Use appropriate getter method based on what type of entity this is
                        if preferredKey == 'loadNumber':
                            # For loads, use GetLoad instead of GetObject
                            mbs.GetLoad(objIndex)
                            debugLog(f"[genericBuilder] âœ… Confirmed load exists: ID {objIndex}", origin="objectRegistry.py")
                        elif preferredKey == 'nodeNumber':
                            # For nodes, use GetNode instead of GetObject
                            mbs.GetNode(objIndex)
                            debugLog(f"[genericBuilder] âœ… Confirmed node exists: ID {objIndex}", origin="objectRegistry.py")
                        elif preferredKey == 'markerNumber':
                            # For markers, use GetMarker instead of GetObject
                            mbs.GetMarker(objIndex)
                            debugLog(f"[genericBuilder] âœ… Confirmed marker exists: ID {objIndex}", origin="objectRegistry.py")
                        elif preferredKey == 'sensorNumber':
                            # For sensors, use GetSensor instead of GetObject
                            mbs.GetSensor(objIndex)
                            debugLog(f"[genericBuilder] âœ… Confirmed sensor exists: ID {objIndex}", origin="objectRegistry.py")
                        else:
                            # For objects and bodies, use GetObject
                            mbs.GetObject(objIndex)
                            debugLog(f"[genericBuilder] âœ… Confirmed object exists: ID {objIndex}", origin="objectRegistry.py")
                except Exception as e:
                    debugLog(f"[genericBuilder] âš ï¸ Entity with ID {objIndex} (type: {preferredKey}) not accessible: {e}", origin="objectRegistry.py")
        
            debugLog(f"[genericBuilder] âœ… Result registered: objIndex={objIndex}, returnValues={data.get('returnValues')}", origin="objectRegistry.py")
            return result
    
    except Exception as e:
        debugLog(f"[genericBuilder] âŒ Exception while calling {objType}: {e}", origin="objectRegistry.py")
        # --- Prevent legacy fallback for Create* types ---
        if isinstance(objType, str) and objType.startswith("Create"):
            raise RuntimeError(f"[genericBuilder] âŒ Could not create object of type '{objType}'. This is a Create* type and cannot be handled by the legacy builder. Error: {e}")
        # ...existing code for legacy fallback...
    
    
   
    
   
    
   
    try:  # === LEGACY BUILDER ===
    
        import re
        debugLog(f"[genericBuilder] ðŸŒ€ Entering fallback legacy builder for {objType}", origin="objectRegistry.py")
    
        match = re.match(r"^(Object|Node|Marker|Load|Sensor)(.+)", objType)
        if not match:
            raise ValueError(f"[genericBuilder] âŒ Unrecognized legacy objectType format: {objType}")
    
        prefix, shortType = match.groups()
        addMethod = getattr(mbs, f"Add{prefix}", None)
        getDefaults = getattr(mbs, f"Get{prefix}Defaults", None)
    
        if not addMethod or not getDefaults:
            raise ValueError(f"[genericBuilder] âŒ Add or GetDefaults method not found for prefix: {prefix}")
    
        # Clean optionals
        kwargs = normalizeKnownOptionals(kwargs)        # Filter unsupported fields
        try:
            defaultFields = getDefaults(shortType)
            debugLog(f"[legacyBuilder] ðŸ” Default fields for {shortType}: {list(defaultFields.keys())}", origin="objectRegistry.py")
            for k in list(kwargs.keys()):
                if k not in defaultFields:
                    debugLog(f"[legacyBuilder] âš ï¸ Removing unsupported param '{k}' for {prefix}{shortType}", origin="objectRegistry.py")
                    del kwargs[k]
        except Exception as e:
            debugLog(f"[legacyBuilder] âš ï¸ Could not get default fields for {shortType}: {e}", origin="objectRegistry.py")
    
        # âœ… SENSOR FIXES: Apply sensor-specific fixes in legacy builder
        if prefix == 'Sensor':
            debugLog(f"[legacyBuilder] ðŸ”§ Applying sensor fixes for {prefix}{shortType}", origin="objectRegistry.py")
            
            # Fix 1: Ensure fileName is always a string (Exudyn requirement)
            if 'fileName' in kwargs and kwargs['fileName'] is None:
                kwargs['fileName'] = ""
                debugLog(f"[legacyBuilder] ðŸ”§ Fixed sensor fileName: None -> empty string", origin="objectRegistry.py")
            
            # Fix 2: Remove GUI-only fields for sensors
            gui_only_fields = ['isLegacy', 'summaryPythonCode']
            for field in gui_only_fields:
                if field in kwargs:
                    del kwargs[field]
                    debugLog(f"[legacyBuilder] ðŸ”§ Removed GUI-only field '{field}' for sensor", origin="objectRegistry.py")
            
            # Fix 3: Auto-generate fileName if writeToFile=True but fileName is empty
            if kwargs.get('writeToFile', False) and (not kwargs.get('fileName') or kwargs.get('fileName').strip() == ''):
                sensor_name = kwargs.get('name', 'sensor')
                output_type = kwargs.get('outputVariableType', 'output')
                auto_filename = f"{sensor_name}_{output_type}.txt"
                kwargs['fileName'] = auto_filename
                debugLog(f"[legacyBuilder] ðŸ”§ Auto-generated fileName for sensor: {auto_filename}", origin="objectRegistry.py")
    
        # === Build visualization dict ===
        val = kwargs.pop('VgraphicsData', None)
        visDict = {}
        if isinstance(val, list) and val:
            gdList = evaluateGraphicsDataList(val)
            # from debug import shortenLargeFields
            debugLog(f"[legacyBuilder] ðŸ§© Evaluated graphicsData: {deepSummarize(gdList)}", origin="objectRegistry.py")
            visDict['graphicsData'] = gdList
    
            for k in ['Vshow', 'VgraphicsDataUserFunction']:
                if k in kwargs:
                    visDict[k[1:]] = kwargs.pop(k)        # === Construct item as dict ===
        objDict = copy.deepcopy(kwargs)
        objDict['objectType'] = shortType
        objDict['visualization'] = visDict
        
        # âœ… Set the correct type field based on prefix
        if prefix == 'Node':
            objDict['nodeType'] = shortType
        elif prefix == 'Marker':
            objDict['markerType'] = f"{prefix}{shortType}"  # Keep full name for markers
        elif prefix == 'Load':
            objDict['loadType'] = shortType
        elif prefix == 'Sensor':
            objDict['sensorType'] = shortType
            
        # âœ… Ensure name field is preserved from original data if not in kwargs
        if 'name' not in objDict or objDict['name'] is None:
            if 'name' in data and data['name'] is not None:
                objDict['name'] = data['name']
                debugLog(f"[legacyBuilder] ðŸ·ï¸ Preserved name from data: '{data['name']}'", origin="objectRegistry.py")
        
        # Optional assert (only if graphicsData exists)
        if 'graphicsData' in visDict and visDict['graphicsData']:
            gd = visDict['graphicsData'][0]
            if not isinstance(gd, dict) or 'type' not in gd:
                raise AssertionError(f"âŒ Invalid graphicsData format: {gd}")
        
        # ðŸ§¼ Patch: convert graphicsDataUserFunction = 0 â†’ None
        vis = objDict["visualization"]
        if vis.get("graphicsDataUserFunction", 0) == 0:
            vis["graphicsDataUserFunction"] = None
            debugLog(f"[legacyBuilder] ðŸ§¼ Patched graphicsDataUserFunction=0 â†’ None", origin="objectRegistry.py")
          # âœ… Rebuild evaluated graphicsData from metadata
        if 'VgraphicsData' in data and data['VgraphicsData'] is not None:
            graphicsData = evaluateGraphicsDataList(data['VgraphicsData'])
            objDict["visualization"]["graphicsData"] = graphicsData
            debugLog(f"[legacyBuilder] ðŸ” Evaluated VgraphicsData â†’ {len(graphicsData)} items", origin="objectRegistry.py")
          # âœ… Ensure show=True if graphics present but no explicit show flag
        if 'graphicsData' in vis and 'show' not in vis:
            vis['show'] = True
        
        # Legacy patch: copy evaluated graphics to VgraphicsData for AddObject
        if 'VgraphicsData' not in objDict and 'visualization' in objDict:
            vis = objDict['visualization']
            if isinstance(vis.get('graphicsData'), list):
                objDict['VgraphicsData'] = vis['graphicsData']
                debugLog(f"[legacyBuilder] ðŸ“¦ Patched VgraphicsData = visualization['graphicsData']", origin="objectRegistry.py")

        # --- Attach summaryPythonCode for legacy items ---
        summary_dict = {}
        # Use the actual field name for graphics data (VgraphicsData)
        vgd = data.get('VgraphicsData', [])
        if vgd:
            formatted_vgd = []
            for gEntry in vgd:
                if isinstance(gEntry, dict):
                    name = gEntry.get('name', '?')
                    args = gEntry.get('args', '')
                    formatted_vgd.append(f"{name}({args})")
                else:
                    formatted_vgd.append(str(gEntry))
            summary_dict['VgraphicsData'] = formatted_vgd
        # Add inertia summary if present
        inertia = objDict.get('inertia', None)
        if inertia is not None:
            if isinstance(inertia, dict):
                iname = inertia.get('name', '?')
                iargs = inertia.get('args', '')
                summary_dict['inertia'] = f"{iname}({iargs})"
            else:
                summary_dict['inertia'] = str(inertia)        # Add nodeType if present
        nodeType = objDict.get('nodeType', None)
        if nodeType is not None:
            summary_dict['nodeType'] = str(nodeType)
            
        # Add outputVariableType for sensors
        outputVariableType = objDict.get('outputVariableType', None)
        if outputVariableType is not None and prefix == 'Sensor':
            summary_dict['outputVariableType'] = f"exu.OutputVariableType.{outputVariableType}"
            
        if summary_dict:
            data['summaryPythonCode'] = summary_dict# âœ… Filter out GUI-only fields before calling addMethod
        GUI_ONLY_FIELDS = {'summaryPythonCode', 'isLegacy'}
        
        # âœ… Keep required type fields for Exudyn API calls
        if prefix != 'Object':
            GUI_ONLY_FIELDS.add('objectType')  # Only exclude objectType for non-Object items
        if prefix != 'Node':
            GUI_ONLY_FIELDS.add('nodeType')    # Only exclude nodeType for non-Node items
        if prefix != 'Marker':
            GUI_ONLY_FIELDS.add('markerType')  # Only exclude markerType for non-Marker items
        if prefix != 'Load':
            GUI_ONLY_FIELDS.add('loadType')    # Only exclude loadType for non-Load items
        if prefix != 'Sensor':
            GUI_ONLY_FIELDS.add('sensorType')  # Only exclude sensorType for non-Sensor items
        
        filtered_objDict = {k: v for k, v in objDict.items() if k not in GUI_ONLY_FIELDS}
        
        # âœ… Ensure nodeType is a string for AddNode (remove GUI prefixes)
        if 'nodeType' in filtered_objDict and prefix == 'Node':
            nodeType_value = filtered_objDict['nodeType']
            if isinstance(nodeType_value, str):
                # Remove 'Node' prefix if present (NodePoint -> Point)  
                if nodeType_value.startswith('Node'):
                    filtered_objDict['nodeType'] = nodeType_value[4:]  # Remove 'Node' prefix
                debugLog(f"[legacyBuilder] âœ… Using nodeType as string: '{filtered_objDict['nodeType']}'", origin="objectRegistry.py")
          # âœ… Ensure objectType is a string for AddObject (remove GUI prefixes)
        if 'objectType' in filtered_objDict and prefix == 'Object':
            objectType_value = filtered_objDict['objectType']
            if isinstance(objectType_value, str):
                # Remove 'Object' prefix if present (ObjectMassPoint -> MassPoint)
                if objectType_value.startswith('Object'):
                    filtered_objDict['objectType'] = objectType_value[6:]  # Remove 'Object' prefix
                debugLog(f"[legacyBuilder] âœ… Using objectType as string: '{filtered_objDict['objectType']}'", origin="objectRegistry.py")
        
        # âœ… Ensure markerType is a string for AddMarker (remove GUI prefixes)
        if 'markerType' in filtered_objDict and prefix == 'Marker':
            markerType_value = filtered_objDict['markerType']
            if isinstance(markerType_value, str):
                # Remove 'Marker' prefix if present (MarkerNodeCoordinate -> NodeCoordinate)
                if markerType_value.startswith('Marker'):
                    filtered_objDict['markerType'] = markerType_value[6:]  # Remove 'Marker' prefix
                debugLog(f"[legacyBuilder] âœ… Using markerType as string: '{filtered_objDict['markerType']}'", origin="objectRegistry.py")
        
        # âœ… Ensure loadType is a string for AddLoad (remove GUI prefixes)
        if 'loadType' in filtered_objDict and prefix == 'Load':
            loadType_value = filtered_objDict['loadType']
            if isinstance(loadType_value, str):
                # Remove 'Load' prefix if present (LoadForceVector -> ForceVector)
                if loadType_value.startswith('Load'):
                    filtered_objDict['loadType'] = loadType_value[4:]  # Remove 'Load' prefix
                debugLog(f"[legacyBuilder] âœ… Using loadType as string: '{filtered_objDict['loadType']}'", origin="objectRegistry.py")
        
        # âœ… Ensure sensorType is a string for AddSensor (remove GUI prefixes)
        if 'sensorType' in filtered_objDict and prefix == 'Sensor':
            sensorType_value = filtered_objDict['sensorType']
            if isinstance(sensorType_value, str):
                # Remove 'Sensor' prefix if present (SensorNode -> Node)
                if sensorType_value.startswith('Sensor'):
                    filtered_objDict['sensorType'] = sensorType_value[6:]  # Remove 'Sensor' prefix
                debugLog(f"[legacyBuilder] âœ… Using sensorType as string: '{filtered_objDict['sensorType']}'", origin="objectRegistry.py")

        # âœ… Patch: convert outputVariableType string to enum for AddSensor
        if prefix == 'Sensor' and 'outputVariableType' in filtered_objDict:
            ovt = filtered_objDict['outputVariableType']
            if isinstance(ovt, str):
                try:
                    filtered_objDict['outputVariableType'] = getattr(exu.OutputVariableType, ovt)
                    debugLog(f"[legacyBuilder] âœ… Converted outputVariableType string '{ovt}' to enum", origin="objectRegistry.py")
                except Exception as e:
                    debugLog(f"[legacyBuilder] âŒ Could not convert outputVariableType '{ovt}' to enum: {e}", origin="objectRegistry.py")

        # ðŸ” Show full mbs.AddObject(...) line for debugging
        debugLog("[legacyBuilder] ðŸ§¾ Final creation line:\n"
                 + f"mbs.{addMethod.__name__}(\n{pformat(deepSummarize(filtered_objDict), indent=4)})",
                 origin="objectRegistry.py")
        
        for g in filtered_objDict['visualization'].get("graphicsData", []):            debugLog("âœ” graphics entry type:", type(g), "â†’", str(g)[:100])
        
        debugLog("ðŸ“¦ [DEBUG] Final objDict passed to mbs.Add*():")
        debugLog(pformat(deepSummarize(filtered_objDict)))
        
        # âœ… DEBUG: Always log sensor processing
        if 'Sensor' in str(objType) or prefix == 'Sensor':
            debugLog(f"[objectRegistry] ðŸš¨ SENSOR DEBUG: objType={objType}, prefix={prefix}", origin="objectRegistry.py")
            debugLog(f"[objectRegistry] ðŸš¨ SENSOR DEBUG: filtered_objDict={filtered_objDict}", origin="objectRegistry.py")
        
        # âœ… General fix: Ensure fileName is always a string for sensors (Exudyn requirement)
        if prefix == 'Sensor' and 'fileName' in filtered_objDict:
            if filtered_objDict['fileName'] is None:
                filtered_objDict['fileName'] = ""
                debugLog(f"[objectRegistry] ðŸ”§ Fixed sensor fileName: None -> empty string", origin="objectRegistry.py")
        
        # âœ… Validate sensor-specific logic: writeToFile requires a valid fileName
        debugLog(f"[objectRegistry] ðŸ” About to check sensor validation - prefix={prefix}", origin="objectRegistry.py")
        debugLog(f"[objectRegistry] ðŸ” filtered_objDict keys: {list(filtered_objDict.keys())}", origin="objectRegistry.py")
        debugLog(f"[objectRegistry] ðŸ” writeToFile in filtered_objDict: {'writeToFile' in filtered_objDict}", origin="objectRegistry.py")
        debugLog(f"[objectRegistry] ðŸ” fileName in filtered_objDict: {'fileName' in filtered_objDict}", origin="objectRegistry.py")
        
        if prefix == 'Sensor' and 'writeToFile' in filtered_objDict and 'fileName' in filtered_objDict:
            write_to_file = filtered_objDict.get('writeToFile', False)
            file_name = filtered_objDict.get('fileName')
            
            debugLog(f"[objectRegistry] ðŸ” Sensor validation: writeToFile={write_to_file}, fileName={repr(file_name)}", origin="objectRegistry.py")
            
            # Fix: Ensure fileName is always a string for Exudyn compatibility
            if file_name is None:
                filtered_objDict['fileName'] = ""
                file_name = ""
                debugLog(f"[objectRegistry] ðŸ”§ Fixed fileName None -> empty string", origin="objectRegistry.py")
            
            if write_to_file and (file_name == '' or str(file_name).strip() == ''):
                # Auto-generate filename if writeToFile is True but no fileName provided
                sensor_name = filtered_objDict.get('name', 'sensor')
                output_type = filtered_objDict.get('outputVariableType', 'output')
                # If output_type is an enum, get its name
                if hasattr(output_type, 'name'):
                    output_type_str = output_type.name
                else:
                    output_type_str = str(output_type)
                auto_filename = f"{sensor_name}_{output_type_str}.txt"
                filtered_objDict['fileName'] = auto_filename
                debugLog(f"[objectRegistry] ðŸ”§ Auto-generated fileName for sensor: {auto_filename}", origin="objectRegistry.py")
            elif not write_to_file and file_name is not None:
                # If writeToFile is False, ensure fileName is empty string (Exudyn expects string, not None)
                filtered_objDict['fileName'] = ''  # Exudyn expects empty string
                debugLog(f"[objectRegistry] ðŸ”§ Set fileName to empty string since writeToFile=False", origin="objectRegistry.py")
          # âœ… Actually add object
        objIndex = addMethod(filtered_objDict)
        
        # ðŸ”¢ Store return info
        preferredKey = {
            "Object": "objectNumber",
            "Node": "nodeNumber",
            "Marker": "markerNumber",
            "Load": "loadNumber",
            "Sensor": "sensorNumber"
        }.get(prefix, "objectNumber")        
        data["objIndex"] = objIndex
        # âœ… CRITICAL FIX: Ensure returnValues are always integers, not strings or Exudyn index objects
        # Convert objIndex to int if it's a string representing a number or an Exudyn index object
        if isinstance(objIndex, str) and objIndex.isdigit():
            objIndex_int = int(objIndex)
        elif isinstance(objIndex, (int, float)):
            objIndex_int = int(objIndex)
        elif hasattr(objIndex, '__index__'):  # Handle Exudyn index objects like NodeIndex, ObjectIndex
            objIndex_int = int(objIndex)
        else:
            objIndex_int = objIndex  # fallback for other types
            
        data["returnValues"] = {preferredKey: objIndex_int}
        data["returnInfo"] = f"{preferredKey}={objIndex}"
        
        debugLog(f"[legacyBuilder] ðŸ”¢ FIXED: Converted returnValues to integers: {data['returnValues']}", origin="objectRegistry.py")
        # Don't add return values to data - they should only be in returnValues!
        
        debugLog(f"[legacyBuilder] âœ… Created {prefix}{shortType} with ID {objIndex}", origin="objectRegistry.py")
        debugLog(f"[genericBuilder] ðŸ“¦ Final stored data:\n{pformat(deepSummarize(data))}", origin="objectRegistry.py")
        return data

    
    except Exception as e:
        debugLog(f"[legacyBuilder] âŒ Exception during legacy add: {repr(e)}", origin="objectRegistry.py")
        raise



    # ... legacy creation logic ...
    
    debugLog(f"[genericBuilder] ðŸ“¦ Final stored data:\n{pformat(data)}", origin="objectRegistry.py")






# â”€â”€â”€ Return key â†’ component group mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RETURN_KEY_TO_GROUP = {
    'nodeNumber': 'nodes',
    'nodeNumbers': 'nodes',
    'markerNumber': 'markers',
    'markerNumbers': 'markers',
    'objectNumber': 'objects',
    'objectNumbers': 'objects',
    'bodyNumber': 'objects',
    'bodyNumbers': 'objects',
    'loadNumber': 'loads',
    'loadNumbers': 'loads',
    'sensorNumber': 'sensors',
    'sensorNumbers': 'sensors',
}

def returnKeyToGroup(returnKey):
    group = RETURN_KEY_TO_GROUP.get(returnKey)
    if not group:
        debugLog(f"[returnKeyToGroup] âš ï¸ Unknown return key: {returnKey}", origin="objectRegistry.py")
    return group


def findRegistryCategoryByShortType(shortType):
    for cat, items in categorizedRegistry.items():
        for fullName in items:
            if fullName == shortType:
                return cat, fullName
            # NEW: allow match on short type
            for prefix in ['Object', 'Node', 'Marker', 'Sensor', 'Load']:
                if fullName.startswith(prefix) and fullName[len(prefix):] == shortType:
                    return cat, fullName
    return None, None



def genericToCode(data):
    objType = data['objectType']
    skipKeys = {
    'objectType', 'objIndex', 'returnValues', 'nodeType', 'markerType', 'loadType', 'sensorType',
    'returnInfo', 'connections', 'creationIndex', 'creationUID'
    }
    kwargs = {k: v for k, v in data.items() if k not in skipKeys}
    kwargs = normalizeKnownOptionals(kwargs)
    

    for k in list(kwargs):
        if kwargs[k] is None:
            del kwargs[k]

    def formatArg(val):
        if isinstance(val, str):
            if val[0] in 'bnmls' and val[1:].isdigit():
                return val
            return repr(val)
        elif isinstance(val, list):
            return f"[{', '.join(formatArg(x) for x in val)}]"
        else:
            return repr(val)

    argString = ", ".join(f"{k}={formatArg(v)}" for k, v in kwargs.items())

    assignVar = None
    if objType.startswith("Create"):
        for key in ['bodyNumber', 'objectNumber', 'markerNumber', 'nodeNumber']:
            if key in data:
                prefix = key[0]
                assignVar = f"{prefix}{data[key]}"
                break
        return f"{assignVar} = mbs.{objType}({argString})" if assignVar else f"mbs.{objType}({argString})"

    constructorCall = f"{objType}({argString})"
    if objType.startswith("Object"):
        return f"mbs.AddObject({constructorCall})"
    elif objType.startswith("Node"):
        return f"mbs.AddNode({constructorCall})"
    elif objType.startswith("Load"):
        return f"mbs.AddLoad({constructorCall})"
    elif objType.startswith("Sensor"):
        return f"mbs.AddSensor({constructorCall})"
    elif objType.startswith("Marker"):
        return f"mbs.AddMarker({constructorCall})"
    else:
        return f"# âš ï¸ Unsupported object type: {objType}"


class PythonSnippetFormWrapper:
    """Wrapper to make PythonSnippetDialog compatible with the registry system."""
    
    def __init__(self, typeName, existingData=None, parent=None, structure=None, SC=None):
        from guiForms.pythonSnippetDialog import PythonSnippetDialog
        
        # Extract data from existingData
        label = existingData.get('label', '') if existingData else ''
        code = existingData.get('code', '') if existingData else ''
        enabled = existingData.get('enabled', True) if existingData else True
        
        # Get kernel client from parent if available
        kernel_client = getattr(parent, 'kernel_client', None) if parent else None
        
        self.dialog = PythonSnippetDialog(
            parent=parent,
            label=label,
            code=code,
            enabled=enabled,
            kernel_client=kernel_client
        )
        
        # Store the result
        self._data = None
        self.dialog.snippetSaved.connect(self._on_snippet_saved)
        
        # Store original data for fallback
        self._original_data = existingData
        
        # Add any additional attributes that might be expected
        self.existingNames = set()
    
    def _on_snippet_saved(self, snippet_data):
        """Handle snippet saved signal."""
        self._data = snippet_data
        debugLog(f"[PythonSnippetFormWrapper] Snippet saved signal received: {snippet_data}", origin="objectRegistry.py")
    
    def exec_(self):
        """Execute the dialog and return result."""
        result = self.dialog.exec_()
        if result:  # Dialog was accepted
            # Always collect data from the form fields regardless of signal
            self._data = {
                'type': 'PythonSnippet',
                'label': self.dialog.label_edit.text().strip(),
                'enabled': self.dialog.enabled_checkbox.isChecked(),
                'code': self.dialog.code_edit.text(),
            }
            debugLog(f"[PythonSnippetFormWrapper] Dialog accepted, collected data: {self._data}", origin="objectRegistry.py")
        else:
            debugLog(f"[PythonSnippetFormWrapper] Dialog rejected", origin="objectRegistry.py")
        return result
    
    def get_data(self):
        """Return the form data."""
        if self._data is None:
            debugLog(f"[PythonSnippetFormWrapper] No data available, returning original data", origin="objectRegistry.py")
            return self._original_data or {}
        debugLog(f"[PythonSnippetFormWrapper] Returning collected data: {self._data}", origin="objectRegistry.py")
        return self._data

def pythonSnippetBuilder(mbs, item, snippet_vars=None):
    """No-op builder for PythonSnippet - they are executed directly during system build."""
    # PythonSnippets don't create Exudyn objects, they just execute Python code
    # The actual execution happens in buildSystemFromSequence
    return {'executed': True}

def pythonSnippetToCode(data):
    """Generate code representation for PythonSnippet."""
    code = data.get('code', '')
    label = data.get('label', '')
    enabled = data.get('enabled', True)
    
    if not enabled:
        return f"# PythonSnippet '{label}' (disabled)"
    
    if label:
        return f"# PythonSnippet: {label}\n{code}"
    else:
        return f"# PythonSnippet\n{code}"

# Register all standard Exudyn types
for objType in getAllTypes():
    category = categorize(objType)
    # debugLog(f"ðŸ“¦ Registering {objType} â†’ builder={genericBuilder}", origin="objectRegistry.py:REGISTRATION")
    registry[objType] = {
        'form': AutoGeneratedForm,
        'builder': genericBuilder,
        'toCode': genericToCode
    }
    categorizedRegistry.setdefault(category, []).append(objType)

# Register Create* functions
for funcName in getCreateFunctions():
    registry[funcName] = {
        'form': AutoGeneratedForm,
        'builder': genericBuilder,
        'toCode': genericToCode,
        'exudynType': f"ObjectConnector{funcName[6:]}"
    }
    categorizedRegistry.setdefault("Create (Helpers)", []).append(funcName)

# Register PythonSnippet
registry['PythonSnippet'] = {
    'form': PythonSnippetFormWrapper,
    'builder': pythonSnippetBuilder,
    'toCode': pythonSnippetToCode
}
categorizedRegistry.setdefault("Scripts", []).append('PythonSnippet')

def getCategorizedRegistry():
    # Ensure alphabetical order of entries inside each category
    for key in categorizedRegistry:
        categorizedRegistry[key] = sorted(categorizedRegistry[key])
    
    # Ensure category keys appear in preferred order
    preferredOrder = [
        "Create (Helpers)",
        "Nodes",
        "Objects (Body)",
        "Objects (SuperElement)",
        "Objects (FiniteElement)",
        "Objects (Joint)",
        "Objects (Connector)",
        "Objects (Constraint)",
        "Objects (Object)",
        "Markers",
        "Loads",
        "Sensors",
        "Other"
    ]
    
    # Use OrderedDict for deterministic dropdown ordering
    from collections import OrderedDict
    ordered = OrderedDict()
    for key in preferredOrder:
        if key in categorizedRegistry:
            ordered[key] = categorizedRegistry[key]
    # Add any leftover categories (e.g. unexpected ones)
    for key in sorted(categorizedRegistry):
        if key not in ordered:
            ordered[key] = categorizedRegistry[key]
    
    return ordered

def getAllRegisteredTypeNames():
    """Return a sorted list of all registered item types."""
    return sorted(registry.keys())