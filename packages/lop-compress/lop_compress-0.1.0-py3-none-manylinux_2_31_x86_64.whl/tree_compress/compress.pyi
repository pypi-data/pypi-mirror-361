# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from dataclasses import dataclass, field
from scipy.sparse import csc_matrix, csr_matrix
from sklearn.linear_model import Lasso, LogisticRegression
from typing import Any, Callable, List, Optional
from typing_extensions import Self
from util import Data, at_isregr, at_predlab, count_nnz_leafs, print_fit, print_metrics
from dataclasses import dataclass
import gc
import itertools
import numpy
import time
import veritas

@dataclass
class CompressRecord:
    def __post_init__(self: Self) -> Any: ...

@dataclass
class AlphaRecord:
class AlphaSearch:
    def __init__(self: Self, round_nsteps: Any, mtrain_ref: Any, mvalid_ref: Any, isworse_fun: Any) -> None: ...
    def __iter__(self: Self) -> Any: ...
    def __next__(self: Self) -> Any: ...
    def isworse_tr(self: Self, mtrain: Any) -> Any: ...
    def isworse_va(self: Self, mvalid: Any) -> Any: ...
    def isnotworse_tr(self: Self, mtrain: Any) -> Any: ...
    def isnotworse_va(self: Self, mvalid: Any) -> Any: ...
    def overfits(self: Self, mtrain: Any, mvalid: Any) -> Any: ...
    def underfits(self: Self, mtrain: Any, mvalid: Any) -> Any: ...
    def nsteps(self: Self) -> Any: ...
    def set_lohis(self: Self) -> Any: ...
    def quality_filter(self: Self, records: Any) -> Any: ...
    def next_lohis(self: Self) -> Any: ...
    def get_best_record(self: Self) -> Any: ...

class Compress:
    def __init__(self: Self, data: Data, at: veritas.AddTree, score: Callable[[np.ndarray, np.ndarray], float], isworse: Callable[[float, float], bool], silent: bool, seed: int, fit_intercept: bool) -> None: ...
    def is_regression(self: Self) -> Any: ...
    def _get_index_fortarget(self: Self, target: Any, level: Any, include_higher_leaves: Any) -> Any: ...
    def _transformx(self: Self, at: Any, x: Any, index: Any, num_cols: Any) -> Any: ...
    def _transformy(self: Self, target: Any, y: Any) -> Any: ...
    def compress(self: Self) -> Any: ...
    def _compress_round(self: Self, timeout: Any) -> Any: ...
    def compress_level(self: Self, level: Any) -> Any: ...
    def fit_coefficients(self: Self, clf: Any, xxtrain: Any, yytrain: Any, xxvalid: Any, yyvalid: Any, alpha_record: Any) -> Any: ...
    def _get_regularized_lin_clf(self: Self, xxtrain: Any) -> Any: ...
    def _update_lin_clf_alpha(self: Self, clf: Any, alpha: Any) -> Any: ...
    def _new_empty_addtree(self: Self, num_leaf_values: Any) -> Any: ...
    def prune_trees(self: Self, at: Any, intercept: Any, coefs: Any, index: Any) -> Any: ...
    def _copy_tree(self: Self, t: Any, tc: Any, coefs: Any, index1: Any) -> Any: ...
    def _copy_subtree(self: Self, t: Any, n: Any, tc: Any, nc: Any, coefs: Any, index1: Any) -> Any: ...

class _TreeZeroLeafPruner:
    def __init__(self: Self, t: Any) -> None: ...
    def _can_prune(self: Self, n: Any) -> Any: ...
    def is_root_zero(self: Self) -> Any: ...
    def prune(self: Self, n: Any, tc: Any, nc: Any) -> Any: ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import itertools
import time
import gc
import dataclasses
import typing
import numpy
import veritas
import scipy
import scipy.sparse
import sklearn
import sklearn.linear_model
import warnings
import sklearn.exceptions