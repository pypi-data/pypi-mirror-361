:mod:`summit.multiview_platform.multiview_classifiers.mvml`
===========================================================

.. py:module:: summit.multiview_platform.multiview_classifiers.mvml


mvml
----


.. py:data:: classifier_class_name
   :value: 'MVMLClassifier'


.. py:class:: MVMLClassifier(random_state=None, lmbda=0.1, eta=0.1, nystrom_param=1, n_loops=50, precision=0.0001, learn_A=0, kernel='rbf', learn_w=0, kernel_params=None)



   BaseMultiviewClassifier base of Multiview classifiers

   :param random_state: The seed of the pseudo random number multiview_generator to use when
                        shuffling the data.
   :type random_state: int seed, RandomState instance, or None (default=None)


   .. py:attribute:: param_names
      :value: ['lmbda', 'eta', 'nystrom_param', 'learn_A', 'learn_w', 'n_loops', 'kernel_params', 'kernel',...



   .. py:attribute:: distribs


   .. py:method:: fit(X, y, train_indices=None, view_indices=None)

      Fit the MVML classifier

      :param X:   Training multi-view input samples. can be also Kernel where attibute 'kernel'
                  is set to precompute "precomputed"
                or
                - Dictionary of {array like} with shape = (n_samples, n_features)  for multi-view
                  for each view.
                - Array of {array like} with shape = (n_samples, n_features)  for multi-view
                  for each view.
                - {array like} with (n_samples, nviews *  n_features) with 'views_ind' diferent to 'None'
      :type X: - Metriclearn_array {array-like, sparse matrix}, shape = (n_samples, n_features)

      y : array-like, shape = (n_samples,)
          Target values (class labels).
          array of length n_samples containing the classification/regression labels
          for training data

      views_ind : array-like (default=[0, n_features//2, n_features])
          Paramater specifying how to extract the data views from X:

          - views_ind is a 1-D array of sorted integers, the entries
            indicate the limits of the slices used to extract the views,
            where view ``n`` is given by
            ``X[:, views_ind[n]:views_ind[n+1]]`` .

            With this convention each view is therefore a view (in the NumPy
            sense) of X and no copy of the data is done.


      :returns: **self** -- Returns self.
      :rtype: object



   .. py:method:: predict(X, sample_indices=None, view_indices=None)

      :param X:
                - Metriclearn_array {array-like, sparse matrix}, shape = (n_samples, n_features)
                  Training multi-view input samples. can be also Kernel where attibute 'kernel'
                  is set to precompute "precomputed"

                - Dictionary of {array like} with shape = (n_samples, n_features)  for multi-view
                  for each view.
                - Array of {array like} with shape = (n_samples, n_features)  for multi-view
                  for each view.
                - {array like} with (n_samples, nviews *  n_features) with 'views_ind' diferent to 'None'
      :type X: different formats are supported

      :returns: **y** -- Predicted classes.
      :rtype: numpy.ndarray, shape = (n_samples,)



