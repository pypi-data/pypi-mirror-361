import math
from dataclasses import dataclass
from typing import Tuple

import numpy as np


@dataclass
class Model:
    """
    The vertices and faces of a 3D model used for 3D panoramas in Naver Map.

    (The UV map is not provided by the server, and I haven't been able to fully work out
    how to generate it, so it's not available yet. Sorry.)
    """
    vertices: np.ndarray  #:
    faces: np.ndarray  #:


# The UVs generated by this function are_almost_ correct, but not entirely,
# and I can't find the issue for the life of me. (Don't use it.)
def generate_uvs_and_save(model: Model, obj_path: str) -> None:
    vertices, faces = model.vertices, model.faces

    # Generate the UV coordinate for each vertex in the mesh.
    vertex_uvs = _generate_vertex_uvs(vertices)

    # Associate each face with its respective UV coordinates;
    # we need this for the next step.
    faces_with_uvs = _map_faces_to_uvs(faces, vertex_uvs)

    # Some faces may go across the edge of the equirectangular texture and
    # wrap back around to the other side. To correctly render this,
    # the U coordinate which is the odd one out must be incremented or
    # decremented by 1 depending on its location.
    # See this graphic for an explanation:
    # https://gist.github.com/sk-zk/ab1ea75ddc60163860d51a1f0006b64d
    _wrap_u_of_faces(faces_with_uvs)

    # Save the model as Wavefront OBJ.
    _save_obj(obj_path, vertices, faces_with_uvs)


def _save_obj(obj_path, vertices, faces_with_uvs):
    with open(obj_path, "w") as f:
        for i in range(0, len(vertices)):
            f.write(f"v {vertices[i][0]} {vertices[i][1]} {vertices[i][2]}\n")
        f.write("\n")

        for i in range(0, len(faces_with_uvs)):
            uv = faces_with_uvs[i][1]
            f.write(f"vt {uv[0][0]} {uv[0][1]}\n")
            f.write(f"vt {uv[1][0]} {uv[1][1]}\n")
            f.write(f"vt {uv[2][0]} {uv[2][1]}\n")
        f.write("\n")

        f.write("usemtl panorama\n")
        uv_idx = 1
        for i in range(0, len(faces_with_uvs)):
            face = faces_with_uvs[i][0]
            f.write(f"f {face[0] + 1}/{uv_idx} {face[1] + 1}/{uv_idx + 1} {face[2] + 1}/{uv_idx + 2}\n")
            uv_idx += 3


def _wrap_u_of_faces(faces_with_uvs):
    for i in range(0, len(faces_with_uvs)):
        face, uvs = faces_with_uvs[i]
        u1, u2, u3 = uvs[0][0], uvs[1][0], uvs[2][0]
        v1, v2, v3 = uvs[0][1], uvs[1][1], uvs[2][1]
        u1, u2, u3 = _wrap_u(u1, u2, u3)
        faces_with_uvs[i] = (face, [[u1, v1], [u2, v2], [u3, v3]])


def _map_faces_to_uvs(faces, vertex_uvs):
    faces_with_uvs = []
    for i in range(0, len(faces)):
        face = faces[i]
        faces_with_uvs.append((
            face, [
                np.copy(vertex_uvs[face[0]]),
                np.copy(vertex_uvs[face[1]]),
                np.copy(vertex_uvs[face[2]])
            ]
        ))
    return faces_with_uvs


def _wrap_u(u1: float, u2: float, u3: float) -> Tuple[float, float, float]:
    if abs(u1 - u2) < 0.5 and abs(u1 - u3) > 0.5:
        if u1 - u3 > 0.5:
            u3 += 1
        else:
            u3 -= 1
    elif abs(u1 - u3) < 0.5 and abs(u1 - u2) > 0.5:
        if u1 - u2 > 0.5:
            u2 += 1
        else:
            u2 -= 1
    elif abs(u2 - u3) < 0.5 and abs(u1 - u2) > 0.5:
        if u1 - u2 > 0.5:
            u1 -= 1
        else:
            u1 += 1
    return u1, u2, u3


def _generate_vertex_uvs(vertices):
    vertex_uvs = np.zeros((len(vertices), 2))
    uv_idx = 0
    for i in range(0, len(vertices)):
        vert = np.copy(vertices[i])
        magnitude = np.linalg.norm(vert)
        vert /= magnitude
        theta = math.atan2(vert[0], vert[2])
        phi = math.asin(vert[1])
        u = 1.0 - ((theta / math.pi) * 0.5 + 0.5)
        v = (phi / math.pi) + 0.5
        vertex_uvs[uv_idx] = [u, v]
        uv_idx += 1
    return vertex_uvs
