# -*- coding: utf-8 -*-
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# This file is part of the Exudyn GUI project.
#
# Filename: guiForms/autoGeneratedForm.py
#
# Description:
#     Dynamically builds input forms for Exudyn object and function creation
#     based on metadata. Supports:
#       - Field type introspection and validation
#       - Default value inference and symbolic variable resolution
#       - Grouped exclusive fields via stacked widgets
#       - Real-time name collision detection
#       - Integrated help from Exudyn docs and theDoc.pdf
#       - Preview, validation, and renderer highlighting support
#       - Special field widgets for user functions, graphicsDataList, inertia, etc.
#
# Authors:  Michael Pieber
# Date:     2025-05-21
#
# License:  BSD 3-Clause License
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Ensure exudynGUI root is in sys.path for submodule imports
import sys
import os
from pathlib import Path
thisFile = Path(__file__).resolve()
projectRoot = thisFile.parents[1]  # exudynGUI
if str(projectRoot) not in sys.path:
    sys.path.insert(0, str(projectRoot))

import re
import exudyn as exu
from exudyn import ItemType  # For renderer highlighting
import numpy as np
import json
import pathlib
import inspect
import importlib
import ast
try:
    import fitz  # PyMuPDF for PDF handling
except ImportError:
    fitz = None
from PyQt5.QtWidgets import QLineEdit, QCheckBox, QDialog, QVBoxLayout, QFormLayout, QComboBox, QDialogButtonBox, QPushButton, QWidget, QHBoxLayout, QLabel, QSizePolicy, QStackedWidget, QMessageBox, QSpinBox, QDoubleSpinBox, QToolButton
from PyQt5.QtCore import Qt, pyqtSlot

# For theDoc.pdf path - use the already calculated projectRoot
theDocPdfPath = projectRoot / 'theDocHelper' / 'theDoc.pdf'


from exudynGUI.core.qtImports import *
from exudynGUI.core.debug import debugLog, deepSummarize, summarizeDict, summarizeIfLarge
from exudynGUI.core.parameterHelp import getParameterDescription  # Import our new helper


from exudynGUI.model.modelData import generateUniqueName, existingNames
from exudynGUI.core.fieldMetadata import getFieldMetadataFor
from exudynGUI.core.fieldMetadata import convertToType  # make sure this import exists
# OR for full control:
# from core.fieldMetadata import FieldMetadataBuilder
from exudynGUI.core.fieldMetadata import FieldMetadataBuilder
from exudynGUI.core.fieldMetadata import guessGraphicsArgDefault
# Use relative import for main.py functions
from exudynGUI.core.rendererState import saveRendererStateFor, restoreRendererStateFor, saveViewStateWithAutoRestore
from exudynGUI.core.fieldValidation import validateAndPrepareFields, validateVector, validateSquareMatrix
from exudynGUI.core.widgetUtils import extractValueFromWidget, setValueToWidget
from exudynGUI.core.specialFields import dispatchSpecialFieldBuilder
from exudynGUI.model.modelData import existingNames  # ‚úÖ this was missing
from exudynGUI.core.specialFields import SPECIAL_FIELD_HANDLERS, getExclusiveFieldGroups
from exudynGUI.theDocHelper.theDocFieldHelp import (
    loadBookmarks, findBookmarkPage, findBookmarkSectionPages, findCreateSectionPages,
    SectionPdfImageDialog, getLegacyItemPageRange,
)


import numpy as np
import inspect
from exudyn.utilities import GraphicsDataBasis, GraphicsDataFrame  # excluded intentionally
from exudynGUI.core.debug import debugLog, deepSummarize
graphicsVisualizations = importlib.import_module("exudynGUI.functions.graphicsVisualizations")
graphicsDataRegistry = graphicsVisualizations.graphicsDataRegistry
from exudynGUI.guiForms.graphicsDataDialog import GraphicsDataDialog
from exudynGUI.core.fieldValidation import isMeaningfulDefault

from exudynGUI.guiForms.specialWidgets import (
    buildBodyNumberWidget,
    buildNodeNumberWidget,
    buildMarkerNumberWidget,
    buildIntNWidget,
    buildBodyPairSelectorWidget,
    buildBodyListWidget,
    buildBodyOrNodeListWidget,
    buildMatrix3x3Widget,
    buildMatrix6x6Widget,
    buildVec6Widget,
    buildOutputVariableTypeWidget,
)
from exudynGUI.core.fieldValidation import (
    validateAndPrepareFields,
    validateVector,
    validateSquareMatrix,
    isMeaningfulDefault  # ‚úÖ Add this
)

from exudynGUI.core.specialFields import getExclusiveFieldGroups


def logFieldValue(fieldName, value):
    return f"{fieldName} = {repr(value)} (type: {type(value).__name__})"

import exudyn.utilities as exuutils

# NodeType dropdown support: dynamically get all exudyn.NodeType values
try:
    NODE_TYPE_OPTIONS = [k for k in exu.NodeType.__members__.keys() if k != 'value']
    # Prefer RotationEulerParameters as default if present
    NODE_TYPE_DEFAULT = 'RotationEulerParameters' if 'RotationEulerParameters' in NODE_TYPE_OPTIONS else NODE_TYPE_OPTIONS[0]
except Exception:
    NODE_TYPE_OPTIONS = [
        "1D", "GenericAE", "GenericData", "GenericODE1", "GenericODE2", "Point", "Point2D", "Point2DSlope1", "PointGround", "PointSlope1", "PointSlope12", "PointSlope23", "RigidBody2D", "RigidBodyEP", "RigidBodyRotVecLG", "RigidBodyRxyz"
    ]
    NODE_TYPE_DEFAULT = "RotationEulerParameters" if "RotationEulerParameters" in NODE_TYPE_OPTIONS else NODE_TYPE_OPTIONS[0]

def bindGettersToStructure(structure, includeGround=True):
    def makeGetter(group):
        def getter():
            items = structure.get(group.lower(), [])
            return [
                (item['index'], item['label'], item['data'].get(f'{group[:-1]}Type', '?'))
                for item in items
                if includeGround or not str(item['data'].get(f'{group[:-1]}Type', '')).startswith("Ground")
            ]
        return getter

    for group in ['objects', 'nodes', 'markers', 'loads', 'sensors']:
        methodName = f"getAvailable{group[:-1].capitalize()}s"
        setattr(structure, methodName, makeGetter(group))


class StructureWrapper:
    def __init__(self, data):
        self._data = data or {}

    def get(self, key, default=None):
        return self._data.get(key, default)

    def __getitem__(self, key):
        return self._data[key]

    def __contains__(self, key):
        return key in self._data



import re

def _convertLatexLikeToHtml(text: str) -> str:
    """
    Convert simple LaTeX‚Äêstyle '$‚Ä¶$' math into minimal HTML, always adding
    a space after the </i> so that the following text is not glued on.
    """
    def _replace_math(match: re.Match) -> str:
        inner = match.group(1)  # e.g. '\vw_{\mathrm{off}}'

        # 1) Remove any \mathrm{‚Ä¶}
        inner = re.sub(r"\\mathrm\{([^}]*)\}", r"\1", inner)

        # 2) Convert _{‚Ä¶} ‚Üí <sub>‚Ä¶</sub>
        inner = re.sub(r"_\{([^}]*)\}", r"<sub>\1</sub>", inner)

        # 3) Convert ^{‚Ä¶} ‚Üí <sup>‚Ä¶</sup>
        inner = re.sub(r"\^\{([^}]*)\}", r"<sup>\1</sup>", inner)

        # 4) Drop any remaining backslashes (e.g. '\vw' ‚Üí 'vw')
        inner = re.sub(r"\\([A-Za-z]+)", r"\1", inner)

        # 5) Wrap in <i>‚Ä¶</i> and add a trailing space (&nbsp; or regular space)
        #    Using &nbsp; prevents HTML from collapsing it away.
        return f"<i>{inner}</i>&nbsp;"

    # Replace all $‚Ä¶$ blocks with our italicized, subscripted HTML + a space
    result = re.sub(r"\$([^$]+)\$", _replace_math, text)

    # Wrap the whole thing in <html> so Qt renders it as rich text
    return f"<html>{result}</html>"

          
class AutoGeneratedForm(QDialog):
    def __init__(self, objectType: str, existingData=None, parent=None, structure=None, SC=None):
        super().__init__(parent)

        self.existingNames = getattr(parent, "existingNames", [])
        debugLog(f"üö® [AutoGeneratedForm.__init__] URGENT DEBUG: existingNames = {self.existingNames}")
        debugLog(f"üö® [AutoGeneratedForm.__init__] URGENT DEBUG: parent type = {type(parent)}")
        debugLog(f"üö® [AutoGeneratedForm.__init__] URGENT DEBUG: hasattr existingNames = {hasattr(parent, 'existingNames') if parent else 'No parent'}")
        debugLog(f"[AutoGeneratedForm.__init__] Initial existingNames from parent: {self.existingNames}", origin="autoGeneratedForm.py")
        self.setWindowTitle(f"AutoGenerated Form for {objectType}")
        self.existingData = existingData or {}
        self.userVariables = parent.userVariables if parent and hasattr(parent, 'userVariables') else {}

        # Store SC directly for highlighting functionality
        self.SC = SC
        if SC:
            debugLog(f"‚úÖ [AutoGeneratedForm.__init__] SC provided directly: {type(SC)}", origin="autoGeneratedForm.py")
        else:
            debugLog(f"‚ö†Ô∏è [AutoGeneratedForm.__init__] No SC provided directly", origin="autoGeneratedForm.py")


        # Preload PDF bookmarks once (for the entire form)
        # 1) Store the absolute PDF path
        self.pdfPath = str(theDocPdfPath)  # e.g. "C:/‚Ä¶/mainExudynGUI_V0.03/exudynGUI/theDocHelper/theDoc.pdf"
        if not Path(self.pdfPath).exists():
            QMessageBox.critical(
                self,
                "Missing PDF",
                f"Cannot find theDoc.pdf at:\n  {self.pdfPath}"
            )
            self.close()
            return        # 2) Preload all bookmarks from theDoc.pdf
        self.pdfBookmarks = loadBookmarks(self.pdfPath)

        # üöÄ Make this dialog NON-MODAL so users can interact with OpenGL window simultaneously
        self.setModal(False)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        debugLog(f"‚úÖ [AutoGeneratedForm] Set as non-modal dialog for simultaneous OpenGL interaction", origin="autoGeneratedForm.py")

        self.objectType = objectType
        self.inputFields = {}
        self.fields = {}
        self.fieldMetadata = {}
        self.exclusiveSelectors = {}  # comboBoxes to track group choices
        self.exclusiveFieldWidgets = {}  # mapping of group ‚Üí { fieldName: widget }

        if structure is not None:
            self.structure = StructureWrapper(structure)
        elif parent is not None:
            self.structure = StructureWrapper(getattr(parent, 'structure', {}))
        else:
            self.structure = StructureWrapper({})

        
        debugLog(f"[DEBUG] self.structure set to: {type(self.structure)} with keys: {list(getattr(self.structure, '__dict__', {}).keys())}")
        bindGettersToStructure(self.structure, includeGround=True)
        
      


        builder = FieldMetadataBuilder(useExtracted=True)
        
        try:
            self.fieldMetadata = builder.build(objectType)
              # üîß Filter out GUI-only metadata fields for legacy items (Object*, Node*, Marker*, etc.)
            # These fields are metadata used by GUI but not constructor parameters for legacy items
            if (objectType.startswith(('Object', 'Node', 'Marker', 'Load', 'Sensor')) and 
                not objectType.startswith('Create')):
                gui_only_fields = ['nodeType', 'markerType', 'summaryPythonCode', 'isLegacy']
                filtered_count = 0
                for field in gui_only_fields:
                    if field in self.fieldMetadata:
                        debugLog(f"üîß [AutoGeneratedForm] Filtering out '{field}' field for legacy item: {objectType}")
                        del self.fieldMetadata[field]
                        filtered_count += 1
                
                if filtered_count > 0:
                    debugLog(f"üîß [AutoGeneratedForm] Filtered {filtered_count} GUI-only fields from {objectType}")
            
            self.exclusiveGroups = getExclusiveFieldGroups(objectType, list(self.fieldMetadata.keys()))
            debugLog(f"üöÄ Building AutoGeneratedForm for: {objectType}", origin="AutoGeneratedForm.__init__")
            debugLog(f"üß© Field metadata keys: {list(self.fieldMetadata.keys())}", origin="AutoGeneratedForm.__init__")
        except Exception as e:
            debugLog(f"‚ùå Failed to load field metadata for {objectType}: {e}", origin="AutoGeneratedForm.__init__")
            self.fieldMetadata = {}


        self.layout = QVBoxLayout(self)
        self.formLayout = QFormLayout()
        self.layout.addLayout(self.formLayout)
        self.exclusiveGroupFields = set()
        for group in self.exclusiveGroups:
            self.exclusiveGroupFields.update(group['options'])
                
        handledFields = set()
        
        for group in self.exclusiveGroups:
            labelText   = group['label']         # e.g. "Connection"
            options     = group['options']       # e.g. ["bodyList", "nodeList", ‚Ä¶]
            defaultOption = group.get('default', options[0])
        
            # ‚îÄ‚îÄ‚îÄ Build the combo‚Äêbox for selecting which option in this group is active ‚îÄ‚îÄ‚îÄ
            combo = QComboBox()
            combo.addItems(options)
            combo.setCurrentText(defaultOption)
        
            # ‚îÄ‚îÄ‚îÄ Build a QStackedWidget, one page for each option in group[...] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            stacked = QStackedWidget()
            self.fields[labelText] = combo
        
            optionWidgets = {}
            for opt in options:
                # opt is a real field name (e.g. "bodyList")
                meta = self.fieldMetadata.get(opt, {})
                default = self.existingData.get(opt, meta.get("default",""))
        
                widget = dispatchSpecialFieldBuilder(
                    fieldName=opt,
                    typeHint=meta.get("type"),
                    default=default,
                    parent=self,
                    structure=self.structure
                ) or self.createFieldWidget(opt, meta, self.userVariables, default=default)
        
                # initial visibility of the container is managed by updateStack, so skip widget.setVisible
                # widget.setVisible(opt == defaultOption)
                widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
                # Only constrain height for simple widgets; leave list-based selectors unconstrained
                if not hasattr(widget, 'listWidget'):
                    widget.setMaximumHeight(40)
        
                self.fields[opt] = widget
        
                container = QWidget()
                layout = QVBoxLayout(container)
                layout.setContentsMargins(0, 0, 0, 0)
                layout.setSpacing(0)
                layout.addWidget(widget)
                # allow container to expand vertically as needed
                container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
                # For list-based selectors, allow vertical expansion
                if not hasattr(widget, 'listWidget'):
                    container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Maximum)
                    container.setMaximumHeight(40)
                    container.setMinimumHeight(1)
                else:
                    container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        
                optionWidgets[opt] = container
                stacked.addWidget(container)
        
            def updateStack(index, combo=combo, stacked=stacked, options=options):
                for i, opt in enumerate(options):
                    optionWidgets[opt].setVisible(i == index)
                stacked.setCurrentIndex(index)
        
            combo.currentIndexChanged.connect(updateStack)
        
            # ‚îÄ‚îÄ‚îÄ Place combo and stacked together in a single container ‚îÄ‚îÄ‚îÄ
            groupContainer = QWidget()
            groupLayout = QVBoxLayout(groupContainer)
            groupLayout.setContentsMargins(0, 0, 0, 0)
            groupLayout.setSpacing(2)
            groupLayout.addWidget(combo)
            groupLayout.addWidget(stacked)
        
            groupHelpText = ""  # or fetch from metadata if you happen to have group‚Äêlevel help
            labelWidget = self._makeLabelWithHelp(labelText, groupHelpText)
            self.formLayout.addRow(labelWidget, groupContainer)
            updateStack(combo.currentIndex())          # Create 'name' field early with real-time validation
        if 'name' in self.fieldMetadata:
            nameMeta = self.fieldMetadata['name']
              # For editing existing objects, use the existing name
            # For new objects, generate a unique name that doesn't conflict
            if self.existingData.get('name'):
                # Editing existing object - use existing name
                defaultName = self.existingData['name']
            else:
                # Creating new object - generate unique name using the backend logic
                baseName = self.sanitizeBaseName(objectType)
                
                # Check if the base name conflicts and auto-increment if needed
                from exudynGUI.model.modelData import generateUniqueName
                defaultName = generateUniqueName(baseName, self.existingNames)
                debugLog(f"[AutoGeneratedForm] üÜï Generated unique default name: '{baseName}' -> '{defaultName}'", origin="autoGeneratedForm.py")
            
            # Create enhanced name field with real-time collision detection
            nameField = QLineEdit()
            nameField.setText(defaultName)
            
            # Store original name to avoid self-collision when editing
            self.originalName = self.existingData.get('name', '')
            
            # Add real-time name collision validation
            def validateNameOnChange():
                currentName = nameField.text().strip()
                debugLog(f"[NameValidation] Checking name: '{currentName}', existingNames: {self.existingNames}, originalName: {self.originalName}", origin="autoGeneratedForm.py")
                
                # Skip validation for empty names (will be caught by other validation)
                if not currentName:
                    nameField.setStyleSheet("")
                    nameField.setToolTip("")
                    return
                  # Check for collision with existing names (excluding original name when editing)
                existing_names_set = {name.lower() for name in self.existingNames}
                if self.originalName:
                    existing_names_set.discard(self.originalName.lower())
                
                debugLog(f"[NameValidation] Names to check against: {existing_names_set}", origin="autoGeneratedForm.py")
                
                if currentName.lower() in existing_names_set:
                    # Name collision detected - show red background and error message
                    nameField.setStyleSheet("background-color: #FFCCCC; border: 2px solid red;")
                    nameField.setToolTip(f"‚ùå Name '{currentName}' already exists! Please choose a different name.")
                    debugLog(f"[NameValidation] ‚ùå Collision detected: '{currentName}' already exists")
                else:
                    # Name is unique - clear any error styling
                    nameField.setStyleSheet("")
                    nameField.setToolTip("")
                    debugLog(f"[NameValidation] ‚úÖ Name '{currentName}' is unique")
            
            # Connect real-time validation to text changes
            nameField.textChanged.connect(validateNameOnChange)
            
            # Run initial validation
            validateNameOnChange()
            
            self.fields['name'] = nameField
            self.inputFields['name'] = nameField

            # ‚îÄ‚îÄ REPLACED: QLabel("name") ‚îÄ‚îÄ
            labelWidget = self._makeLabelWithHelp("name", nameMeta.get("description", ""))
            self.formLayout.addRow(labelWidget, nameField)
            debugLog(f"[AutoGeneratedForm] üÜï Assigned unique name: {defaultName}")

        # Add all remaining (non-exclusive) fields
        for fieldName, meta in self.fieldMetadata.items():
            if fieldName in handledFields or fieldName in self.fields:
                continue

            default = self.existingData.get(fieldName, meta.get("default", ""))
            widget = dispatchSpecialFieldBuilder(
                fieldName=fieldName,
                typeHint=meta.get("type"),
                default=default,
                parent=self,
                structure=self.structure
            )
            if widget is None:
                widget = self.createFieldWidget(fieldName, meta, self.userVariables, default=default)

            self.fields[fieldName] = widget
            self.inputFields[fieldName] = widget            # ‚îÄ‚îÄ ENHANCED: Get help from Exudyn internal documentation ‚îÄ‚îÄ
            # 1) Try to get parameter help from Exudyn's internal documentation
            # Use existing MainSystem from parent to avoid creating new SystemContainer
            existing_mbs = getattr(parent, 'mbs', None) if parent else None
            exudynHelp = getParameterDescription(self.objectType, fieldName, existing_mbs)
            
            # 2) Fallback to metadata description if Exudyn help is not available
            rawDesc = meta.get("description", "") or ""
            
            # 3) Prefer Exudyn help, but combine with metadata if both exist
            if exudynHelp and rawDesc.strip():
                # Both sources available - combine them
                helpText = f"<b>Exudyn:</b> {exudynHelp}<br><br><b>Metadata:</b> {_convertLatexLikeToHtml(rawDesc)}"
            elif exudynHelp:
                # Only Exudyn help available
                helpText = exudynHelp
            elif rawDesc.strip():
                # Only metadata description available
                helpText = _convertLatexLikeToHtml(rawDesc)
            else:
                # No help available
                helpText = ""

            # 4) Create label with help text (info icon will appear if helpText is not empty)
            labelWidget = self._makeLabelWithHelp(fieldName, helpText)

            # Special: Add PDF help button for outputVariableType
            if fieldName == "outputVariableType":
                labelContainer = QWidget()
                hLayout = QHBoxLayout(labelContainer)
                hLayout.setContentsMargins(0, 0, 0, 0)
                hLayout.setSpacing(4)
                hLayout.addWidget(labelWidget)
                help_btn = QToolButton()
                help_btn.setText("?")
                help_btn.setToolTip("Show help for the selected item in bodyNumber, objectNumber, nodeNumber, or loadNumber")
                hLayout.addWidget(help_btn)
                hLayout.addStretch(1)
                def show_selected_item_help():
                    for selector_field in ["bodyNumber", "objectNumber", "nodeNumber", "loadNumber"]:
                        widget_sel = self.fields.get(selector_field)
                        if widget_sel:
                            selected_label = None
                            if hasattr(widget_sel, 'combo') and hasattr(widget_sel.combo, 'currentText'):
                                selected_label = widget_sel.combo.currentText()
                            elif hasattr(widget_sel, 'currentText'):
                                selected_label = widget_sel.currentText()
                            elif hasattr(widget_sel, 'getValue'):
                                selected_label = str(widget_sel.getValue())
                            if selected_label:
                                # NEW: Extract index and get actual type from MBS
                                try:
                                    # Parse different formats: "1", "1 - Object_MassPoint2", "[Object 1] Name (Type)", etc.
                                    import re
                                    
                                    # Method 1: Try to extract index from various formats
                                    index = None
                                    group_type = None
                                    
                                    # Format: "[Object 1] Name (Type)" or "[Node 1] Name (Type)"
                                    match = re.match(r'\[(\w+)\s+(\d+)\]', selected_label)
                                    if match:
                                        group_name = match.group(1).lower()
                                        index = int(match.group(2))
                                        if group_name == 'object':
                                            group_type = 'objects'
                                        elif group_name == 'node':
                                            group_type = 'nodes'
                                        elif group_name == 'marker':
                                            group_type = 'markers'
                                        elif group_name == 'load':
                                            group_type = 'loads'
                                        elif group_name == 'sensor':
                                            group_type = 'sensors'
                                    
                                    # Format: "1 - Object_MassPoint2" or just "1"
                                    if index is None:
                                        if ' - ' in selected_label:
                                            index_part = selected_label.split(' - ', 1)[0].strip()
                                        else:
                                            index_part = selected_label.strip()
                                        
                                        try:
                                            index = int(index_part)
                                            # Determine group type from field name
                                            if selector_field in ['bodyNumber', 'objectNumber']:
                                                group_type = 'objects'
                                            elif selector_field == 'nodeNumber':
                                                group_type = 'nodes'
                                            elif selector_field == 'loadNumber':
                                                group_type = 'loads'
                                        except ValueError:
                                            pass
                                    
                                    # Get actual type from MBS if we have index and group
                                    if index is not None and group_type:
                                        from core.modelManager import getActualComponentType
                                        # Get parent window to access mbs
                                        parent_window = self.parent()
                                        while parent_window and not hasattr(parent_window, 'mbs'):
                                            parent_window = parent_window.parent()
                                        
                                        if parent_window and hasattr(parent_window, 'mbs'):
                                            actual_type = getActualComponentType(parent_window.mbs, group_type, index)
                                            debugLog(f"‚úÖ Resolved {selector_field}[{index}] ‚Üí actual type: '{actual_type}'")
                                            
                                            # Use the actual type for help lookup
                                            type_name_normalized = actual_type.replace('_', '')
                                            debugLog(f"Trying PDF help for resolved type: '{type_name_normalized}'")
                                            start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, type_name_normalized)
                                            if start_page and end_page:
                                                dlg = SectionPdfImageDialog(self.pdfPath, list(range(start_page, end_page + 1)), parent=self)
                                                dlg.exec_()
                                                return
                                            else:
                                                debugLog(f"‚ö†Ô∏è No PDF help found for '{type_name_normalized}'")
                                        else:
                                            debugLog("‚ö†Ô∏è Could not access MBS from AutoGeneratedForm")
                                    
                                    # FALLBACK: Use old method if new method fails
                                    if ' - ' in selected_label:
                                        type_name = selected_label.split(' - ', 1)[1].strip()
                                    else:
                                        type_name = selected_label.strip()
                                    type_name_normalized = type_name.replace('_', '')
                                    debugLog(f"Fallback: Trying PDF help for type: '{type_name_normalized}'")
                                    start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, type_name_normalized)
                                    if start_page and end_page:
                                        dlg = SectionPdfImageDialog(self.pdfPath, list(range(start_page, end_page + 1)), parent=self)
                                        dlg.exec_()
                                        return
                                    
                                except Exception as e:
                                    debugLog(f"‚ùå Error in help resolution: {e}")
                                    import traceback
                                    traceback.print_exc()
                    
                    QMessageBox.information(self, "Help", "No item selected or help not found for the selected entity.")
                help_btn.clicked.connect(show_selected_item_help)
                self.formLayout.addRow(labelContainer, widget)
            else:
                self.formLayout.addRow(labelWidget, widget)


        # OK/Cancel/Preview/Help buttons
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.previewButton = QPushButton("Preview")
        self.helpButton = QPushButton("Help")

        # Add Preview and Help to the button box
        self.buttonBox.addButton(self.previewButton, QDialogButtonBox.ActionRole)
        self.buttonBox.addButton(self.helpButton, QDialogButtonBox.HelpRole)

        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        self.previewButton.clicked.connect(self.onPreviewClicked)
        self.helpButton.clicked.connect(self.onHelpClicked)

        self.layout.addWidget(self.buttonBox)
        self.existingNames = getattr(parent, "existingNames", [])

        btnValidateAndPrint = QPushButton("Validate and Print")
        btnValidateAndPrint.clicked.connect(self.validateAndPrintCollectedData)
        self.layout.addWidget(btnValidateAndPrint)

        
        debugLog(f"[AutoGeneratedForm] Finished building form for: {self.objectType}")
        
        # Set up renderer highlighting for relevant fields
        self._setupRendererHighlighting()

    def exec_(self):
        """Override exec_() to show non-modally but still return a result when finished."""
        # Show the dialog non-modally
        self.show()
        
        # Create an event loop to wait for the dialog to be closed
        from PyQt5.QtCore import QEventLoop
        self.event_loop = QEventLoop()
        
        # Connect the finished signal to quit the event loop
        self.finished.connect(self.event_loop.quit)
        
        # Start the event loop (this blocks until the dialog is closed)
        self.event_loop.exec_()
        
        # Return the result (QDialog.Accepted or QDialog.Rejected)
        return self.result()

    def onPreviewClicked(self):
        """Preview the current object in the main GUI using the actual constructor."""
        try:
            mainWindow = self.parent()

            # Undo previous preview if it exists
            if hasattr(self, "_previewUndo") and self._previewUndo:
                mainWindow.undoLastAction()
                self._previewUndo = False

            # ‚úÖ Mark this as a preview call to allow data collection even with name conflicts
            self._isPreview = True

            # Use the same normalization as accept(), but do NOT close the dialog
            data = self.collectAndNormalizeData()
            
            # ‚úÖ Handle case where data collection failed
            if not data:
                QMessageBox.critical(
                    self,
                    "Preview Error", 
                    "Failed to collect form data for preview. Please check all fields are properly filled."
                )
                return
            # --- Add unique suffix to name for preview only ---
            import uuid
            if "name" in data:
                data["name"] = f"{data['name']}_PREVIEW_{uuid.uuid4().hex[:8]}"


            # --- NEW: Validate required fields before preview ---
            missing_fields = []
            for field, meta in self.fieldMetadata.items():
                if meta.get("required", False) and (field not in data or data[field] in [None, "", []]):
                    missing_fields.append(field)
            if missing_fields:
                QMessageBox.critical(
                    self,
                    "Preview Error",
                    f"Cannot preview: missing required fields:\n{', '.join(missing_fields)}"
                )
                return

            # Add the preview object using your model logic
            from exudynGUI.core.modelManager import addItemToModel
            index = addItemToModel(self.objectType, mainWindow, previewData=data)
            if index is not None:
                mainWindow.undoStack.append({'action': 'add', 'index': index})
                self._previewUndo = True  # Mark that a preview object exists
            mainWindow.buildSystemAndShowAndRefreshTree()

        except Exception as e:
            # --- NEW: Show the data dict in the error dialog for debugging ---
            import pprint
            data_str = pprint.pformat(locals().get('data', {}), indent=2)
            debugLog(f"[Preview Error] Exception: {e}\nData sent:\n{data_str}", origin="autoGeneratedForm.py:onPreviewClicked")
            QMessageBox.critical(
                self,
                "Preview Error",
                f"Failed to create preview:\n{str(e)}\n\nData sent:\n{data_str}"
            )
        finally:
            # ‚úÖ Clean up preview flag
            if hasattr(self, '_isPreview'):
                delattr(self, '_isPreview')



    def _wrapInHBox(self, widget):
        wrapper = QWidget()
        layout = QHBoxLayout(wrapper)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(widget)
        layout.addStretch(1)  # stretch pushes widget to full width
        wrapper.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)  # ‚¨Ö restore normal width
        return wrapper

    @pyqtSlot()
    def onHelpClicked(self):
        origKey = self.objectType
        debugLog(f"[DEBUG] Help clicked for objectType = {origKey!r}")
    
        # If it's a Create‚Ä¶ function, first try to locate the literal definition page
        if origKey.startswith("Create"):
            from exudynGUI.theDocHelper.theDocFieldHelp import (
                findFunctionPageInCreateSection,
                findCreateSectionPages
            )
            import fitz
    
            # 1) Look for "def CreateXYZ" inside the Create-section
            funcPage = findFunctionPageInCreateSection(
                self.pdfPath,
                self.pdfBookmarks,
                origKey
            )
    
            if funcPage is not None:
                # We want funcPage plus the next 2 pages (if they exist)
                doc       = fitz.open(self.pdfPath)
                last_page = doc.page_count
                doc.close()
    
                # Build a small "window" of pages: `[funcPage, funcPage+1, funcPage+2]` clamped to [1..last_page]
                pages = []
                for offset in (0, 1):
                    p = funcPage + offset
                    if 1 <= p <= last_page:
                        pages.append(p)
    
                debugLog(f"[DEBUG] Showing pages {pages} (centered on {funcPage})")
                dlg = SectionPdfImageDialog(self.pdfPath, pages, parent=self)
                dlg.exec_()
                return
    
            # 2) If no exact match, fall back to the entire Create-section
            startP, endP = findCreateSectionPages(self.pdfBookmarks)
            if startP is None:
                QMessageBox.information(
                    self,
                    "Help Not Found",
                    f"No PDF help found for '{origKey}'."
                )
                return
    
            doc       = fitz.open(self.pdfPath)
            last_page = doc.page_count
            doc.close()
    
            if endP is None:
                endP = last_page
    
            pages = list(range(startP, endP + 1))
            dlg = SectionPdfImageDialog(self.pdfPath, pages, parent=self)
            dlg.exec_()
            return
        
        # ‚Ä¶ existing "Object‚Ä¶" logic below ‚Ä¶        # For legacy items (Object*, Node*, Marker*, Load*, Sensor*), use the improved page range logic
        if origKey.startswith(("Object", "Node", "Marker", "Load", "Sensor")):
            debugLog(f"[DEBUG] Legacy item detected: {origKey}")
            start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, origKey)
            
            if start_page and end_page:
                pages = list(range(start_page, end_page + 1))
                debugLog(f"[DEBUG] Found legacy item pages: {pages}")
                dlg = SectionPdfImageDialog(self.pdfPath, pages, parent=self)
                dlg.exec_()
                return
            else:
                debugLog(f"[DEBUG] No specific pages found for {origKey}, falling back to section search")
        
        # Fallback: existing logic below
        searchKey = origKey
        if not searchKey.startswith("Object"):
            searchKey = "Object" + searchKey
        startP, endP = findBookmarkSectionPages(self.pdfBookmarks, searchKey)
        if startP is None:
            QMessageBox.information(
                self,
                "Help Not Found",
                f"No PDF help found for '{origKey}'."
            )
            return
        if endP is None:
            endP = fitz.open(self.pdfPath).page_count
        pages = list(range(startP, endP + 1))
        dlg = SectionPdfImageDialog(self.pdfPath, pages, parent=self)
        dlg.exec_()

    def _getPdfPageCount(self, pdfPath):
        doc = fitz.open(pdfPath)
        return doc.page_count



    def _makeLabelWithHelp(self, text: str, helpText: str) -> QWidget:
        """
        Return a QWidget containing:
          [ QLabel(text) ] [ üìò (‚Ñπ) icon ]  
        where hovering on the icon shows 'helpText' as a tooltip.
        If helpText is empty, just return a plain QLabel(text) (wrapped as QWidget for uniformity).
        """
        if not helpText:
            # Just a simple QLabel inside a container, so we can always call addRow(widget, field)
            container = QWidget()
            layout = QHBoxLayout(container)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.addWidget(QLabel(text))
            return container
    
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
    
        # 1) The field name label
        nameLabel = QLabel(text)
        layout.addWidget(nameLabel)
    
        # 2) The tiny "‚Ñπ" icon with enhanced tooltip
        infoIcon = QLabel("‚Ñπ")
        infoIcon.setStyleSheet("color: #1e90ff; font-weight: bold; font-size: 12px;")
        
        # Set rich text tooltip with better formatting
        if "<b>" in helpText or "<br>" in helpText or "<" in helpText:
            # HTML content - use it directly
            infoIcon.setToolTip(helpText)
        else:
            # Plain text - wrap in HTML for better formatting
            infoIcon.setToolTip(f"<div style='max-width: 300px; word-wrap: break-word;'>{helpText}</div>")
          # Make the cursor show "?" when hovering and make it clickable
        infoIcon.setCursor(Qt.WhatsThisCursor)
        infoIcon.setScaledContents(True)
        infoIcon.setMaximumSize(16, 16)
        
        # Add click functionality to show detailed help dialog
        infoIcon.mousePressEvent = lambda event: self._showFieldHelp(text, helpText)
        
        layout.addWidget(infoIcon)
    
        return container
    def validateAndPrintCollectedData(self):
        from exudynGUI.core.fieldValidation import tryValidateField
        import pprint
        if not hasattr(self, '_data'):
            debugLog("[validateAndPrint] ‚ö†Ô∏è Forcing accept() to populate data.")
            self.simulateAccept()  # ensure data is ready
        failed = []
        collectedData = {}
    
        data = self.get_data()
        for fieldName, rawValue in data.items():
            widget = self.fields.get(fieldName)
            meta = self.fieldMetadata.get(fieldName, {})
            typeHint = meta.get('type', None)
           
    
            # Fallback to metadata default for empty fields
            if rawValue in ['', None]:
                fallback = meta.get("default")
                if fallback is not None and fallback != '':
                    debugLog(f"[validateAndPrint] üõ†Ô∏è Fallback for {fieldName} = {fallback}")
                    rawValue = fallback
    
            collectedData[fieldName] = rawValue
    
            # Skip GUI-only
            if meta.get("guiOnly", False):
                widget.setStyleSheet("border: 1px solid gray;")
                continue            # Validate
            valid, msg = tryValidateField(fieldName, rawValue, typeHint=typeHint, objectType=self.objectType)
            if not valid:
                failed.append((fieldName, msg))
                widget.setStyleSheet("border: 2px solid red;")
                widget.setToolTip(msg)
            else:
                widget.setStyleSheet("border: 2px solid green;")
                widget.setToolTip("")
    
        debugLog("\nüì¶ Final collected data (including weak/invalid fields):")
        from pprint import pformat
        debugLog(pformat(collectedData, indent=2, width=100))
    
        if failed:
            debugLog("\n‚ùå Validation failed for:")
            for f, msg in failed:
                debugLog(f"   - {f}: {msg}")
        else:
            debugLog("\n‚úÖ All fields validated successfully.")

    def onEditInMainWindowClicked(self):
        mainWindow = self.parent()
        if hasattr(self, "_previewUndo") and self._previewUndo:
            mainWindow.undoLastAction()
            self._previewUndo = False
        if hasattr(mainWindow, "showAnalyseAndGraphicsTabsOnly"):
            mainWindow.showAnalyseAndGraphicsTabsOnly()
        if hasattr(mainWindow, "previewCurrentGraphics"):
            mainWindow.previewCurrentGraphics()
            
    def buildBodyNumberWidget(fieldName, typeHint, default, parent=None, structure=None):
        combo = QComboBox()
        combo.setEditable(True)
        defaultStr = str(default)
    
        # Get body IDs from the structure, fallback to empty list
        bodyIDs = []
        if structure:
            bodyGroup = structure.get('Objects (Body)', {})
            bodyIDs = list(bodyGroup.keys()) if isinstance(bodyGroup, dict) else []
    
        # Add valid body IDs
        for bid in sorted(bodyIDs):
            combo.addItem(str(bid))
    
        if defaultStr and defaultStr not in bodyIDs:
            combo.addItem(defaultStr)
        combo.setCurrentText(defaultStr)
    
        # Create container with Highlight button
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(combo)
        
        # Add Highlight button
        from PyQt5.QtWidgets import QPushButton
        from guiForms.specialWidgets import setupRendererHighlighting
        highlightBtn = QPushButton("Highlight")
        highlightBtn.setToolTip("Highlight selected body in the OpenGL window")
        highlightBtn.setMaximumWidth(80)
        layout.addWidget(highlightBtn)
        
        def on_highlight_clicked():
            # Get the selected value from the combo box
            selected_text = combo.currentText()
            try:
                selected_index = int(selected_text)
                # Call the highlight function
                setupRendererHighlighting(parent, selected_index)
            except (ValueError, TypeError):
                debugLog(f"‚ö†Ô∏è [Highlighting] Invalid body number: {selected_text}", origin="autoGeneratedForm")
        
        highlightBtn.clicked.connect(on_highlight_clicked)
        
        # Store the combo box as an attribute for compatibility
        container.combo = combo
        container.getValue = lambda: combo.currentText()
        
        return container

    def buildNodeNumberWidget(fieldName, typeHint, default, parent=None, structure=None):
        combo = QComboBox()
        combo.setEditable(True)
        defaultStr = str(default)
    
        # Get body IDs from the structure, fallback to empty list
        bodyIDs = []
        if structure:
            bodyGroup = structure.get('Nodes', {})
            bodyIDs = list(bodyGroup.keys()) if isinstance(bodyGroup, dict) else []
    
        # Add valid body IDs
        for bid in sorted(bodyIDs):
            combo.addItem(str(bid))
    
        if defaultStr and defaultStr not in bodyIDs:
            combo.addItem(defaultStr)
        combo.setCurrentText(defaultStr)
    
        return combo

    def buildMarkerNumberWidget(fieldName, typeHint, default, parent=None, structure=None):
        combo = QComboBox()
        combo.setEditable(True)
        defaultStr = str(default)
    
        # Get body IDs from the structure, fallback to empty list
        bodyIDs = []
        if structure:
            bodyGroup = structure.get('Markers', {})
            bodyIDs = list(bodyGroup.keys()) if isinstance(bodyGroup, dict) else []
    
        # Add valid body IDs
        for bid in sorted(bodyIDs):
            combo.addItem(str(bid))
    
        if defaultStr and defaultStr not in bodyIDs:
            combo.addItem(defaultStr)
        combo.setCurrentText(defaultStr)
        return combo
    
    def sanitizeBaseName(self, name: str) -> str:
        """Remove Create/Object/etc. prefixes but preserve numbers at the end"""
        for prefix in ["Create", "Object", "Node", "Marker", "Load", "Sensor"]:
            if name.startswith(prefix):
                name = name[len(prefix):]
                break        # DON'T remove trailing digits - preserve user's numbered names!
        return name
        

    def findNextName(self, baseName: str) -> str:
        base = self.sanitizeBaseName(baseName)
        i = 1
        existing_lower = {n.lower() for n in self.existingNames}
        while f"{base}{i}".lower() in existing_lower:
            i += 1
        return f"{base}{i}"


    

    def createFieldWidget(self, fieldName, meta, userVariables=None, default=None):
        """
        Create a suitable input widget for one field.  If the field's type
        is vector/list‚Äêlike, we return a QLineEdit that expects "[1,2,3]" or
        "[m,0,0]".  Otherwise we fall back to QLineEdit (or QCheckBox for bool).
        """

        fieldType = meta.get("type", "string").lower()
        # Use the provided default (from existingData) if available, otherwise fall back to metadata default
        defaultValue = default if default is not None else meta.get("default", "")
        lname = fieldName.lower()

        # --- Special: outputVariableType with help button for selected entity ---
        if lname == "outputvariabletype":
            from PyQt5.QtWidgets import QHBoxLayout, QToolButton
            container = QWidget()
            layout = QHBoxLayout(container)
            layout.setContentsMargins(0, 0, 0, 0)

            # Use the normal widget for outputVariableType (e.g. combo box)
            from guiForms.specialWidgets import buildOutputVariableTypeWidget
            output_widget = buildOutputVariableTypeWidget(fieldName, defaultValue, meta, self, structure=getattr(self, 'structure', None))
            layout.addWidget(output_widget)

            # Add the help button
            help_btn = QToolButton()
            help_btn.setText("?")
            help_btn.setToolTip("Show help for the selected item in bodyNumber, objectNumber, nodeNumber, or loadNumber")
            layout.addWidget(help_btn)

            def show_selected_item_help():
                # Try each possible selector in order of priority
                for selector_field in ["bodyNumber", "objectNumber", "nodeNumber", "loadNumber"]:
                    widget = self.fields.get(selector_field)
                    if widget:
                        # Try to get the selected label/type from the combo box or widget
                        selected_label = None
                        # Try QComboBox
                        if hasattr(widget, 'combo') and hasattr(widget.combo, 'currentText'):
                            selected_label = widget.combo.currentText()
                        elif hasattr(widget, 'currentText'):
                            selected_label = widget.currentText()
                        elif hasattr(widget, 'getValue'):
                            selected_label = str(widget.getValue())
                        if selected_label:
                            # NEW: Extract index and get actual type from MBS (same logic as above)
                            try:
                                import re
                                
                                # Method 1: Try to extract index from various formats
                                index = None
                                group_type = None
                                
                                # Format: "[Object 1] Name (Type)" or "[Node 1] Name (Type)"
                                match = re.match(r'\[(\w+)\s+(\d+)\]', selected_label)
                                if match:
                                    group_name = match.group(1).lower()
                                    index = int(match.group(2))
                                    if group_name == 'object':
                                        group_type = 'objects'
                                    elif group_name == 'node':
                                        group_type = 'nodes'
                                    elif group_name == 'marker':
                                        group_type = 'markers'
                                    elif group_name == 'load':
                                        group_type = 'loads'
                                    elif group_name == 'sensor':
                                        group_type = 'sensors'
                                
                                # Format: "1 - Object_MassPoint2" or just "1"
                                if index is None:
                                    if ' - ' in selected_label:
                                        index_part = selected_label.split(' - ', 1)[0].strip()
                                    else:
                                        index_part = selected_label.strip()
                                    
                                    try:
                                        index = int(index_part)
                                        # Determine group type from field name
                                        if selector_field in ['bodyNumber', 'objectNumber']:
                                            group_type = 'objects'
                                        elif selector_field == 'nodeNumber':
                                            group_type = 'nodes'
                                        elif selector_field == 'loadNumber':
                                            group_type = 'loads'
                                    except ValueError:
                                        pass
                                
                                # Get actual type from MBS if we have index and group
                                if index is not None and group_type:
                                    from exudynGUI.core.modelManager import getActualComponentType
                                    # Get parent window to access mbs
                                    parent_window = self.parent()
                                    while parent_window and not hasattr(parent_window, 'mbs'):
                                        parent_window = parent_window.parent()
                                    
                                    if parent_window and hasattr(parent_window, 'mbs'):
                                        actual_type = getActualComponentType(parent_window.mbs, group_type, index)
                                        debugLog(f"‚úÖ Resolved {selector_field}[{index}] ‚Üí actual type: '{actual_type}'")
                                        
                                        # Use the actual type for help lookup
                                        type_name_normalized = actual_type.replace('_', '')
                                        debugLog(f"Trying PDF help for resolved type: '{type_name_normalized}'")
                                        start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, type_name_normalized)
                                        if start_page and end_page:
                                            dlg = SectionPdfImageDialog(self.pdfPath, list(range(start_page, end_page + 1)), parent=self)
                                            dlg.exec_()
                                            return
                                        else:
                                            debugLog(f"‚ö†Ô∏è No PDF help found for '{type_name_normalized}'")
                                    else:
                                        debugLog("‚ö†Ô∏è Could not access MBS from AutoGeneratedForm")
                                
                                # FALLBACK: Use old method if new method fails
                                match = re.search(r'-\s*([A-Za-z0-9_]+)$', selected_label)
                                if match:
                                    type_name = match.group(1)
                                else:
                                    # Fallback: try after last underscore
                                    type_name = selected_label.split('_')[-1]
                                # Try to open PDF help for this type
                                start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, type_name)
                                if start_page and end_page:
                                    dlg = SectionPdfImageDialog(self.pdfPath, list(range(start_page, end_page + 1)), parent=self)
                                    dlg.exec_()
                                    return
                                    
                            except Exception as e:
                                debugLog(f"‚ùå Error in help resolution: {e}")
                                import traceback
                                traceback.print_exc()
                
                # If nothing found, show a message
                QMessageBox.information(self, "Help", "No item selected or help not found for the selected entity.")

            help_btn.clicked.connect(show_selected_item_help)
            container.getValue = lambda: output_widget.getValue() if hasattr(output_widget, 'getValue') else None
            return container

        # --- NodeType field: use QComboBox for CREATE, QLineEdit for LEGACY ---
        if fieldName == "nodeType":
            # If objectType starts with 'Node' (legacy), use QLineEdit
            if getattr(self, 'objectType', '').startswith('Node'):
                line = QLineEdit(str(defaultValue))
                line.setPlaceholderText("e.g. Point, RigidBodyEP, ...")
                return line
            # Otherwise (CREATE), use dropdown
            combo = QComboBox()
            combo.addItems(NODE_TYPE_OPTIONS)
            # Accept both None and 'None' as invalid defaults
            if defaultValue and defaultValue not in (None, "None") and defaultValue in NODE_TYPE_OPTIONS:
                combo.setCurrentText(defaultValue)
            elif NODE_TYPE_DEFAULT in NODE_TYPE_OPTIONS:
                combo.setCurrentText(NODE_TYPE_DEFAULT)
            else:
                combo.setCurrentIndex(0)
            return combo

        # --- Special handling for CreateRigidBodySpringDamper.offset: use 6D vector widget with expression support ---
        if self.objectType == "CreateRigidBodySpringDamper" and fieldName == "offset":
            return buildVec6Widget(fieldName, value=defaultValue, parent=self, meta=meta, default=meta.get("default", [0,0,0,0,0,0]), userVariables=userVariables or {})

        # --- Always use matrix widget for Matrix3D fields ---
        if fieldType in ("matrix3d", "matrix3x3[list]", "matrix"):  # support all naming variants
            return buildMatrix3x3Widget(fieldName, value=defaultValue, parent=self, meta=meta, default=defaultValue, userVariables=userVariables or {})

        # Special handling for constrainedAxes: use EnhancedIntNWidget with correct N
        if lname == "constrainedaxes":
            # --- Patch: SphericalJoint should always have N=3 and default [1,1,1] ---
            if getattr(self, 'objectType', '').lower() == 'createsphericaljoint' or 'sphericaljoint' in getattr(self, 'objectType', '').lower():
                N = 3
                defaultValue = [1,1,1]
            else:
                N = 6
                # Try to get N from type if possible (e.g. intvector3, intvector6, etc.)
                if "3" in fieldType:
                    N = 3
                elif "6" in fieldType:
                    N = 6
                elif isinstance(defaultValue, (list, tuple)):
                    N = len(defaultValue)
                elif isinstance(defaultValue, str) and defaultValue.startswith("["):
                    try:
                        arr = ast.literal_eval(defaultValue)
                        if isinstance(arr, (list, tuple)):
                            N = len(arr)
                    except Exception:
                        pass
            return buildIntNWidget(fieldName, default=defaultValue, meta=meta, parent=self, N=N)
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # (1) If this is CreateSpringDamper.referenceLength, force a blank field.
        if lname == "referencelength" and self.objectType == "CreateSpringDamper":
            line = QLineEdit()
            line.setPlaceholderText("leave empty ‚Üí computed automatically")
            return line
    
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # (2) If this is CreateDistanceConstraint.distance, force a blank field.
        if lname == "distance" and self.objectType == "CreateDistanceConstraint":
            line = QLineEdit()
            line.setPlaceholderText("leave empty ‚Üí computed automatically")
            return line
    
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        # --- Special handling for CreateRigidBodySpringDamper: always use 6x6 matrix widget for stiffness/damping ---
        if self.objectType == "CreateRigidBodySpringDamper" and fieldName in ("stiffness", "damping"):
            # Always use a 6x6 matrix widget, ignore type/metadata
            return buildMatrix6x6Widget(fieldName, value=defaultValue, parent=self, meta=meta, default=meta.get("default", np.zeros((6,6)).tolist()))

        # --- Special handling for graphicsDataList: use main window's temporary list ---
        if fieldName == "graphicsDataList":
            from PyQt5.QtWidgets import QPushButton, QVBoxLayout, QWidget, QLabel
            container = QWidget()
            layout = QVBoxLayout(container)
            mainWindow = self.parent()

            def getGraphicsCount():
                if mainWindow and hasattr(mainWindow, "getTemporaryGraphicsList"):
                    return len(mainWindow.getTemporaryGraphicsList())
                return 0

            label = QLabel(f"{getGraphicsCount()} graphics")
            btn = QPushButton("Edit in Main Window")
            layout.addWidget(label)
            layout.addWidget(btn)

            # Set initial graphics list in main window
            if mainWindow and hasattr(mainWindow, "setTemporaryGraphicsList"):
                mainWindow.setTemporaryGraphicsList(self.existingData.get("graphicsDataList", []))

            def updateLabel():
                label.setText(f"{getGraphicsCount()} graphics")

            def onEdit():
                if mainWindow and hasattr(mainWindow, "startGraphicsEdit"):
                    mainWindow.startGraphicsEdit(self.existingData.get("graphicsDataList", []))
                updateLabel()
            btn.clicked.connect(onEdit)

            # Optionally, connect to a signal if your mainWindow emits one after graphics edit is accepted:
            if mainWindow and hasattr(mainWindow, "graphicsEditAccepted"):
                try:
                    mainWindow.graphicsEditAccepted.connect(lambda _: updateLabel())
                except Exception:
                    pass

            # Provide a getValue method for data collection
            container.getValue = lambda: (
                mainWindow.getTemporaryGraphicsList() if mainWindow and hasattr(mainWindow, "getTemporaryGraphicsList") else []
            )
            return container

        # === Step 1: "vector" or "list" types get a QLineEdit that can accept [ ‚Ä¶ ] literals or variables ‚âî "[m,0,0]" ===
        if any(substr in fieldType for substr in ("vector", "list")):
            line = QLineEdit()
            line.setPlaceholderText("e.g. [m, 0, 0] or [100, 100, 100]")

            # If there's a pure‚Äêpython default (like [100,100,100]), display it in gray:
            if defaultValue not in ("", None):
                line.setText(str(defaultValue))
                line.setStyleSheet("color: gray;")

                # ‚úÖ Store default value to avoid closure issues
                line._defaultValue = str(defaultValue)
                line._hasDefaultValue = True

                def on_focus_safe(event):
                    # ‚úÖ Safely clear the gray default when user clicks into the box
                    if hasattr(line, '_hasDefaultValue') and line._hasDefaultValue:
                        if line.text() == line._defaultValue:
                            line.clear()
                        line.setStyleSheet("color: black;")
                        line._hasDefaultValue = False
                    # Call the original focus event handler
                    QLineEdit.focusInEvent(line, event)

                # ‚úÖ Use a proper method override instead of lambda
                line.focusInEvent = on_focus_safe

            return line



        # === Step 2: Boolean fields ‚Üí QCheckBox ===
        if fieldType == "bool":
            box = QCheckBox()
            box.setChecked(bool(defaultValue))
            return box

        # === Step 3: Everything else ‚Üí plain QLineEdit ===
        field = QLineEdit(str(defaultValue))
        if meta.get("required", False):
            field.setPlaceholderText("required")
        return field

    def setFieldValue(self, fieldName, value):
        """Set the widget value for a field in the form, if it exists."""
        if fieldName in self.fields:
            widget = self.fields[fieldName]
            setValueToWidget(widget, value)  # import from widgetUtils


    def _getFieldValue(self, widget):
        """Get the value from a field widget, handling various widget types including container widgets."""
        try:
            # Handle container widgets (for dual-field widgets with highlight buttons)
            if hasattr(widget, 'original_widget'):
                # This is a container widget, get value from the original widget
                return self._getFieldValue(widget.original_widget)
            
            # Handle special widgets with getValue method
            if hasattr(widget, 'getValue'):
                return widget.getValue()
            
            # Handle QComboBox
            if hasattr(widget, 'currentData'):
                return widget.currentData()
            
            # Handle QLineEdit
            if hasattr(widget, 'text'):
                return widget.text()
            
            # Handle QSpinBox
            if hasattr(widget, 'value'):
                return widget.value()
            
            # Handle QCheckBox
            if hasattr(widget, 'isChecked'):
                return widget.isChecked()
            
            # Handle QListWidget
            if hasattr(widget, 'selectedItems'):
                items = widget.selectedItems()
                if items:
                    return [item.text() for item in items]
                return []
            
            # Handle QTableWidget
            if hasattr(widget, 'item'):
                # This is a simplified table handling - you might need to customize this
                return "table_data"  # Placeholder
            
            # Default fallback
            return None
            
        except Exception as e:
            debugLog(f"Error getting field value: {e}", origin="AutoGeneratedForm")
            return None



    def get_data(self):
        if hasattr(self, '_data'):
            # üîÅ Patch: ensure excluded fields have safe values
            for group in getattr(self, 'exclusiveGroups', []):
                selected = self.fields[group['label']].currentText()
                for fieldName in group['options']:
                    if fieldName == selected:
                        continue
                    # üß© Ensure excluded fields are always present with safe default
                    if fieldName not in self._data:
                        meta = self.fieldMetadata.get(fieldName, {})
                        ftype = meta.get('type', '').lower()
                        if ftype in ['bodylist', 'bodyornodelist', 'bodynumbers']:
                            self._data[fieldName] = [None, None]
                        else:
                            self._data[fieldName] = None

            return self._data
    
        debugLog("[AutoGeneratedForm.get_data] ‚ö†Ô∏è Called before accept()", origin="AutoGeneratedForm")
        return {}


    def simulateAccept(self):
        """Simulate accept() without closing the form or showing dialogs."""
        self.values = {}
        self.accepted = False
    
        # Track fields already processed
        handledFields = set()
        excludedFields = set()
        selectedFields = set()
    
        for group in self.exclusiveGroups:
            selected = self.fields[group['label']].currentText()
            excluded = set(group['options']) - {selected}
            excludedFields.update(excluded)
            selectedFields.add(selected)
    
        skipFields = excludedFields
        YELLOW_WARNING_WHITELIST = ['stiffness', 'mass', 'damping', 'physicsMass', 'drawSize', 'create2D', 'returnDict']
    
        for fieldName, widget in self.fields.items():
            if fieldName in skipFields:
                continue
            handledFields.add(fieldName)
    
            rawValue = extractValueFromWidget(widget)
            if isinstance(rawValue, str):
                valueStr = rawValue.strip()
                if (valueStr.startswith('[') and valueStr.endswith(']')) or \
                   (valueStr.startswith('{') and valueStr.endswith('}')) or \
                   valueStr.lower() in ['true', 'false'] or \
                   valueStr.replace('.', '', 1).replace('-', '', 1).isdigit():
                    try:
                        rawValue = ast.literal_eval(valueStr)
                    except Exception:
                        pass
    
            meta = self.fieldMetadata.get(fieldName, {})
            if rawValue in ['', None]:
                fallback = meta.get("default")
                if fallback not in ['', None]:
                    rawValue = fallback
    
            if fieldName.endswith('UserFunction'):
                if rawValue in ['None', '', None, '0']:
                    rawValue = 0
                elif isinstance(rawValue, str):
                    rawValue = rawValue.strip()
                    if rawValue == '0':
                        rawValue = 0
    
            if fieldName == "graphicsDataList" and isinstance(rawValue, list):
                rawValue = [
                    {k: v for k, v in entry.items() if k in ['name', 'args']}
                    for entry in rawValue if isinstance(entry, dict) and 'name' in entry and 'args' in entry
                ]
    
            metaType = meta.get("type", "unknown")
            try:
                # If it's a string and NOT a literal or expression, preserve it (e.g., 'm')
                shouldPreserveVariable = (
                    isinstance(rawValue, str)
                    and metaType.lower() in ['float', 'real', 'int', 'vector', 'list<float>', 'list<real>', 'list<int>']
                    and not rawValue.strip().isdigit()
                    and not rawValue.strip().startswith('[')  # avoid list literals
                    and not rawValue.strip().startswith('{')  # avoid dict literals
                    and not rawValue.strip().lower() in ['true', 'false']
                )
                
                if shouldPreserveVariable:
                    # üß† Preserve symbolic input like 'm' or 'k+3*m' for post-substitution
                    debugLog(f"[accept] üß¨ Preserving symbolic variable for {fieldName}: {rawValue}")
                    converted = rawValue
                else:
                    try:
                        converted = convertToType(rawValue, metaType)
                    except Exception as e:
                        debugLog(f"[accept] ‚ùå Failed to convert {fieldName}='{rawValue}' to {metaType}: {e}")
                        converted = rawValue

            except Exception:
                converted = rawValue
    
            self.values[fieldName] = converted
    
        for excluded in excludedFields:
            self.values.pop(excluded, None)
    
        self.values['name'] = self.fields['name'].text().strip()
        self._data = self.values

    def collectAndNormalizeData(self):
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # (we already imported isMeaningfulDefault, evaluateExpression, etc. at top)
        self.values = {}
        self.accepted = False
        hasWarnings = False
        warningFields = []
        self._clearHighlighting(self.SC)
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Define "weak default" list ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        YELLOW_WARNING_WHITELIST = [
            'stiffness', 'mass', 'damping',
            'physicsMass', 'drawSize', 'create2D', 'returnDict'
        ]

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Identify "excludedFields" from any exclusive selectors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        excludedFields = set()
        for group in getattr(self, 'exclusiveGroups', []):
            selected = self.fields[group['label']].currentText()
            excludedFields.update(set(group['options']) - {selected})

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Loop over every field/widget ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        for fieldName, widget in self.fields.items():
            if fieldName in excludedFields:
                continue

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 0: look up metadata for this field ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            meta = self.fieldMetadata.get(fieldName, {})
            metaType = meta.get("type", "string").lower()

            if fieldName.lower() == "inertia":
                rawDict = extractValueFromWidget(widget)
                if isinstance(rawDict, list) and len(rawDict) > 0:
                    rawDict = rawDict[0]
                try:
                    # Convert to actual function call: exuutils.InertiaSphere(...)
                    funcName = rawDict.get("name", "")
                    argsStr = rawDict.get("args", "")
                    import exudyn.utilities as exuutils
                    inertiaFunc = getattr(exuutils, funcName)
                    finalValue = eval(f"inertiaFunc({argsStr})")
                    debugLog(f"[accept] inertia = {finalValue}", origin="AutoGeneratedForm")
                except Exception as e:
                    debugLog(f"[accept] ‚ùå Failed to evaluate inertia: {e}", origin="AutoGeneratedForm")
                    finalValue = None


            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 1 (VECTOR3): if metaType contains "vector" & "3",
            # look inside for the QLineEdit child first. If user typed anything in that line,
            # use it verbatim. Otherwise fall back to the 3 spinboxes via extractValueFromWidget().
            if isinstance(metaType, str) and "vector" in metaType and "3" in metaType:
                # find the QLineEdit that buildVec3Widget created:
                le = widget.findChild(QLineEdit)
                if le is not None and le.text().strip() != "":
                    rawValue = le.text().strip()
                else:
                    rawValue = extractValueFromWidget(widget)
            else:
                # not a vector3 field ‚Üí normal extract
                rawValue = extractValueFromWidget(widget)

            debugLog(f"[accept] üîé {fieldName} raw = {repr(rawValue)} "
                     f"(type: {type(rawValue).__name__})")

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 2: If rawValue is a string AND metaType says "vector" or "list",
            # attempt to parse ‚Ä¶ but do NOT call evaluateExpression(token) on every token.
            if isinstance(rawValue, str) and any(substr in metaType for substr in ("vector", "list")):
                # txt = rawValue.strip()
                # # 2.a) If it looks like "[ ‚Ä¶ ]", try literal_eval ‚Üí Python list
                # if txt.startswith("[") and txt.endswith("]"):
                #     try:
                #         py_list = ast.literal_eval(txt)
                #     except Exception:
                #         # fallback: manually split by commas, but DO NOT call evaluateExpression()
                #         inner = txt[1:-1]
                #         tokens = [t.strip() for t in inner.split(",")]
                #         eval_list = []
                #         for tk in tokens:
                #             # if token is empty string, keep it
                #             if tk == "":
                #                 eval_list.append(tk)
                #             else:
                #                 # DO NOT evaluate token against userVariables here
                #                 # Just preserve it as a string if it isn't a pure number
                #                 try:
                #                     fv = float(tk)
                #                 except Exception:
                #                     fv = tk   # keep "k" as literally "k"
                #                 eval_list.append(fv)
                #         try:
                #             converted = [float(x) for x in eval_list]
                #         except Exception:
                #             converted = eval_list
                #     else:
                #         # literal_eval succeeded (likely all numbers), cast them to float:
                #         try:
                #             converted = [float(x) for x in py_list]
                #         except Exception:
                #             converted = py_list
                # else:
                    # 2.b) Maybe user typed "k" (no brackets) ‚Üí we'll just store the string "k"
                    # (don't call evaluateExpression here, because we want to remain symbolic)
                converted = rawValue

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 3: If rawValue is some other string (e.g. "123" or "{‚Ä¶}" or "true"),
            # try a simple literal_eval
            elif isinstance(rawValue, str):
                valueStr = rawValue.strip()
                if (
                    (valueStr.startswith("[") and valueStr.endswith("]"))
                    or (valueStr.startswith("{") and valueStr.endswith("}"))
                    or valueStr.lower() in ["true", "false"]
                    or valueStr.replace(".", "", 1).replace("-", "", 1).isdigit()
                ):
                    try:
                        converted = ast.literal_eval(valueStr)
                        debugLog(f"[accept] üß† Parsed simple literal for {fieldName}: {converted!r}")
                    except Exception:
                        converted = rawValue
                else:
                    converted = rawValue

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 4: Otherwise (rawValue is not a string), keep it as-is
            else:
                converted = rawValue

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 5: If conversion produced "empty," fall back to metadata default
            if converted in ("", None):
                fallback = meta.get("default")
                if fallback not in ("", None):
                    debugLog(f"[accept] üõ†Ô∏è Fallback for {fieldName}: {fallback}")
                    converted = fallback

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 6 (UserFunction fields): keep symbolic if user typed a name
            if fieldName.endswith("UserFunction"):
                if converted in ("None", "", None, "0"):
                    converted = 0
                elif isinstance(converted, str):
                    converted = converted.strip()

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 7 (graphicsDataList): strip down each entry to {name, args}
            if fieldName == "graphicsDataList" and isinstance(converted, list):
                converted = [
                    {k: v for k, v in entry.items() if k in ("name", "args")}
                    for entry in converted if isinstance(entry, dict)
                ]

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 8: If it's a list that still contains a string,
            # skip convertToType (we will do symbolic resolution later). Otherwise coerce.
            if isinstance(converted, list) and any(isinstance(x, str) for x in converted):
                finalValue = converted
            else:
                try:
                    finalValue = convertToType(converted, meta.get("type", "unknown"))
                except Exception as e:
                    debugLog(f"[accept] ‚ùå Failed to convert {fieldName}={converted!r} ‚Üí {meta.get('type')}: {e}")
                    finalValue = converted

            # --- Patch: convert nodeType string to exudyn.NodeType enum for Exudyn ---
            if fieldName == "nodeType" and isinstance(finalValue, str):
                try:
                    import exudyn as exu
                    finalValue = getattr(exu.NodeType, finalValue)
                except Exception:
                    pass

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 9: Now run the validator (and color red/yellow if needed)
            validator = meta.get("validator")
            isValid, msg = True, ""
            if validator and callable(validator):
                try:
                    isValid, msg = validator(fieldName, finalValue)
                except Exception as e:
                    isValid, msg = False, str(e)

            widget.setStyleSheet("")
            widget.setToolTip("")
            if not isValid:
                widget.setStyleSheet("background-color: #FFCCCC")
                widget.setToolTip(msg)
                hasWarnings = True
                warningFields.append(fieldName)
                debugLog(f"[accept] ‚ö†Ô∏è {fieldName}: {msg}")
            elif not isMeaningfulDefault(finalValue, fieldName) and (fieldName not in YELLOW_WARNING_WHITELIST):
                widget.setStyleSheet("background-color: #FFFFAA")
                widget.setToolTip("Value may be too small, empty, or placeholder")
                hasWarnings = True
                warningFields.append(fieldName)
                debugLog(f"[accept] ‚ö†Ô∏è {fieldName} is weak: {finalValue!r}")

            debugLog(f"[accept] ‚úÖ Stored: {fieldName} = {repr(finalValue)}")
            self.values[fieldName] = finalValue

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 10: Validate name for duplicates before final submission ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        name = self.fields["name"].text().strip()
          # Final check for name collision (preventing form submission with duplicate names)
        existing_names_set = {name.lower() for name in self.existingNames}
        if hasattr(self, 'originalName') and self.originalName:
            existing_names_set.discard(self.originalName.lower())
        
        if name.lower() in existing_names_set:
            # Critical error: duplicate name - prevent form submission
            nameWidget = self.fields["name"]
            nameWidget.setStyleSheet("background-color: #FFCCCC; border: 2px solid red;")
            nameWidget.setToolTip(f"‚ùå Name '{name}' already exists! Please choose a different name.")
            
            QMessageBox.critical(
                self,
                "Duplicate Name Error",
                f"The name '{name}' is already in use.\n\n"
                f"Please choose a different name before saving."
            )
            debugLog(f"[accept] ‚ùå BLOCKED: Form submission prevented due to duplicate name: '{name}'")
            # ‚úÖ For preview, still return the data but flag the error
            # For actual form submission, this will be caught elsewhere
            if hasattr(self, '_isPreview') or 'preview' in str(getattr(self, '_caller', '')).lower():
                debugLog(f"[collectAndNormalizeData] ‚ö†Ô∏è Preview mode: returning data despite name collision")
                # Continue processing and return data for preview
            else:
                return {}  # Return empty dict instead of None
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 11: Filter out GUI-only fields for legacy items before final submission ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Remove fields that should not be passed to legacy constructor calls
        if (self.objectType.startswith(('Object', 'Node', 'Marker', 'Load', 'Sensor')) and 
            not self.objectType.startswith('Create')):
            gui_only_fields = ['nodeType', 'markerType', 'summaryPythonCode', 'isLegacy']
            filtered_fields = []
            for field in gui_only_fields:
                if field in self.values:
                    filtered_fields.append(field)
                    del self.values[field]
            
            if filtered_fields:
                debugLog(f"üîß [AutoGeneratedForm.accept] Final filtering of GUI-only fields from {self.objectType}: {filtered_fields}")
            # --- Normalize graphicsDataList entries to {'name': ..., 'args': ...} ---
        data = self.get_data()

        # --- Normalize graphicsDataList entries to {'name': ..., 'args': ...} ---
        def parseGraphicsString(entry):
            """Convert 'exu.graphics.NAME(args)' to {'name': NAME, 'args': args}"""
            if isinstance(entry, str) and entry.startswith('exu.graphics.') and '(' in entry:
                try:
                    fnName = entry[len('exu.graphics.'):entry.index('(')]
                    fnArgs = entry[entry.index('(')+1:-1]
                    return {'name': fnName, 'args': fnArgs}
                except Exception as e:
                    debugLog(f"[WARNING] Failed to parse graphics string: {entry} ‚Üí {e}", origin="AutoGeneratedForm.parseGraphicsString")
            return entry  # Return unchanged if already dict or invalid format

        # Apply normalization to graphicsDataList
        if 'graphicsDataList' in data and isinstance(data['graphicsDataList'], list):
            data['graphicsDataList'] = [parseGraphicsString(e) for e in data['graphicsDataList']]        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 12: Finally save validated name and call super() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.values["name"] = name
        self._data = self.values
        self.accepted = True

        debugLog(f"[accept] ‚úÖ Final form data: {summarizeDict(self.values)}")
          # üéØ SAVE VIEW STATE: Right after user clicks OK, before form closes
        try:
            from exudynGUI.core.rendererState import saveViewStateWithAutoRestore
            # Get parent window from the form's parent chain
            parent_window = self.parent()
            while parent_window and not hasattr(parent_window, 'mbs'):
                parent_window = parent_window.parent()
            
            if parent_window and saveViewStateWithAutoRestore(parent_window, "after_ok_clicked", duration=2.0):
                debugLog("[accept] üìå Saved view state with auto-restore after OK clicked", origin="AutoGeneratedForm")
            else:
                debugLog("[accept] ‚ö†Ô∏è Failed to save view state with auto-restore after OK clicked", origin="AutoGeneratedForm")
        except Exception as e:
            debugLog(f"[accept] ‚ö†Ô∏è View state auto-restore setup failed: {e}", origin="AutoGeneratedForm")


        return self.values


    def accept(self):
        mainWindow = self.parent()
        if hasattr(self, "_previewUndo") and self._previewUndo:
            mainWindow.undoLastAction()
            self._previewUndo = False
        self.values = self.collectAndNormalizeData()
        if not self.values:  # If duplicate or error, do not close the dialog
            return
        super().accept()

    def reject(self):
        # Clear all highlights when form is closed
        try:
            SC = None
            if hasattr(self, 'SC') and self.SC:
                SC = self.SC
            elif hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'SC'):
                SC = self.parent.SC
            
            if SC:
                self._clearHighlighting(SC)
                debugLog(f"[Form] Cleared all highlights on form close", origin="AutoGeneratedForm")
        except Exception as e:
            debugLog(f"[Form] Failed to clear highlights on close: {e}", origin="AutoGeneratedForm")
        
        mainWindow = self.parent()
        if hasattr(self, "_previewUndo") and self._previewUndo:
            mainWindow.undoLastAction()
            self._previewUndo = False
        super().reject()

    def _showFieldHelp(self, fieldName: str, helpText: str):
        """Show a detailed help dialog for a specific field or type, using rich legacy help if available."""
        from guiForms.addItemDialog import AddModelElementDialog
        # Try to use the rich legacy help if possible
        typeName = getattr(self, 'objectType', None)
        rich_help = None
        if typeName:
            # Use the AddModelElementDialog logic for legacy types
            try:
                dlg = AddModelElementDialog(parent=self, pdfBookmarks=getattr(self, '_pdfBookmarks', None), pdfPath=getattr(self, '_pdfPath', None))
                rich_help = dlg._getLegacyHelpFromMetadata(typeName)
            except Exception:
                rich_help = None
        # Prefer rich help if available and relevant
        display_help = rich_help if (rich_help and len(rich_help) > 100) else helpText
        msgBox = QMessageBox(self)
        msgBox.setWindowTitle(f"Help: {fieldName}")
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setText(f"<pre>{display_help}</pre>")
        # Add PDF button if rich help was used and PDF is available
        if rich_help and hasattr(self, 'pdfPath') and hasattr(self, 'pdfBookmarks'):
            from PyQt5.QtWidgets import QPushButton
            pdf_btn = QPushButton("View PDF Documentation")
            def open_pdf():
                from theDocHelper.theDocFieldHelp import getLegacyItemPageRange, SectionPdfImageDialog
                start_page, end_page = getLegacyItemPageRange(self.pdfPath, self.pdfBookmarks, typeName)
                if start_page and end_page:
                    dlg = SectionPdfImageDialog(self.pdfPath, list(range(start_page, end_page + 1)), parent=self)
                    dlg.exec_()
            pdf_btn.clicked.connect(open_pdf)
            msgBox.addButton(pdf_btn, QMessageBox.ActionRole)
        msgBox.exec_()
    def _setupRendererHighlighting(self):
        """
        Set up highlighting in the 3D renderer when relevant fields are selected/changed.
        This connects field widgets to the visualization highlighting system with multi-color support.
        """
        debugLog(f"üéØ [Highlighting] Setting up multi-color renderer highlighting for {self.objectType}", origin="AutoGeneratedForm")
        
        # Initialize multi-color highlighting tracking
        self._activeHighlights = {}  # fieldName -> {type, index, color}
        self._fieldColors = {}  # fieldName -> color
        self._highlightRotationTimer = None
        
        # Try to get SC directly first, then from parent as fallback
        SC = None
        
        if hasattr(self, 'SC') and self.SC:
            SC = self.SC
            debugLog(f"‚úÖ [Highlighting] Using directly provided SC: {type(SC)}", origin="autoGeneratedForm")
        elif hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'SC'):
            SC = self.parent.SC  # Very visible debug
            debugLog(f"‚úÖ [Highlighting] Using SC from parent: {type(SC)}", origin="autoGeneratedForm")
        
        # Check if we actually found an SC
        if not SC: # Very visible debug
            debugLog("‚ö†Ô∏è [Highlighting] No SC available (neither direct nor from parent)", origin="autoGeneratedForm")
            if hasattr(self, 'parent') and self.parent:
                debugLog(f"üîç [Highlighting] Parent type: {type(self.parent)}", origin="AutoGeneratedForm")
                debugLog(f"üîç [Highlighting] Parent has SC? {hasattr(self.parent, 'SC')}", origin="AutoGeneratedForm")
                debugLog(f"üîç [Highlighting] Parent attributes: {[attr for attr in dir(self.parent) if not attr.startswith('_')][:10]}", origin="AutoGeneratedForm")
            return
        # Very visible debug
        debugLog(f"üöÄ [Highlighting] Proceeding with multi-color SC setup", origin="AutoGeneratedForm")
            
        # Define field mappings to Exudyn highlight types
        # These need to match Exudyn's ItemType values
        highlight_mappings = {
            'bodynumber': 'Object',     # Bodies are Objects in Exudyn
            'objectnumber': 'Object', 
            'nodenumber': 'Node',
            'markernumber': 'Marker',
            'loadnumber': 'Load',
            'sensornumber': 'Sensor'
        }
        
        # Define predefined colors for different fields
        self._predefinedColors = {
            'primary': [0.8, 0.05, 0.05, 0.75],    # Red for first/left field
            'secondary': [0.05, 0.05, 0.8, 0.75],  # Blue for second/right field  
            'tertiary': [0.05, 0.8, 0.05, 0.75],   # Green for third field
            'quaternary': [0.8, 0.8, 0.05, 0.75],  # Yellow for fourth field
            'quinary': [0.8, 0.05, 0.8, 0.75],     # Magenta for fifth field
        }
        
        debugLog(f"üîç [Highlighting] Available fields: {list(self.fields.keys())}", origin="AutoGeneratedForm")
        
        # Connect each relevant field to highlighting and assign colors
        connected_count = 0
        color_index = 0
        color_names = list(self._predefinedColors.keys())
        
        for fieldName, widget in self.fields.items():
            if fieldName.lower() in [key.lower() for key in highlight_mappings]:
                # If this is a container with an entity_selector, check its type
                if hasattr(widget, 'entity_selector'):
                    if getattr(widget.entity_selector, 'fieldType', None) == 'bodyNumber':
                        continue
                # Otherwise, skip direct bodyNumber fields
                if fieldName.lower() == 'bodynumber':
                    continue
                self._connectFieldToHighlighting(fieldName, widget, SC, highlight_mappings)
                connected_count += 1

        # Also handle exclusive group fields
        for group in getattr(self, 'exclusiveGroups', []):
            for fieldName in group['options']:
                if fieldName.lower() in [key.lower() for key in highlight_mappings]:
                    widget = self.fields.get(fieldName)
                    if widget:
                        if hasattr(widget, 'entity_selector'):
                            if getattr(widget.entity_selector, 'fieldType', None) == 'bodyNumber':
                                continue
                        if fieldName.lower() == 'bodynumber':
                            continue
                        self._connectFieldToHighlighting(fieldName, widget, SC, highlight_mappings)
                        connected_count += 1
          # Special handling for dual-field widgets (e.g., bodyNumbers with two combo boxes)
        connected_count = self._connectDualFieldHighlighting(SC, highlight_mappings, connected_count, color_index, color_names)
        
        debugLog(f"‚úÖ [Highlighting] Connected {connected_count} fields for multi-color highlighting", origin="AutoGeneratedForm")
    def replayAllHighlights(self):
        """
        Re-emit each combo's currentIndexChanged so that the
        form's own highlighting logic fires on whatever is selected.
        """
        from PyQt5.QtWidgets import QComboBox

        # must use the same mapping you used in _setupRendererHighlighting
        highlight_keys = {
            'bodynumber',
            'nodenumber',
            'markernumber',
            'loadnumber',
            'sensornumber',
            'objectnumber',
        }

        for name, widget in self.fields.items():
            if name.lower() in highlight_keys:
                # find the QComboBox
                combo = getattr(widget, 'combo', None)
                if combo is None and isinstance(widget, QComboBox):
                    combo = widget
                if combo:
                    idx = combo.currentIndex()
                    combo.currentIndexChanged.emit(idx)
    def _connectDualFieldHighlighting(self, SC, highlight_mappings, connected_count, color_index, color_names):
        """Handle highlighting for special dual-field widgets (e.g., bodyNumbers with two combo boxes)."""
        # Define which fields are dual-field widgets and their highlight types
        dual_field_mappings = {
            'bodynumbers': 'Object',
            'nodenumbers': 'Node', 
            'markernumbers': 'Marker',
            'objectnumbers': 'Object',
            'sensornumbers': 'Sensor',
            'loadnumbers': 'Load'
        }
        
        for fieldName, widget in self.fields.items():
            field_lower = fieldName.lower()
            
            # Check if this is a dual-field widget
            if field_lower in dual_field_mappings:
                highlight_type = dual_field_mappings[field_lower]
                
                # Look for dual combo boxes in the widget structure
                combo0 = None
                combo1 = None
                
                # Check different possible structures
                if hasattr(widget, 'combo0') and hasattr(widget, 'combo1'):
                    # Direct combo0/combo1 attributes (like buildBodyPairSelectorWidget)
                    combo0 = widget.combo0
                    combo1 = widget.combo1
                    debugLog(f"üîó [Dual-Field] Found combo0/combo1 in {fieldName}", origin="AutoGeneratedForm")
                    
                elif hasattr(widget, 'combo1') and hasattr(widget, 'combo2'):
                    # Alternative naming (combo1/combo2)
                    combo0 = widget.combo1
                    combo1 = widget.combo2
                    debugLog(f"üîó [Dual-Field] Found combo1/combo2 in {fieldName}", origin="AutoGeneratedForm")
                
                else:
                    # Look for child combo boxes
                    combos = widget.findChildren(QComboBox)
                    if len(combos) >= 2:
                        combo0 = combos[0]
                        combo1 = combos[1]
                        debugLog(f"üîó [Dual-Field] Found child combos in {fieldName}: {len(combos)} total", origin="AutoGeneratedForm")
                
                # If we found dual combo boxes, add a highlight button
                if combo0 and combo1:
                    # Assign distinct colors
                    if color_index < len(color_names):
                        color0_name = color_names[color_index]
                        color0 = self._predefinedColors[color0_name]
                        color_index += 1
                    else:
                        color0 = self._predefinedColors['primary']
                    
                    if color_index < len(color_names):
                        color1_name = color_names[color_index] 
                        color1 = self._predefinedColors[color1_name]
                        color_index += 1
                    else:
                        color1 = self._predefinedColors['secondary']
                    
                    # Store colors for field components
                    self._fieldColors[f"{fieldName}_0"] = color0
                    self._fieldColors[f"{fieldName}_1"] = color1
                    
                    # Create a highlight button for this dual-field widget
                    highlightBtn = QPushButton("Highlight")
                    highlightBtn.setCheckable(True)  # Make it a toggle button
                    highlightBtn.setMaximumWidth(80)
                    
                    # Store references for later use
                    widget.highlightBtn = highlightBtn
                    widget.combo0 = combo0
                    widget.combo1 = combo1
                    widget.highlight_type = highlight_type
                    widget.fieldName = fieldName
                    
                    # Define the highlight function for this specific widget
                    def create_highlight_function(widget_ref=widget, SC_ref=SC):
                        def do_highlight():
                            """Highlight both selected items with their respective colors."""
                            try:
                                # Get current values from both combo boxes
                                item0 = widget_ref.combo0.currentData()
                                item1 = widget_ref.combo1.currentData()
                                
                                # Clear any existing highlights for this field
                                if f"{widget_ref.fieldName}_0" in self._activeHighlights:
                                    del self._activeHighlights[f"{widget_ref.fieldName}_0"]
                                if f"{widget_ref.fieldName}_1" in self._activeHighlights:
                                    del self._activeHighlights[f"{widget_ref.fieldName}_1"]
                                
                                # Add highlights for both items if they have valid data
                                if item0 is not None:
                                    self._activeHighlights[f"{widget_ref.fieldName}_0"] = {
                                        'type': self._getItemType(widget_ref.highlight_type),
                                        'index': item0,
                                        'color': self._fieldColors[f"{widget_ref.fieldName}_0"]
                                    }
                                
                                if item1 is not None:
                                    self._activeHighlights[f"{widget_ref.fieldName}_1"] = {
                                        'type': self._getItemType(widget_ref.highlight_type),
                                        'index': item1,
                                        'color': self._fieldColors[f"{widget_ref.fieldName}_1"]
                                    }
                                
                                # Update the renderer
                                self._updateActiveHighlighting(SC_ref)
                                debugLog(f"üé® [Dual-Field] Highlighted {widget_ref.fieldName}: item0={item0}, item1={item1}", origin="AutoGeneratedForm")
                                
                            except Exception as e:
                                debugLog(f"‚ùå [Dual-Field] Failed to highlight {widget_ref.fieldName}: {e}", origin="AutoGeneratedForm")
                        
                        def clear_highlight():
                            """Clear highlighting for this field."""
                            try:
                                # Remove highlights for this field
                                if f"{widget_ref.fieldName}_0" in self._activeHighlights:
                                    del self._activeHighlights[f"{widget_ref.fieldName}_0"]
                                if f"{widget_ref.fieldName}_1" in self._activeHighlights:
                                    del self._activeHighlights[f"{widget_ref.fieldName}_1"]
                                
                                # Update the renderer
                                self._updateActiveHighlighting(SC_ref)
                                debugLog(f"üé® [Dual-Field] Cleared highlighting for {widget_ref.fieldName}", origin="AutoGeneratedForm")
                                
                            except Exception as e:
                                debugLog(f"‚ùå [Dual-Field] Failed to clear highlighting for {widget_ref.fieldName}: {e}", origin="AutoGeneratedForm")
                        
                        return do_highlight, clear_highlight
                    
                    # Create the highlight functions
                    do_highlight, clear_highlight = create_highlight_function()
                    
                    # Connect button toggle to highlight functions
                    def on_highlight_toggled(checked):
                        if checked:
                            do_highlight()
                        else:
                            clear_highlight()
                    
                    highlightBtn.toggled.connect(on_highlight_toggled)
                    
                    # Connect combo changes to update highlights when button is active
                    def on_combo0_changed():
                        if highlightBtn.isChecked():
                            self._highlightDualFieldWidget(widget, SC)
                    
                    def on_combo1_changed():
                        if highlightBtn.isChecked():
                            self._highlightDualFieldWidget(widget, SC)
                    
                    # Connect the combo change signals
                    try:
                        if hasattr(combo0, 'currentIndexChanged'):
                            combo0.currentIndexChanged.connect(on_combo0_changed)
                        if hasattr(combo1, 'currentIndexChanged'):
                            combo1.currentIndexChanged.connect(on_combo1_changed)
                        debugLog(f"üîó [Dual-Field] Connected combo change signals for {fieldName}", origin="AutoGeneratedForm")
                    except Exception as e:
                        debugLog(f"‚ö†Ô∏è [Dual-Field] Failed to connect combo change signals for {fieldName}: {e}", origin="AutoGeneratedForm")
                    
                    # Add the button to the widget layout
                    layout = widget.layout() if hasattr(widget, 'layout') and callable(widget.layout) else None
                    if layout is not None:
                        layout.addWidget(highlightBtn)
                    else:
                        # Create a horizontal layout for the widget and button
                        container = QWidget()
                        layout = QHBoxLayout(container)
                        layout.setContentsMargins(0, 0, 0, 0)
                        layout.addWidget(widget)
                        layout.addWidget(highlightBtn)
                        
                        # Replace the original widget in the form
                        self.fields[fieldName] = container
                        container.original_widget = widget  # Keep reference to original
                        container.highlightBtn = highlightBtn
                        container.getValue = widget.getValue if hasattr(widget, 'getValue') else lambda: None
                    
                    debugLog(f"üé® [Dual-Field] Added highlight button for {fieldName} with colors: combo0={color0}, combo1={color1}", origin="AutoGeneratedForm")
                    connected_count += 1
                else:
                    debugLog(f"‚ö†Ô∏è [Dual-Field] Could not find dual combo boxes in {fieldName}", origin="AutoGeneratedForm")
        
        return connected_count

    def _getItemType(self, highlight_type):
        """Helper method to convert highlight_type string to Exudyn ItemType."""
        from exudyn import ItemType
        
        item_type_mapping = {
            'Object': ItemType.Object,
            'Node': ItemType.Node,
            'Marker': ItemType.Marker,
            'Load': ItemType.Load,
            'Sensor': ItemType.Sensor
        }
        
        return item_type_mapping.get(highlight_type, ItemType._None)

    def _connectSingleFieldToHighlighting(self, fieldName, widget, SC, highlight_type):
        """Connect a single field widget to multi-color highlighting."""
        try:
            field_color = self._getFieldColor(fieldName)
            
            # Connect different widget types to highlighting with field-specific color
            if hasattr(widget, 'combo'):  # Special widgets with combo box
                widget.combo.currentIndexChanged.connect(
                    lambda index, fname=fieldName: self._highlightItemWithColor(SC, highlight_type, widget.combo.currentData(), fname)
                )
            elif hasattr(widget, 'currentIndexChanged'):  # QComboBox
                widget.currentIndexChanged.connect(
                    lambda index, fname=fieldName: self._highlightItemWithColor(SC, highlight_type, widget.currentData(), fname)
                )
            elif hasattr(widget, 'currentTextChanged'):  # QComboBox text changes
                widget.currentTextChanged.connect(
                    lambda text, fname=fieldName: self._highlightItemWithColor(SC, highlight_type, self._parseIndexFromText(text), fname)
                )
            elif hasattr(widget, 'textChanged'):  # QLineEdit
                widget.textChanged.connect(
                    lambda text, fname=fieldName: self._highlightItemWithColor(SC, highlight_type, self._parseIndexFromText(text), fname)
                )
                
            debugLog(f"üîó [Single-Field] Connected {fieldName} with color {field_color}", origin="AutoGeneratedForm")
            
        except Exception as e:
            debugLog(f"Failed to connect single field highlighting for {fieldName}: {e}", origin="AutoGeneratedForm")

    def _highlightItemWithColor(self, SC, highlight_type, item_index, fieldName):
        """Set highlighting in the 3D renderer for the specified item with field-specific color."""
        debugLog(f"üéØ [Multi-Color] _highlightItemWithColor called: field={fieldName}, type={highlight_type}, index={item_index}", origin="AutoGeneratedForm")
        
        try:
            if item_index is None:
                # Clear highlighting for this field
                debugLog(f"üéØ [Multi-Color] Clearing highlighting for field {fieldName}", origin="AutoGeneratedForm")
                if fieldName in self._activeHighlights:
                    del self._activeHighlights[fieldName]
                self._updateActiveHighlighting(SC)
                return
                
            # Convert to integer if needed
            if isinstance(item_index, str):
                try:
                    item_index_int = int(item_index)
                    debugLog(f"üéØ [Multi-Color] Converted string '{item_index}' to int", origin="AutoGeneratedForm")
                    item_index = item_index_int
                except (ValueError, TypeError):
                    debugLog(f"‚ö†Ô∏è [Multi-Color] Failed to convert '{item_index}' to int", origin="AutoGeneratedForm")
                    return
            # Import ItemType and map highlight_type to ItemType
            from exudyn import ItemType
            
            item_type_mapping = {
                'Object': ItemType.Object,
                'Node': ItemType.Node,
                'Marker': ItemType.Marker,
                'Load': ItemType.Load,
                'Sensor': ItemType.Sensor
            }
            
            item_type = item_type_mapping.get(highlight_type)
            if not item_type:
                debugLog(f"‚ùå [Multi-Color] Unknown highlight type: {highlight_type}", origin="AutoGeneratedForm")
                return
                
            # Get field-specific color
            field_color = self._fieldColors.get(fieldName, self._predefinedColors['primary'])
            
            debugLog(f"üéØ [Multi-Color] Mapped {highlight_type} to {item_type} with color {field_color}", origin="AutoGeneratedForm")
            
            # Update active highlights tracking
            self._activeHighlights[fieldName] = {
                'type': item_type,
                'index': item_index,
                'color': field_color
            }
            
            # Update the active highlighting in the renderer
            self._updateActiveHighlighting(SC)
                
        except Exception as e:
            debugLog(f"‚ùå [Multi-Color] Failed to highlight item {item_index} of type {highlight_type}: {e}", origin="AutoGeneratedForm")
    
    
    
    def _updateActiveHighlighting(self, SC):
        """Update the renderer to show the currently active highlights with rotation if multiple."""
        try:
            if not hasattr(SC, 'visualizationSettings') or not hasattr(SC.visualizationSettings, 'interactive'):
                debugLog(f"‚ö†Ô∏è [Multi-Color] No visualizationSettings.interactive available", origin="AutoGeneratedForm")
                return
                
            active_highlights = list(self._activeHighlights.values())
            
            if not active_highlights:                # No active highlights - clear everything
                from exudyn import ItemType
                SC.visualizationSettings.interactive.highlightItemType = ItemType._None
                SC.visualizationSettings.interactive.highlightItemIndex = -1
                debugLog(f"‚úÖ [Multi-Color] Cleared all highlighting", origin="AutoGeneratedForm")
                
                # üöÄ Force OpenGL window refresh to show changes
                self._refreshOpenGLRenderer()
                
                # Stop any rotation timer
                if hasattr(self, '_highlightRotationTimer') and self._highlightRotationTimer:
                    self._highlightRotationTimer.stop()
                    self._highlightRotationTimer = None
                
            elif len(active_highlights) == 1:
                # Single highlight - show it directly with its color
                highlight = active_highlights[0]
                SC.visualizationSettings.interactive.highlightItemType = highlight['type']
                SC.visualizationSettings.interactive.highlightItemIndex = highlight['index']
                  # Apply color if the renderer supports it
                if hasattr(SC.visualizationSettings.interactive, 'highlightColor'):
                    SC.visualizationSettings.interactive.highlightColor = highlight['color']
                
                debugLog(f"‚úÖ [Multi-Color] Single highlight: {highlight['type']} #{highlight['index']} with color {highlight['color']}", origin="AutoGeneratedForm")
                
                # üöÄ Force OpenGL window refresh to show highlighting
                self._refreshOpenGLRenderer()
                
                # Stop any rotation timer
                if hasattr(self, '_highlightRotationTimer') and self._highlightRotationTimer:
                    self._highlightRotationTimer.stop()
                    self._highlightRotationTimer = None
                
            else:
                # Multiple highlights - start rotation
                debugLog(f"üîÑ [Multi-Color] Starting rotation for {len(active_highlights)} highlights", origin="AutoGeneratedForm")
                self._startHighlightRotation(SC, active_highlights)

        except Exception as e:
            debugLog(f"‚ùå [Multi-Color] Failed to update active highlighting: {e}", origin="AutoGeneratedForm")

    def _startHighlightRotation(self, SC, highlights):
        """Start rotating between multiple highlights with different colors."""
        try:
            from PyQt5.QtCore import QTimer
            
            # Stop any existing timer
            if hasattr(self, '_highlightRotationTimer') and self._highlightRotationTimer:
                self._highlightRotationTimer.stop()
            
            # Set up rotation state
            self._rotationHighlights = highlights
            self._rotationIndex = 0
            self._rotationSC = SC
            
            # Create and start timer (rotate every 1.5 seconds)
            self._highlightRotationTimer = QTimer()
            self._highlightRotationTimer.timeout.connect(self._rotateHighlight)
            self._highlightRotationTimer.start(1500)  # 1.5 seconds
            
            # Show first highlight immediately
            self._rotateHighlight()
            
            debugLog(f"üîÑ [Multi-Color] Started highlight rotation with {len(highlights)} items", origin="AutoGeneratedForm")
        except Exception as e:
            debugLog(f"‚ùå [Multi-Color] Failed to start highlight rotation: {e}", origin="AutoGeneratedForm")
    
    def _rotateHighlight(self):
        """Rotate to the next highlight in the sequence."""
        try:
            if not hasattr(self, '_rotationHighlights') or not self._rotationHighlights:
                return
                
            # Get current highlight
            current_highlight = self._rotationHighlights[self._rotationIndex]
            
            # Apply to renderer
            self._rotationSC.visualizationSettings.interactive.highlightItemType = current_highlight['type']
            self._rotationSC.visualizationSettings.interactive.highlightItemIndex = current_highlight['index']
            
            # Apply color if supported
            if hasattr(self._rotationSC.visualizationSettings.interactive, 'highlightColor'):
                self._rotationSC.visualizationSettings.interactive.highlightColor = current_highlight['color']
            
            debugLog(f"üîÑ [Multi-Color] Rotated to highlight {self._rotationIndex}: {current_highlight['type']} #{current_highlight['index']} with color {current_highlight['color']}", origin="AutoGeneratedForm")
            
            # üöÄ Force OpenGL window refresh to show rotation
            self._refreshOpenGLRenderer()
            
            # Advance to next highlight
            self._rotationIndex = (self._rotationIndex + 1) % len(self._rotationHighlights)
            
        except Exception as e:
            debugLog(f"‚ùå [Multi-Color] Failed to rotate highlight: {e}", origin="AutoGeneratedForm")
    
    def _parseIndexFromText(self, text):
        """Parse an index number from text that might be in format '0 - Object_0' or just '0'."""
        if not text:
            return None

        try:
            # Try to extract just the number part
            if ' - ' in text:
                return int(text.split(' - ')[0])
            else:
                return int(text)
        except (ValueError, TypeError):
            return None
        

    def _connectFieldToHighlighting(self, fieldName, widget, SC, highlight_mappings):
        """Connect a specific field widget to renderer highlighting."""
        try:
            # Find the matching highlight type
            highlight_type = None
            for key, value in highlight_mappings.items():
                if fieldName.lower() == key.lower():
                    highlight_type = value
                    break
                    
            if not highlight_type:
                return
            
            # Determine field-specific color based on field name
            field_color = self._getFieldColor(fieldName)
                
            # Connect different widget types to highlighting with color
            if hasattr(widget, 'combo'):  # Special widgets with combo box
                widget.combo.currentIndexChanged.connect(
                    lambda index: self._highlightItemWithColor(SC, highlight_type, widget.combo.currentData(), fieldName)
                )
            elif hasattr(widget, 'currentIndexChanged'):  # QComboBox
                widget.currentIndexChanged.connect(
                    lambda index: self._highlightItemWithColor(SC, highlight_type, widget.currentData(), fieldName)
                )
            elif hasattr(widget, 'currentTextChanged'):  # QComboBox text changes
                widget.currentTextChanged.connect(
                    lambda text: self._highlightItemWithColor(SC, highlight_type, self._parseIndexFromText(text), fieldName)
                )
            elif hasattr(widget, 'textChanged'):  # QLineEdit
                widget.textChanged.connect(
                    lambda text: self._highlightItemWithColor(SC, highlight_type, self._parseIndexFromText(text), fieldName)
                )
        except Exception as e:
            debugLog(f"Failed to connect highlighting for {fieldName}: {e}", origin="AutoGeneratedForm")

    def _getFieldColor(self, fieldName):
        """Get the color assigned to a specific field for highlighting."""
        if fieldName in self._fieldColors:
            return self._fieldColors[fieldName]
        
        # Assign a color based on field name if not already assigned
        field_lower = fieldName.lower()
        
        # Try to map common field patterns to colors
        if 'body0' in field_lower or 'left' in field_lower or 'first' in field_lower:
            color = self._predefinedColors['primary']  # Red
        elif 'body1' in field_lower or 'right' in field_lower or 'second' in field_lower:
            color = self._predefinedColors['secondary']  # Blue
        elif any(word in field_lower for word in ['node0', 'node1', 'nodelist']):
            color = self._predefinedColors['tertiary']  # Green
        else:
            # Default to primary color
            color = self._predefinedColors['primary']
        
        self._fieldColors[fieldName] = color
        debugLog(f"üé® [Highlighting] Assigned color {color} to field {fieldName}", origin="AutoGeneratedForm")
        return color

    def _clearHighlighting(self, SC):
        """Clear any active highlighting in the 3D renderer."""
        try:
            if hasattr(SC, 'visualizationSettings') and hasattr(SC.visualizationSettings, 'interactive'):
                from exudyn import ItemType
                SC.visualizationSettings.interactive.highlightItemType = ItemType._None
                SC.visualizationSettings.interactive.highlightItemIndex = -1
            if hasattr(SC.visualizationSettings.interactive, 'highlightColor'):
                SC.visualizationSettings.interactive.highlightColor = [0, 0, 0, 0]
            # Optionally stop any highlight rotation timer
            if hasattr(self, '_highlightRotationTimer') and self._highlightRotationTimer:
                self._highlightRotationTimer.stop()
                self._highlightRotationTimer = None
            # Clear active highlights tracking
            if hasattr(self, '_activeHighlights'):
                self._activeHighlights.clear()
            # Debug log
            debugLog(f"[Highlighting] Cleared all highlights", origin="AutoGeneratedForm")
        except Exception as e:
            debugLog(f"[Highlighting] Failed to clear highlighting: {e}", origin="AutoGeneratedForm")

    def _refreshOpenGLRenderer(self):
        """Force the OpenGL renderer to refresh and show highlighting changes."""
        try:
            # Try to get the main window and force a renderer refresh
            if hasattr(self, 'parent') and self.parent:
                if hasattr(self.parent, 'rendererSettings') and hasattr(self.parent.rendererSettings, 'openGL'):
                    # Force OpenGL window update
                    self.parent.rendererSettings.openGL.forceRedraw = True
                    debugLog(f"üöÄ [Multi-Color] Forced OpenGL refresh via parent.rendererSettings", origin="AutoGeneratedForm")
                    return

                if hasattr(self.parent, 'forceOpenGLUpdate'):
                    self.parent.forceOpenGLUpdate()
                    debugLog(f"üöÄ [Multi-Color] Forced OpenGL refresh via parent.forceOpenGLUpdate()", origin="AutoGeneratedForm")
                    return

                if hasattr(self.parent, 'update'):
                    self.parent.update()
                    debugLog(f"üöÄ [Multi-Color] Forced refresh via parent.update()", origin="AutoGeneratedForm")
                    return

            # Try global OpenGL activation functions
            try:
                from guiForms.exudynNativeRenderer import activateOpenGL
                activateOpenGL()
                debugLog(f"üöÄ [Multi-Color] Forced OpenGL refresh via activateOpenGL()", origin="AutoGeneratedForm")
            except ImportError:
                debugLog(f"‚ö†Ô∏è [Multi-Color] Could not import activateOpenGL for refresh", origin="AutoGeneratedForm")

        except Exception as e:
            debugLog(f"‚ùå [Multi-Color] Failed to refresh OpenGL renderer: {e}", origin="AutoGeneratedForm")

    def _replayHighlightState(self):
        """Re-apply the highlight state for bodyNumber after renderer restarts, with a short delay."""
        from PyQt5.QtCore import QTimer
        from guiForms.specialWidgets import setupRendererHighlighting
        widget = self.fields.get('bodyNumber')
        def do_replay():
            if widget and hasattr(widget, 'highlightBtn'):
                if widget.highlightBtn.isChecked():
                    selected_text = widget.combo.currentText()
                    try:
                        selected_index = int(selected_text)
                        setupRendererHighlighting(self, selected_index)
                    except (ValueError, TypeError):
                        setupRendererHighlighting(self, None)
                else:
                    setupRendererHighlighting(self, None)
        # Delay to ensure renderer is ready
        QTimer.singleShot(200, do_replay)

    def _updateDualFieldHighlights(self):
        """Update highlights for all dual-field widgets that have their highlight buttons active."""
        try:
            SC = None
            if hasattr(self, 'SC') and self.SC:
                SC = self.SC
            elif hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'SC'):
                SC = self.parent.SC
            
            if not SC:
                return
            
            # Check all dual-field widgets and update their highlights if buttons are active
            for fieldName, widget in self.fields.items():
                # Handle container widgets
                if hasattr(widget, 'original_widget'):
                    widget = widget.original_widget
                
                # Check if this is a dual-field widget with an active highlight button
                if hasattr(widget, 'highlightBtn') and widget.highlightBtn.isChecked():
                    if hasattr(widget, 'combo0') and hasattr(widget, 'combo1'):
                        self._highlightDualFieldWidget(widget, SC)
            
        except Exception as e:
            debugLog(f"‚ùå [Dual-Field] Failed to update dual field highlights: {e}", origin="AutoGeneratedForm")

    def _highlightDualFieldWidget(self, widget, SC):
        """Highlight a specific dual-field widget with its current combo values."""
        try:
            # Only proceed if widget has combo0 and combo1
            if not (hasattr(widget, 'combo0') and hasattr(widget, 'combo1')):
                return

            # Get current values from both combo boxes
            item0 = widget.combo0.currentData()
            item1 = widget.combo1.currentData()
            
            # Clear any existing highlights for this field
            fieldName = getattr(widget, 'fieldName', repr(widget))
            if f"{fieldName}_0" in self._activeHighlights:
                del self._activeHighlights[f"{fieldName}_0"]
            if f"{fieldName}_1" in self._activeHighlights:
                del self._activeHighlights[f"{fieldName}_1"]
            
            # Add highlights for both items if they have valid data
            if item0 is not None:
                self._activeHighlights[f"{fieldName}_0"] = {
                    'type': self._getItemType(getattr(widget, 'highlight_type', 'Object')),
                    'index': item0,
                    'color': self._fieldColors.get(f"{fieldName}_0", [0.8, 0.05, 0.05, 0.75])
                }
            
            if item1 is not None:
                self._activeHighlights[f"{fieldName}_1"] = {
                    'type': self._getItemType(getattr(widget, 'highlight_type', 'Object')),
                    'index': item1,
                    'color': self._fieldColors.get(f"{fieldName}_1", [0.05, 0.05, 0.8, 0.75])
                }
            
            # Update the renderer
            self._updateActiveHighlighting(SC)
            debugLog(f"üé® [Dual-Field] Updated highlight for {fieldName}: item0={item0}, item1={item1}", origin="AutoGeneratedForm")
            
        except Exception as e:
            debugLog(f"‚ùå [Dual-Field] Failed to highlight widget {getattr(widget, 'fieldName', repr(widget))}: {e}", origin="AutoGeneratedForm")

    def _updateDualFieldHighlights(self):
        """Update highlights for all dual-field widgets that have their highlight buttons active."""
        try:
            SC = None
            if hasattr(self, 'SC') and self.SC:
                SC = self.SC
            elif hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'SC'):
                SC = self.parent.SC
            
            if not SC:
                return
            
            # Check all dual-field widgets and update their highlights if buttons are active
            for fieldName, widget in self.fields.items():
                # Handle container widgets
                if hasattr(widget, 'original_widget'):
                    widget = widget.original_widget
                
                # Check if this is a dual-field widget with an active highlight button
                if hasattr(widget, 'highlightBtn') and widget.highlightBtn.isChecked():
                    if hasattr(widget, 'combo0') and hasattr(widget, 'combo1'):
                        self._highlightDualFieldWidget(widget, SC)
            
        except Exception as e:
            debugLog(f"‚ùå [Dual-Field] Failed to update dual field highlights: {e}", origin="AutoGeneratedForm")

    def _replayHighlightState(self):
        """Replay the current highlight state after renderer restarts."""
        try:
            # Update dual-field highlights if any buttons are active
            self._updateDualFieldHighlights()
            
            # Also replay any other active highlights
            if hasattr(self, '_activeHighlights') and self._activeHighlights:
                SC = None
                if hasattr(self, 'SC') and self.SC:
                    SC = self.SC
                elif hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'SC'):
                    SC = self.parent.SC
                
                if SC:
                    self._updateActiveHighlighting(SC)
                    debugLog(f"üîÑ [Highlight] Replayed highlight state with {len(self._activeHighlights)} active highlights", origin="AutoGeneratedForm")
            
        except Exception as e:
            debugLog(f"‚ùå [Highlight] Failed to replay highlight state: {e}", origin="AutoGeneratedForm")
